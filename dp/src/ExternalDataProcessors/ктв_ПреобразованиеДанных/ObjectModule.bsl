// ----------------------------------------------------------
// This Source Code Form is subject to the terms of the
// Mozilla Public License, v.2.0. If a copy of the MPL
// was not distributed with this file, You can obtain one
// at http://mozilla.org/MPL/2.0/.
// ----------------------------------------------------------
// Codebase: https://github.com/ArKuznetsov/SerLib1C/
// ----------------------------------------------------------

#Область ОписаниеПеременных

Перем ПравилаВыгрузкиТипов; // - Соответствие   - правила выгрузки типов (см. ПолучитьПравилаВыгрузкиТипов())
Перем ПравилаЗагрузкиТипов; // - Соответствие   - правила загрузки типов (см. ПолучитьПравилаЗагрузкиТипов())

Перем Совместимость8_3;     // - Соответствие   - флаги совместимости с релизами 8.3

Перем КэшМетаданных;        // - Соответствие   - кэш объектов метаданных
Перем КэшОписанийТипов;     // - Соответствие   - кэш описаний типов метаданных
Перем КэшСсылок;            // - Соответствие   - кэш ссылок на обработанные объекты

#КонецОбласти // ОписаниеПеременных

#Область ПрограммныйИнтерфейс

#Область ПреобразованияОбъектовОбщие

// Преобразует переданное значение в структуру, значения атомарных типов, возвращаются как есть
//
// Параметры:
//  Значение    - Произвольный    - Преобразуемое значение
//
// Возвращаемое значение:
//   Структура, Массив, Число, Строка, Дата, Булево    - результат преобразования
//
Функция ЗначениеВСтруктуру(Значение) Экспорт

	ТипЗначения = ТипЗнч(Значение);

	ЭтоПростойТип = (ТипЗначения = Тип("Строка")
	             ИЛИ ТипЗначения = Тип("Число")
	             ИЛИ ТипЗначения = Тип("Булево")
	             ИЛИ ТипЗначения = Тип("Дата")
	             ИЛИ ТипЗначения = Тип("ХранилищеЗначения")
	             ИЛИ ТипЗначения = Тип("УникальныйИдентификатор")
	             ИЛИ ТипЗначения = Тип("NULL")
	             ИЛИ ТипЗначения = Тип("Неопределено"));

	Если ЭтоПростойТип Тогда
		Возврат Значение;
	КонецЕсли;

	Если ТипЗначения = Тип("Массив")
		  ИЛИ ТипЗначения = Тип("ФиксированныйМассив") Тогда
		Возврат МассивВСтруктуру(Значение);
	КонецЕсли;

	Если ТипЗначения = Тип("Структура")
		  ИЛИ ТипЗначения = Тип("ФиксированнаяСтруктура") Тогда
		Возврат СтруктураВСтруктуру(Значение);
	КонецЕсли;

	Если ТипЗначения = Тип("Соответствие")
		  ИЛИ ТипЗначения = Тип("ФиксированноеСоответствие") Тогда
		Возврат СоответствиеВСтруктуру(Значение);
	КонецЕсли;

	Если ТипЗначения = Тип("СписокЗначений") Тогда
		Возврат СписокЗначенийВСтруктуру(Значение);
	КонецЕсли;

	Если ТипЗначения = Тип("ТаблицаЗначений") Тогда
		Возврат ТаблицаЗначенийВСтруктуру(Значение);
	КонецЕсли;

	Если ТипЗначения = Тип("ДеревоЗначений") Тогда
		Возврат ДеревоЗначенийВСтруктуру(Значение);
	КонецЕсли;

	Если ТипЗначения = Тип("ОписаниеТипов") Тогда
		Возврат ОписаниеТиповВСтруктуру(Значение);
	КонецЕсли;

	Если ТипЗначения = Тип("УдалениеОбъекта") Тогда
		Возврат УдалениеОбъектаВСтруктуру(Значение);
	КонецЕсли;

	Если ЭтоСсылка(Значение) Тогда
		Возврат СсылкаВСтруктуру(Значение);
	КонецЕсли;

	Если ЭтоОбъект(Значение) Тогда
		Возврат ОбъектВСтруктуру(Значение);
	КонецЕсли;

	Если ЭтоНаборЗаписейРегистра(Значение) Тогда
		Возврат НаборЗаписейРегистраВСтруктуру(Значение);
	КонецЕсли;

	Возврат Значение;

КонецФункции // ЗначениеВСтруктуру()

// Получает значение из переданного описания, значения атомарных типов, возвращаются как есть
//
// Параметры:
//  СтруктураЗначения      - Структура, Число, Строка    - Описание значение
//                           Дата, Булево
//  ПолучатьБитыеСсылки    - Булево                        - Истина - если объект по ссылке не существует,
//                                                           будет возвращена битая ссылка;
//                                                           Ложь - будет возвращена пустая ссылка
//
// Возвращаемое значение:
//   Произвольный     - результат преобразования
//
// TODO: продумать управление получением битых ссылок
//
Функция ЗначениеИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки = Ложь) Экспорт

	ТипЗначения = ТипЗнч(СтруктураЗначения);

	ЭтоПростойТип = (ТипЗначения = Тип("Строка")
	             ИЛИ ТипЗначения = Тип("Число")
	             ИЛИ ТипЗначения = Тип("Булево")
	             ИЛИ ТипЗначения = Тип("Дата")
	             ИЛИ ТипЗначения = Тип("ХранилищеЗначения")
	             ИЛИ ТипЗначения = Тип("УникальныйИдентификатор")
	             ИЛИ ТипЗначения = Тип("NULL")
	             ИЛИ ТипЗначения = Тип("Неопределено"));

	Если ЭтоПростойТип Тогда
		Возврат СтруктураЗначения;
	КонецЕсли;

	ТипЗначения = СтруктураТипЗнч(СтруктураЗначения);

	Если ТипЗначения = Тип("Массив") Тогда
		Возврат МассивИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки);
	КонецЕсли;

	Если ТипЗначения = Тип("Структура") Тогда
		Возврат СтруктураИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки);
	КонецЕсли;

	Если ТипЗначения = Тип("Соответствие") Тогда
		Возврат СоответствиеИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки);
	КонецЕсли;

	Если ТипЗначения = Тип("СписокЗначений") Тогда
		Возврат СписокЗначенийИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки);
	КонецЕсли;

	Если ТипЗначения = Тип("ТаблицаЗначений") Тогда
		Возврат ТаблицаЗначенийИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки);
	КонецЕсли;

	Если ТипЗначения = Тип("ДеревоЗначений") Тогда
		Возврат ДеревоЗначенийИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки);
	КонецЕсли;

	Если ТипЗначения = Тип("ОписаниеТипов") Тогда
		Возврат ОписаниеТиповИзСтруктуры(СтруктураЗначения);
	КонецЕсли;

	Если ТипЗначения = Тип("УдалениеОбъекта") Тогда
		Возврат УдалениеОбъектаИзСтруктуры(СтруктураЗначения);
	КонецЕсли;

	Если ЭтоСсылка(СтруктураЗначения) Тогда
		Возврат СсылкаИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки);
	КонецЕсли;

	Если ЭтоОбъект(СтруктураЗначения) Тогда
		Возврат СоздатьОбъектИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки);
	КонецЕсли;

	Если ЭтоНаборЗаписейРегистра(СтруктураЗначения) Тогда
		Возврат СоздатьНаборЗаписейРегистраИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки);
	КонецЕсли;

	Возврат СтруктураЗначения;

КонецФункции // ЗначениеИзСтруктуры()

// Преобразует значение ссылочного типа в структуру
//
// Параметры:
//  Объект              - Объект, ЛюбаяСсылка       - преобразуемый объект
//  СписокСвойств       - Строка, Массив из Строка  - список допустимых свойств
//                                                    (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив из Строка  - список исключаемых свойств
//                                                    (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура                                         - результат преобразования
//     *Ссылка                       - Структура         - описание ссылки на объект
//       **Тип                         - Строка            - текстовое описание типа объекта
//       **Ид                          - Строка            - уникальный идентификатор ссылки
//       **ИдПолный                    - Строка            - преставление ссылки на объект,
//                                                           полученное функцией ЗначениеВСтрокуВнутр
//       **Предопределенный            - Булево            - Истина - предопределенное значение
//                                                           Ложь - в противном случае
//       **ИмяПредопределенныхДанных   - Строка            - имя предопределенного значения
//       **Представление               - Строка            - стандатрное строковое представление объекта
//       **<имя поля>                  - Произвольный      - дополнительные поля добавленные при выгрузке
//     *__ТЧ                         - Массив            - табличные части объекта
//     *<имя поля>                   - Произвольный      - значения реквизитов объекта
//
Функция ОбъектВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт

	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипЗнч(Объект));

	Если ОписаниеВида = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;

	СтруктураОбъекта = Неопределено;

	Если ПредставленияРавны(ОписаниеВида.Имя, "Справочник") Тогда
		СтруктураОбъекта = СправочникВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "Документ") Тогда
		СтруктураОбъекта = ДокументВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "ПланВидовХарактеристик") Тогда
		СтруктураОбъекта = ПланВидовХарактеристикВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "ПланСчетов") Тогда
		СтруктураОбъекта = ПланСчетовВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "ПланВидовРасчета") Тогда
		СтруктураОбъекта = ПланВидовРасчетаВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "ПланОбмена") Тогда
		СтруктураОбъекта = ПланОбменаВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "БизнесПроцесс") Тогда
		СтруктураОбъекта = БизнесПроцессВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "Задача") Тогда
		СтруктураОбъекта = ЗадачаВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	Иначе
		ПоказатьСообщение(СтрШаблонВнутр("Неизвестный тип объекта: %1", Объект));
	КонецЕсли;

	Возврат СтруктураОбъекта;

КонецФункции // ОбъектВСтруктуру()

// Находит объект (ссылочного типа) по имени предопределенных данных
// или по идентификатору и заполняет из структуры
//
// Параметры:
//  СтруктураОбъекта              - Структура        - данные для заполнения объекта
//    *Ссылка                       - Структура        - описание ссылки на объект
//       **Тип                        - Строка           - текстовое описание типа объекта
//       **Ид                         - Строка           - уникальный идентификатор ссылки
//       **ИдПолный                   - Строка           - преставление ссылки на объект,
//                                                         полученное функцией ЗначениеВСтрокуВнутр
//       **Предопределенный           - Булево           - Истина - предопределенное значение
//                                                         Ложь - в противном случае
//       **ИмяПредопределенныхДанных  - Строка           - имя предопределенного значения
//       **Представление              - Строка           - стандатрное строковое представление объекта
//       **<имя поля>                 - Произвольный     - дополнительные поля добавленные при выгрузке
//     *__ТЧ                        - Массив           - табличные части объекта
//     *<имя поля>                  - Произвольный     - значения реквизитов объекта
//  Создавать                       - Булево           - Истина - если объект не найден,
//                                                       будет создан новый объект (по умолчанию Ложь)
//  УстановитьСсылку                - Булево           - установить ссылку из СтруктураОбъекта
//  ПолучатьБитыеСсылки             - Булево           - Истина - если объект по ссылке не существует,
//                                                       будет возвращена битая ссылка;
//                                                       Ложь - будет возвращена пустая ссылка
//  СписокСвойств         - Строка, Массив из Строка  - список допустимых свойств
//                                                      (если пустой, то допустимы все свойства)
//  ИсключаяСвойства      - Строка, Массив из Строка  - список исключаемых свойств
//                                                      (если пустой, то допустимы все свойства)
//
Функция НайтиЗаполнитьОбъектИзСтруктуры(СтруктураОбъекта,
                                        Создавать = Ложь,
                                        УстановитьСсылку = Истина,
                                        ПолучатьБитыеСсылки = Ложь,
                                        СписокСвойств = Неопределено,
                                        ИсключаяСвойства = Неопределено) Экспорт

	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(СтруктураОбъекта);

	МетаОбъект = ОписаниеВида.МетаКоллекция.Найти(ОписаниеВида.ИмяТипа);

	Значение = НайтиЗначениеПоОписанию(ОписаниеВида, МетаОбъект, СтруктураОбъекта.Ссылка);
	
	Объект = Неопределено;
	Попытка
		Объект = Значение.ПолучитьОбъект();
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ТекстОшибки = СтрШаблон("Объект не найден ""%1"":%2%3",
		                        СтруктураОбъекта.Ссылка.Представление,
		                        Символы.ПС,
		                        ТекстОшибки);
	КонецПопытки;
	
	Если Объект = Неопределено И Создавать Тогда
		Объект = СоздатьОбъектИзСтруктуры(СтруктураОбъекта, УстановитьСсылку, ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли НЕ Объект = Неопределено Тогда
		ЗаполнитьОбъектИзСтруктуры(Объект, СтруктураОбъекта, ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Возврат Объект;

КонецФункции // НайтиЗаполнитьОбъектИзСтруктуры()

// Заполняет объект (ссылочного типа) из структуры
//
// Параметры:
//  Объект                        - Объект           - Заполняемый объект
//  СтруктураОбъекта              - Структура        - Данные для заполнения объекта
//    *Ссылка                       - Структура        - описание ссылки на объект
//       **Тип                        - Строка           - текстовое описание типа объекта
//       **Ид                         - Строка           - уникальный идентификатор ссылки
//       **ИдПолный                   - Строка           - преставление ссылки на объект,
//                                                         полученное функцией ЗначениеВСтрокуВнутр
//       **Предопределенный           - Булево           - Истина - предопределенное значение
//                                                         Ложь - в противном случае
//       **ИмяПредопределенныхДанных  - Строка           - имя предопределенного значения
//       **Представление              - Строка           - стандатрное строковое представление объекта
//       **<имя поля>                 - Произвольный     - дополнительные поля добавленные при выгрузке
//     *__ТЧ                        - Массив           - табличные части объекта
//     *<имя поля>                  - Произвольный     - значения реквизитов объекта
//  ПолучатьБитыеСсылки   - Булево                   - Истина - если объект по ссылке не существует,
//                                                     будет возвращена битая ссылка;
//                                                     Ложь - будет возвращена пустая ссылка
//  СписокСвойств         - Строка, Массив из Строка  - Список допустимых свойств
//                                                      (если пустой, то допустимы все свойства)
//  ИсключаяСвойства      - Строка, Массив из Строка  - Список исключаемых свойств
//                                                      (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Объект - найденны/созданный и заполненный объект
//
Процедура ЗаполнитьОбъектИзСтруктуры(Объект,
                                     СтруктураОбъекта,
                                     ПолучатьБитыеСсылки = Ложь,
                                     СписокСвойств = Неопределено,
                                     ИсключаяСвойства = Неопределено) Экспорт

	ТипОбъекта = "NULL";
	Если ЕстьСсылка(СтруктураОбъекта) И СтруктураОбъекта.Ссылка.Свойство("Тип") Тогда 
		ТипОбъекта = СтруктураОбъекта.Ссылка.Тип;
	ИначеЕсли ЕстьСсылка(СтруктураОбъекта) И ЕстьТип(СтруктураОбъекта.Ссылка) Тогда 
		ТипОбъекта = СтруктураОбъекта.Ссылка.__Тип;
	ИначеЕсли ЕстьТип(СтруктураОбъекта) Тогда 
		ТипОбъекта = СтруктураОбъекта.__Тип;
	Иначе
		ТекстОшибки = "Структура не содержит указания типа значения или не является представлением ссылочного объекта. Поля %1 объекта:";

		Если ЕстьСсылка(СтруктураОбъекта) Тогда
			ВремСтруктура = СтруктураОбъекта.Ссылка;
			ТекстОшибки = СтрШаблонВнутр(ТекстОшибки, "ссылки");
		Иначе
			ВремСтруктура = СтруктураОбъекта;
			ТекстОшибки = СтрШаблонВнутр(ТекстОшибки, "структуры");
		КонецЕсли;
		ДополнитьТекстПолямиСтруктуры(ТекстОшибки, ВремСтруктура);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;

	Попытка
		ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипОбъекта);
	Исключение
		ВызватьИсключение СтрШаблонВнутр("Ошибка получения описания вида объекта ""%1"": %2%3",
		                            ТипОбъекта,
		                            Символы.ПС,
		                            ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;

	Если ПредставленияРавны(ОписаниеВида.Имя, "Справочник") Тогда
		СправочникИзСтруктуры(Объект, СтруктураОбъекта, ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "Документ") Тогда
		ДокументИзСтруктуры(Объект, СтруктураОбъекта, ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "ПланВидовХарактеристик") Тогда
		ПланВидовХарактеристикИзСтруктуры(Объект,
		                                  СтруктураОбъекта,
		                                  ПолучатьБитыеСсылки,
		                                  СписокСвойств,
		                                  ИсключаяСвойства);
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "ПланСчетов") Тогда
		ПланСчетовИзСтруктуры(Объект, СтруктураОбъекта, ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "ПланВидовРасчета") Тогда
		ПланВидовРасчетаИзСтруктуры(Объект, СтруктураОбъекта, ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "ПланОбмена") Тогда
		ПланОбменаИзСтруктуры(Объект, СтруктураОбъекта, ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "БизнесПроцесс") Тогда
		БизнесПроцессИзСтруктуры(Объект, СтруктураОбъекта, ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "Задача") Тогда
		ЗадачаИзСтруктуры(Объект, СтруктураОбъекта, ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
	Иначе
		ПоказатьСообщение(СтрШаблонВнутр("Неизвестный тип объекта: %1", ТипОбъекта));
	КонецЕсли;

КонецПроцедуры // ЗаполнитьОбъектИзСтруктуры()

// Создает объект (ссылочного типа) из структуры
//
// Параметры:
//  СтруктураОбъекта               - Структура         - Данные для заполнения объекта
//     *Ссылка                       - Структура         - Описание ссылки на объект
//       **Тип                         - Строка            - Текстовое описание типа объекта
//       **Ид                          - Строка            - Уникальный идентификатор ссылки
//       **ИдПолный                    - Строка            - Преставление ссылки на объект,
//                                                           полученное функцией ЗначениеВСтрокуВнутр
//       **Предопределенный            - Булево            - Истина - предопределенное значение
//                                                           Ложь - в противном случае
//       **ИмяПредопределенныхДанных   - Строка            - Имя предопределенного значения
//       **Представление               - Строка            - Стандатрное строковое представление объекта
//       **<имя поля>                  - Произвольный      - Дополнительные поля добавленные при выгрузке
//     *__ТЧ                         - Массив            - Массив табличных частей объекта
//     *<имя поля>                   - Произвольный      - Значения реквизитов объекта
//  УстановитьСсылку               - Булево            - Установить ссылку из СтруктураОбъекта
//  ПолучатьБитыеСсылки            - Булево            - Истина - если объект по ссылке не существует,
//                                                       будет возвращена битая ссылка;
//                                                       Ложь - будет возвращена пустая ссылка
//  СписокСвойств                  - Строка            - Список допустимых свойств
//                                   Массив из Строка    (если пустой, то допустимы все свойства)
//  ИсключаяСвойства               - Строка            - Список исключаемых свойств
//                                   Массив из Строка    (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Объект             - созданный и заполненный объект
//
Функция СоздатьОбъектИзСтруктуры(СтруктураОбъекта,
                                 УстановитьСсылку = Ложь,
                                 ПолучатьБитыеСсылки = Ложь,
                                 СписокСвойств = Неопределено,
                                 ИсключаяСвойства = Неопределено) Экспорт

	ТипОбъекта = "NULL";
	Если ЕстьСсылка(СтруктураОбъекта) И СтруктураОбъекта.Ссылка.Свойство("Тип") Тогда 
		ТипОбъекта = СтруктураОбъекта.Ссылка.Тип;
	ИначеЕсли ЕстьСсылка(СтруктураОбъекта) И ЕстьТип(СтруктураОбъекта.Ссылка) Тогда 
		ТипОбъекта = СтруктураОбъекта.Ссылка.__Тип;
	ИначеЕсли ЕстьТип(СтруктураОбъекта) Тогда 
		ТипОбъекта = СтруктураОбъекта.__Тип;
	Иначе
		ТекстОшибки = "Структура не содержит указания типа значения или не является представлением ссылочного объекта. Поля %1 объекта:";

		Если ЕстьСсылка(СтруктураОбъекта) Тогда
			ВремСтруктура = СтруктураОбъекта.Ссылка;
			ТекстОшибки = СтрШаблонВнутр(ТекстОшибки, "ссылки");
		Иначе
			ВремСтруктура = СтруктураОбъекта;
			ТекстОшибки = СтрШаблонВнутр(ТекстОшибки, "структуры");
		КонецЕсли;
		ДополнитьТекстПолямиСтруктуры(ТекстОшибки, ВремСтруктура);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;

	Попытка
		ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипОбъекта);
	Исключение
		ВызватьИсключение СтрШаблонВнутр("Ошибка получения описания вида объекта ""%1"": %2%3",
		                            ТипОбъекта,
		                            Символы.ПС,
		                            ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;

	МетаОбъект = Метаданные.НайтиПоПолномуИмени(СтрШаблонВнутр("%1.%2", ОписаниеВида.Имя, ОписаниеВида.ИмяТипа));
	Менеджер = ОписаниеВида.Коллекция[МетаОбъект.Имя];

	Конструктор = ОписаниеВида.Конструктор;

	ИерархияГруппИЭлементов = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов;

	Если ПредставленияРавны(ОписаниеВида.Имя, "Справочник") Тогда
		Если ОписаниеВида.МетаКоллекция[МетаОбъект.Имя].Иерархический
		   И ОписаниеВида.МетаКоллекция[МетаОбъект.Имя].ВидИерархии = ИерархияГруппИЭлементов Тогда
			Если СтруктураОбъекта.ЭтоГруппа Тогда 
				Конструктор = ОписаниеВида.КонструкторАльт;
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "ПланВидовХарактеристик") Тогда
		Если ОписаниеВида.МетаКоллекция[МетаОбъект.Имя].Иерархический Тогда
			Если СтруктураОбъекта.ЭтоГруппа Тогда 
				Конструктор = ОписаниеВида.КонструкторАльт;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;

	Объект = Неопределено;

	Если ЗначениеЗаполнено(Конструктор) Тогда

		Объект = Вычислить(СтрШаблонВнутр("Менеджер.%1()", Конструктор));

		Если УстановитьСсылку Тогда
			НоваяСсылка = Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(СтруктураОбъекта.Ссылка.Ид)); 
			Объект.УстановитьСсылкуНового(НоваяСсылка);
		КонецЕсли;

		ЗаполнитьОбъектИзСтруктуры(Объект, СтруктураОбъекта, ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);

	КонецЕсли;

	Возврат Объект;

КонецФункции // СоздатьОбъектИзСтруктуры()

// Преобразует переданную ссылку в структуру, значения атомарных типов, возвращаются как есть
//
// Параметры:
//  Значение            - ЛюбаяСсылка                - Преобразуемое ссылка
//
// Возвращаемое значение:
//   Структура            - результат преобразования
//
Функция СсылкаВСтруктуру(Значение) Экспорт

	ОписаниеМетаданного = КэшМетаданных()[ТипЗнч(Значение)];

	Если НЕ ТипЗнч(ОписаниеМетаданного) = Тип("Структура") Тогда
		Возврат Значение;
	КонецЕсли;

	Если НЕ ТипЗнч(КэшСсылок) = Тип("Соответствие") Тогда
		КэшСсылок = Новый Соответствие();
	КонецЕсли;
	  
	ЗначениеИзКэша = КэшСсылок.Получить(Значение); 
	Если НЕ ЗначениеИзКэша = Неопределено Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;

	Предопределенный = Ложь;

	Если ОписаниеМетаданного.Коллекция = "Перечисления" Тогда

		ИмяПредопределенныхДанных = "";
		Если ЗначениеЗаполнено(Значение) Тогда
			Индекс = Перечисления[ОписаниеМетаданного.Имя].Индекс(Значение);
			ИмяПредопределенныхДанных = Метаданные.Перечисления[ОписаниеМетаданного.Имя].ЗначенияПеречисления.Получить(Индекс).Имя;
		КонецЕсли;

		Предопределенный = Истина;

		Ид = ИмяПредопределенныхДанных;

	Иначе

		ЕстьПредопределенные = (ОписаниеМетаданного.Коллекция = "Справочники"
		                    ИЛИ ОписаниеМетаданного.Коллекция = "ПланыВидовХарактеристик"
		                    ИЛИ ОписаниеМетаданного.Коллекция = "ПланыСчетов"
		                    ИЛИ ОписаниеМетаданного.Коллекция = "ПланыВидовРасчета");
		
		Если ЕстьПредопределенные Тогда
			Предопределенный = Значение.Предопределенный;
		ИначеЕсли ОписаниеМетаданного.Коллекция = "ПланыОбмена" Тогда
			Предопределенный = Значение.ЭтотУзел;
		Иначе
			Предопределенный = Ложь;
		КонецЕсли;

		Ид = СокрЛП(Значение.УникальныйИдентификатор());

	КонецЕсли;

	ОписаниеЗначения = Новый Структура();
	ОписаниеЗначения.Вставить("__Тип", СтрЗаменить(ОписаниеМетаданного.ПолноеИмя, ".", "Ссылка."));
	Если НЕ Значение.Пустая() Тогда
		ОписаниеЗначения.Вставить("Ид"                       , Ид);
		ОписаниеЗначения.Вставить("ИдПолный"                 , ЗначениеВСтрокуВнутр(Значение));
		ОписаниеЗначения.Вставить("Предопределенный"         , Предопределенный);
		ОписаниеЗначения.Вставить("ИмяПредопределенныхДанных", ПолучитьИмяПредопределенныхДанных(Значение));
		ОписаниеЗначения.Вставить("Представление"            , СокрЛП(Значение));
	КонецЕсли;

	ПравилоВыгрузки = ПолучитьПравилоВыгрузкиТипа(ОписаниеМетаданного.ПолноеИмя);

	Если ПравилоВыгрузки = Неопределено Тогда
		Возврат ОписаниеЗначения;
	КонецЕсли;

	КодДополненияЗначения = "";
	Если НЕ ПравилоВыгрузки.Модуль = Неопределено Тогда
		КодДополненияЗначения = КодДополненияЗначения + "ПравилоВыгрузки.Модуль.";
	КонецЕсли;

	КодДополненияЗначения = СтрШаблонВнутр("%1%2(ОписаниеЗначения, Значение);",
	                        КодДополненияЗначения,
	                        СокрЛП(ПравилоВыгрузки.ФункцияДополнения));

	Попытка
		Выполнить(КодДополненияЗначения);
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ТекстОшибки = СтрШаблонВнутр("Ошибка дополнения значения: ""%1""%2%3",
		                             СокрЛП(Значение),
									 Символы.ПС,
									 ТекстОшибки);
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;

	КэшСсылок.Вставить(Значение, ОписаниеЗначения);

	Возврат ОписаниеЗначения;

КонецФункции // СсылкаВСтруктуру()

// Получает ссылку по переданной структуре
//
// Параметры:
//  СтруктураЗначения           - Структура         - Структура описания ссылки
//  ПолучатьБитыеСсылки         - Булево            - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//
// Возвращаемое значение:
//   ЛюбаяСсылка            - полученная ссылка
// TODO: продумать управление получением битых ссылок
Функция СсылкаИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки = Ложь) Экспорт

	Если Не ТипЗнч(СтруктураЗначения) = Тип("Структура") Тогда
		Возврат СтруктураЗначения;
	КонецЕсли;

	Если ЕстьТип(СтруктураЗначения) Тогда
		ПравилоЗагрузки = ПолучитьПравилоЗагрузкиТипа(СтруктураЗначения.__Тип);
	ИначеЕсли СтруктураЗначения.Свойство("Тип") Тогда
		ПравилоЗагрузки = ПолучитьПравилоЗагрузкиТипа(СтруктураЗначения.Тип);
	Иначе
		ТекстОшибки = "Структура не содержит поля с типом значения или не является представлением ссылки. Поля: ";
		ДополнитьТекстПолямиСтруктуры(ТекстОшибки, СтруктураЗначения);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;

	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ПравилоЗагрузки.ТипЗначения);

	МетаОбъект = Метаданные.НайтиПоПолномуИмени(СтрШаблонВнутр("%1.%2", ОписаниеВида.Имя, ОписаниеВида.ИмяТипа));

	Если МетаОбъект = Неопределено Тогда
		ТекстОшибки = СтрШаблонВнутр("Не найден тип ""%1"" для значения: ""%2 (%3)""",
		                             ПравилоЗагрузки.ТипЗначения,
									 СтруктураЗначения.Представление,
									 СтруктураЗначения.Ид);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;

	Коллекция = ОписаниеВида.Коллекция;

	Результат = Коллекция[МетаОбъект.Имя].ПустаяСсылка();

	Если НЕ СтруктураЗначения.Свойство("Ид") Тогда
		Возврат Результат;
	КонецЕсли;

	Если СтруктураЗначения.Свойство("ИдПолный") И Найти(СтруктураЗначения.ИдПолный, "00000000000000000000000000000000") > 0 Тогда
		Возврат Результат;
	КонецЕсли;

	Если НЕ ТипЗнч(КэшСсылок) = Тип("Соответствие") Тогда
		КэшСсылок = Новый Соответствие();
	КонецЕсли;
	  
	КлючЗначения = СтрШаблонВнутр("%1#%2", СтруктураЗначения.__Тип, СтруктураЗначения.Ид);

	ЗначениеИзКэша = КэшСсылок.Получить(КлючЗначения); 
	Если НЕ ЗначениеИзКэша = Неопределено Тогда
		Возврат ЗначениеИзКэша;
	КонецЕсли;

	КодПоискаСсылки = "Результат = ";
	Если НЕ ПравилоЗагрузки.Модуль = Неопределено Тогда
		КодПоискаСсылки = КодПоискаСсылки + "ПравилоЗагрузки.Модуль.";
	КонецЕсли;

	КодПоискаСсылки = СтрШаблонВнутр("%1%2(ОписаниеВида, МетаОбъект, СтруктураЗначения);",
	                                 КодПоискаСсылки,
									 СокрЛП(ПравилоЗагрузки.ФункцияПоиска));

	Попытка
		Выполнить(КодПоискаСсылки);
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ТекстОшибки = СтрШаблонВнутр("Ошибка поиска ссылки по описанию:%1%2",
		                             Символы.ПС,
									 ТекстОшибки);
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;

	Если НЕ ЗначениеЗаполнено(Результат) Тогда
		ТекстСообщения = СтрШаблонВнутр("Не найдено значение ""%1"": ""%2 (%3)"".",
		                                МетаОбъект.ПолноеИмя(),
										?(СтруктураЗначения.Свойство("Представление"), СтруктураЗначения.Представление, ""),
										СтруктураЗначения.Ид);
		ПоказатьСообщение(ТекстСообщения);
		Если ПолучатьБитыеСсылки Тогда
			Результат = Коллекция[МетаОбъект.Имя].ПолучитьСсылку(Новый УникальныйИдентификатор(СтруктураЗначения.Ид));
		КонецЕсли;
	КонецЕсли;

	КэшСсылок.Вставить(КлючЗначения, Результат);

	Возврат Результат;

КонецФункции // СсылкаИзСтруктуры()

// Преобразует переданную ссылку объект или удаление объекта в структуру
//
// Параметры:
//  Значение    - УдалениеОбъекта    - Преобразуемое ссылка
//                ЛюбаяСсылка     
//                Объект
//
// Возвращаемое значение:
//   Структура    - результат преобразования
//
Функция УдалениеОбъектаВСтруктуру(Значение) Экспорт

	ОписаниеЗначения = Новый Структура();
	ОписаниеЗначения.Вставить("__Тип", "УдалениеОбъекта");

	Если ЭтоСсылка(Значение) Тогда
		Удаление = Новый УдалениеОбъекта(Значение);
	ИначеЕсли ЭтоОбъект(Значение) Тогда
		Удаление = Новый УдалениеОбъекта(Значение.Ссылка);
	ИначеЕсли ТипЗнч(Значение) = Тип("УдалениеОбъекта") Тогда
		Удаление = Значение;
	Иначе
		Возврат ОписаниеЗначения;
	КонецЕсли;

	ОписаниеЗначения.Вставить("Ссылка", СсылкаВСтруктуру(Удаление.Ссылка));

	Возврат ОписаниеЗначения;

КонецФункции // УдалениеОбъектаВСтруктуру()

// Получает объект типа удаление объекта из структуры
//
// Параметры:
//  СтруктураЗначения      - Структура    - Структура описания удаления объекта
//  ПолучатьБитыеСсылки    - Булево       - Истина - если объект по ссылке не существует,
//                                          будет возвращена битая ссылка;
//                                          Ложь - будет возвращена пустая ссылка
//
// Возвращаемое значение:
//   УдалениеОбъекта    - объект типа удаление объекта
//
Функция УдалениеОбъектаИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки = Ложь) Экспорт

	Если Не ТипЗнч(СтруктураЗначения) = Тип("Структура") Тогда
		ТекстОшибки = СтрШаблон("Некорректный тип параметра ""СтруктураЗначения"" ""%1""
		                        |Ожидается тип ""Структура"".",
		                        ТипЗнч(СтруктураЗначения));
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;

	Если НЕ ЕстьТип(СтруктураЗначения) Тогда
		ТекстОшибки = "Структура не содержит поля ""__Тип"". Поля: ";
		ДополнитьТекстПолямиСтруктуры(ТекстОшибки, СтруктураЗначения);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;

	Если НЕ СтруктураЗначения.__Тип = "УдалениеОбъекта" Тогда
		ТекстОшибки = СтрШаблон("В параметре ""СтруктураЗначения"" передан некорректный тип для преобразования ""%1""
		                        |Ожидается тип ""УдалениеОбъекта"".",
		                        СтруктураЗначения.__Тип);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;

	Ссылка = СсылкаИзСтруктуры(СтруктураЗначения.Ссылка, ПолучатьБитыеСсылки);

	Возврат Новый УдалениеОбъекта(Ссылка);

КонецФункции // УдалениеОбъектаИзСтруктуры()

// Преобразует набор записей регистра в структуру
//
// Параметры:
//  НаборЗаписей        - РегистрСведенийНаборЗаписей,   - набор записей регистра для преобразования
//                        РегистрНакопленияНаборЗаписей,
//                        РегистрБухгалтерииНаборЗаписей,
//                        РегистрРасчетаНаборЗаписей
//  СписокСвойств       - Строка                         - Список допустимых свойств
//                        Массив из Строка                 (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка                         - Список исключаемых свойств
//                        Массив из Строка                 (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура                                  - результат преобразования
//       *Отбор            - Структура            - Описание отбора записей регистра
//          **<имя поля>     - Произвольный         - Значение отбора
//       *Записи           - Массив(Структура)    - Массив записей регистра
//          **<имя поля>     - Произвольный         - Значения измерений, ресурсов и реквизитов записи регистра
//
//
Функция НаборЗаписейРегистраВСтруктуру(НаборЗаписей,
                                       СписокСвойств = Неопределено,
                                       ИсключаяСвойства = Неопределено) Экспорт

	МетаОбъект = НаборЗаписей.Метаданные();

	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(МетаОбъект.ПолноеИмя());

	СтруктураНабораЗаписей = Неопределено;

	Если ПредставленияРавны(ОписаниеВида.Имя, "РегистрСведений") Тогда
		СтруктураНабораЗаписей = НаборЗаписейРегистраСведенийВСтруктуру(НаборЗаписей, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "РегистрНакопления") Тогда
		СтруктураНабораЗаписей = НаборЗаписейРегистраНакопленияВСтруктуру(НаборЗаписей, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "РегистрБухгалтерии") Тогда
		СтруктураНабораЗаписей = НаборЗаписейРегистраБухгалтерииВСтруктуру(НаборЗаписей, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "РегистрРасчета") Тогда
		СтруктураНабораЗаписей = НаборЗаписейРегистраРасчетаВСтруктуру(НаборЗаписей, СписокСвойств, ИсключаяСвойства);
	Иначе
		ПоказатьСообщение(СтрШаблонВнутр("Неизвестный тип объекта: %1", МетаОбъект.ПолноеИмя()));
	КонецЕсли;

	Возврат СтруктураНабораЗаписей;

КонецФункции // НаборЗаписейРегистраВСтруктуру()

// Заполняет набор записей регистра из структуры
//
//  НаборЗаписей         - РегистрСведенийНаборЗаписей   - Набор записей регистра для заполнения
//  СтруктураОбъекта     - Структура                     - Данные для заполнения объекта
//       *Отбор            - Структура                   - Описание отбора записей регистра
//          **<имя поля>     - Произвольный                - Значение отбора
//       *Записи           - Массив(Структура)           - Массив записей регистра
//          **<имя поля>     - Произвольный                - Значения измерений, ресурсов и реквизитов записи регистра
//  ПолучатьБитыеСсылки  - Булево                        - Истина - если объект по ссылке не существует,
//                                                         будет возвращена битая ссылка;
//                                                         Ложь - будет возвращена пустая ссылка
//  СписокСвойств        - Строка                        - Список допустимых свойств
//                         Массив из Строка                (если пустой, то допустимы все свойства)
//  ИсключаяСвойства     - Строка                        - Список исключаемых свойств
//                         Массив из Строка                (если пустой, то допустимы все свойства)
//
Процедура ЗаполнитьНаборЗаписейРегистраИзСтруктуры(НаборЗаписей,
                                                   СтруктураНабораЗаписей,
                                                   ПолучатьБитыеСсылки,
                                                   СписокСвойств = Неопределено,
                                                   ИсключаяСвойства = Неопределено) Экспорт

	МетаОбъект = НаборЗаписей.Метаданные();

	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(МетаОбъект.ПолноеИмя());

	Если ПредставленияРавны(ОписаниеВида.Имя, "РегистрСведений") Тогда
		НаборЗаписейРегистраСведенийИзСтруктуры(НаборЗаписей,
		                                        СтруктураНабораЗаписей,
		                                        ПолучатьБитыеСсылки,
		                                        СписокСвойств,
		                                        ИсключаяСвойства);
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "РегистрНакопления") Тогда
		НаборЗаписейРегистраНакопленияИзСтруктуры(НаборЗаписей,
		                                          СтруктураНабораЗаписей,
		                                          ПолучатьБитыеСсылки,
		                                          СписокСвойств,
		                                          ИсключаяСвойства);
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "РегистрБухгалтерии") Тогда
		НаборЗаписейРегистраБухгалтерииИзСтруктуры(НаборЗаписей,
		                                           СтруктураНабораЗаписей,
		                                           ПолучатьБитыеСсылки,
		                                           СписокСвойств,
		                                           ИсключаяСвойства);
	ИначеЕсли ПредставленияРавны(ОписаниеВида.Имя, "РегистрРасчета") Тогда
		НаборЗаписейРегистраРасчетаИзСтруктуры(НаборЗаписей,
		                                       СтруктураНабораЗаписей,
		                                       ПолучатьБитыеСсылки,
		                                       СписокСвойств,
		                                       ИсключаяСвойства);
	Иначе
		ПоказатьСообщение(СтрШаблонВнутр("Неизвестный тип объекта: %1", МетаОбъект.ПолноеИмя()));
	КонецЕсли;

КонецПроцедуры // ЗаполнитьНаборЗаписейРегистраИзСтруктуры()

// Заполняет набор записей регистра из структуры
//
//  НаборЗаписей         - РегистрСведенийНаборЗаписей   - Набор записей регистра для заполнения
//  СтруктураОбъекта     - Структура                     - Данные для заполнения объекта
//       *Отбор            - Структура                   - Описание отбора записей регистра
//          **<имя поля>     - Произвольный                - Значение отбора
//       *Записи           - Массив(Структура)           - Массив записей регистра
//          **<имя поля>     - Произвольный                - Значения измерений, ресурсов и реквизитов записи регистра
//  ПолучатьБитыеСсылки  - Булево                        - Истина - если объект по ссылке не существует,
//                                                         будет возвращена битая ссылка;
//                                                         Ложь - будет возвращена пустая ссылка
//  СписокСвойств        - Строка                        - Список допустимых свойств
//                         Массив из Строка                (если пустой, то допустимы все свойства)
//  ИсключаяСвойства     - Строка                        - Список исключаемых свойств
//                         Массив из Строка                (если пустой, то допустимы все свойства)
//
Функция СоздатьНаборЗаписейРегистраИзСтруктуры(СтруктураНабораЗаписей,
                                               ПолучатьБитыеСсылки,
                                               СписокСвойств = Неопределено,
                                               ИсключаяСвойства = Неопределено) Экспорт

	ТипОбъекта = "NULL";
	Если ЕстьТип(СтруктураНабораЗаписей) Тогда 
		ТипОбъекта = СтруктураНабораЗаписей.Ссылка.__Тип;
	Иначе
		ТекстОшибки = "Структура не содержит указания типа значения или не является представлением набора записей. Поля :";
		ДополнитьТекстПолямиСтруктуры(ТекстОшибки, СтруктураНабораЗаписей);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;

	Попытка
		ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипОбъекта);
	Исключение
		ВызватьИсключение СтрШаблонВнутр("Ошибка получения описания вида объекта ""%1"": %2%3",
		                            ТипОбъекта,
		                            Символы.ПС,
		                            ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;

	МетаОбъект = Метаданные.НайтиПоПолномуИмени(СтрШаблонВнутр("%1.%2", ОписаниеВида.Имя, ОписаниеВида.ИмяТипа));
	//@skip-warning
	Менеджер = ОписаниеВида.Коллекция[МетаОбъект.Имя];

	Конструктор = ОписаниеВида.Конструктор;

	НаборЗаписей = Неопределено;

	Если ЗначениеЗаполнено(Конструктор) Тогда
		НаборЗаписей = Вычислить(СтрШаблонВнутр("Менеджер.%1()", Конструктор));
		ЗаполнитьНаборЗаписейРегистраИзСтруктуры(НаборЗаписей,
		                                         СтруктураНабораЗаписей,
		                                         ПолучатьБитыеСсылки,
		                                         СписокСвойств,
		                                         ИсключаяСвойства);
	КонецЕсли;

	Возврат НаборЗаписей;

КонецФункции // СоздатьНаборЗаписейРегистраИзСтруктуры()

// Преобразует набор записей регистра, полученный по указанному отбору, в структуру
//
// Параметры:
//  Регистр                - Строка                    - Строковое представление типа регистра (например: РегистрСведений.КурсыВалют)
//  Отбор                - Структура                    - Структура вида <Имя поля>: <Значение поля>, значения полей отбора
//
// Возвращаемое значение:
//   Структура                                      - результат преобразования
//     *Отбор            - Структура                   - Описание отбора записей регистра
//        **<имя поля>     - Произвольный                - Значение отбора
//     *Записи           - Массив(Структура)           - Массив записей регистра
//        **<имя поля>     - Произвольный                - Значения измерений, ресурсов и реквизитов записи регистра
//
Функция РегистрПоОтборуВСтруктуру(Регистр, Отбор) Экспорт

	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(Регистр);

	Если ОписаниеВида = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;

	НаборЗаписей = ОписаниеВида.Коллекция[ОписаниеВида.ИмяТипа].СоздатьНаборЗаписей();
	Для Каждого ТекЭлемент Из Отбор Цикл
		НаборЗаписей.Отбор[ТекЭлемент.Ключ].Установить(ТекЭлемент.Значение);
	КонецЦикла;
	НаборЗаписей.Прочитать();

	Возврат НаборЗаписейРегистраВСтруктуру(НаборЗаписей);

КонецФункции // РегистрПоОтборуВСтруктуру()

// Преобразует движения документа в структуру
//
// Параметры:
//  Объект                - ДокументСсылка            - Документ, для которого получаются движения
//  СписокРегистров       - Строка, Массив(Строка)    - Список обрабатываемых регистров (если пустой, то обрабатываются все регистры)
//  ИсключаяРегистры      - Строка, Массив(Строка)    - Список исключаемых регистров (если пустой, то обрабатываются все регистры)
//
// Возвращаемое значение:
//   Структура                                              - движения документа по регистрам
//      *<Имя регистра>            - Структура                - Движения регистра
//          **Отбор                  - Структура                - Описание отбора записей регистра
//             ***<имя поля>           - Произвольный             - Значение отбора
//          **Записи                 - Массив(Структура)        - Массив записей регистра
//             ***<имя поля>           - Произвольный             - Значения измерений, ресурсов и реквизитов записи регистра
//
Функция ДвиженияДокументаВСтруктуру(Объект, СписокРегистров = Неопределено, ИсключаяРегистры = Неопределено) Экспорт

	МетаОбъект = Объект.Метаданные();

	ДвиженияПрочитаны = Ложь;
	Для Каждого ТекДвижения Из МетаОбъект.Движения Цикл
		Если Объект.Движения[ТекДвижения.Имя].Количество() > 0 Тогда
			ДвиженияПрочитаны = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;

	СтруктураДвижений = Новый Структура();
	Для Каждого ТекДвижения Из МетаОбъект.Движения Цикл
		Если НЕ ИспользоватьСвойство(ТекДвижения.Имя, СписокРегистров, ИсключаяРегистры) Тогда
			Продолжить;
		КонецЕсли;

		Если НЕ ДвиженияПрочитаны Тогда
			Объект.Движения[ТекДвижения.Имя].Прочитать();
		КонецЕсли;

		СтруктураОбъекта = НаборЗаписейРегистраВСтруктуру(Объект.Движения[ТекДвижения.Имя]);

		СтруктураДвижений.Вставить(ТекДвижения.Имя, СтруктураОбъекта);
	КонецЦикла;

	Возврат СтруктураДвижений;

КонецФункции // ДвиженияДокументаВСтруктуру()

// Заполняет движения документа из структуры
//
// Параметры:
//  Объект                  - ДокументОбъект        - Документ, для которого заполняются движения
//  СтруктураДвижений       - Структура               - Движения документа по регистрам
//      *<Имя регистра>       - Структура               - Движения регистра
//          **Отбор             - Структура               - Описание отбора записей регистра
//             ***<имя поля>      - Произвольный            - Значение отбора
//          **Записи            - Массив(Структура)       - Массив записей регистра
//             ***<имя поля>      - Произвольный            - Значения измерений, ресурсов и реквизитов записи регистра
//  ПолучатьБитыеСсылки     - Булево                - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//  СписокРегистров     - Строка, Массив(Строка)    - Список обрабатываемых регистров (если пустой, то обрабатываются все регистры)
//  ИсключаяРегистры    - Строка, Массив(Строка)    - Список исключаемых регистров (если пустой, то обрабатываются все регистры)
//
// Возвращаемое значение:
//
Процедура ДвиженияДокументаИзСтруктуры(Объект,
                                       СтруктураДвижений,
                                       ПолучатьБитыеСсылки = Ложь,
                                       СписокРегистров = Неопределено,
                                       ИсключаяРегистры = Неопределено) Экспорт

	МетаОбъект = Объект.Метаданные();

	Для Каждого ТекДвижения Из МетаОбъект.Движения Цикл

		Если НЕ СтруктураДвижений.Свойство(ТекДвижения.Имя) Тогда
			Продолжить;
		КонецЕсли;

		Если НЕ ИспользоватьСвойство(ТекДвижения.Имя, СписокРегистров, ИсключаяРегистры) Тогда
			Продолжить;
		КонецЕсли;

		ЗаполнитьНаборЗаписейРегистраИзСтруктуры(Объект.Движения[ТекДвижения.Имя],
		                                         СтруктураДвижений[ТекДвижения.Имя],
		                                         ПолучатьБитыеСсылки);
	КонецЦикла;

КонецПроцедуры // ДвиженияДокументаИзСтруктуры()

#КонецОбласти // ПреобразованияОбъектовОбщие

#Область ПреобразованияСКДИнтерфейсныеПроцедуры

// Функция - заполняет и возвращает структуру описания объекта СКД
// НастройкиКомпоновкиДанных
// 
// Параметры:
//     Объект        - НастройкиКомпоновкиДанных - объект СКД для обработки
//
// Возвращаемое значение:
//     Структура     - структура описания объекта
//
Функция НастройкиСКДВСтруктуру(Объект) Экспорт

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("НастройкиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "НастройкиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Выбор"                 , ЗначениеСКДВСтруктуру(Объект.Выбор));
	СтруктураОбъекта.Вставить("ДополнительныеСвойства", ЗначениеВСтруктуру(Объект.ДополнительныеСвойства));
	СтруктураОбъекта.Вставить("Отбор"                 , ЗначениеСКДВСтруктуру(Объект.Отбор));
	СтруктураОбъекта.Вставить("ПараметрыВывода"       , ЗначениеСКДВСтруктуру(Объект.ПараметрыВывода));
	СтруктураОбъекта.Вставить("ПараметрыДанных"       , ЗначениеСКДВСтруктуру(Объект.ПараметрыДанных));
	СтруктураОбъекта.Вставить("ПользовательскиеПоля"  , ЗначениеСКДВСтруктуру(Объект.ПользовательскиеПоля));
	СтруктураОбъекта.Вставить("Порядок"               , ЗначениеСКДВСтруктуру(Объект.Порядок));
	СтруктураОбъекта.Вставить("Родитель"              , Неопределено); // TODO: Разбраться с родителем
	СтруктураОбъекта.Вставить("Структура"             , КоллекцияСКДВМассив(Объект.Структура));
	СтруктураОбъекта.Вставить("УсловноеОформление"    , ЗначениеСКДВСтруктуру(Объект.УсловноеОформление));

	Возврат СтруктураОбъекта;

КонецФункции // НастройкиСКДВСтруктуру()

// Процедура - заполняет объект СКД НастройкиКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - НастройкиКомпоновкиДанных     - заполняемый объект
//     СтруктураОбъекта   - Структура                     - данные для заполнения объекта
//
Процедура НастройкиСКДИзСтруктуры(Объект, СтруктураОбъекта) Экспорт

	Если НЕ ТипЗнч(Объект) = Тип("НастройкиКомпоновкиДанных") Тогда
		Объект = Новый НастройкиКомпоновкиДанных();
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Выбор", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Отбор", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПараметрыВывода", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПараметрыДанных", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПользовательскиеПоля", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Порядок", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "УсловноеОформление", Истина);

	Если СтруктураОбъекта.Свойство("ДополнительныеСвойства") Тогда
		Для Каждого ТекЭлемент Из СтруктураОбъекта.ДополнительныеСвойства Цикл
			Объект.ДополнительныеСвойства.Вставить(ТекЭлемент.Ключ, ЗначениеИзСтруктуры(ТекЭлемент.Значение));
		КонецЦикла;
	КонецЕсли;

	// TODO: Разобраться с родителем

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Структура", Истина);

КонецПроцедуры // НастройкиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// СхемаКомпоновкиДанных
// 
// Параметры:
//     Объект        - СхемаКомпоновкиДанных   - объект СКД для обработки
//
// Возвращаемое значение:
//     Структура     - структура описания объекта
//
Функция СКДВСтруктуру(Объект) Экспорт

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("СхемаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "СхемаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ИсточникиДанных"     , КоллекцияСКДВМассив(Объект.ИсточникиДанных));
	СтруктураОбъекта.Вставить("НаборыДанных"        , КоллекцияСКДВМассив(Объект.НаборыДанных));
	СтруктураОбъекта.Вставить("СвязиНаборовДанных"  , КоллекцияСКДВМассив(Объект.СвязиНаборовДанных));
	СтруктураОбъекта.Вставить("ВычисляемыеПоля"     , КоллекцияСКДВМассив(Объект.ВычисляемыеПоля));
	СтруктураОбъекта.Вставить("Параметры"           , КоллекцияСКДВМассив(Объект.Параметры));
	СтруктураОбъекта.Вставить("ПоляИтога"           , КоллекцияСКДВМассив(Объект.ПоляИтога));
	СтруктураОбъекта.Вставить("ВариантыНастроек"    , КоллекцияСКДВМассив(Объект.ВариантыНастроек));
	СтруктураОбъекта.Вставить("НастройкиПоУмолчанию", СтруктураОбъекта.ВариантыНастроек[0].Имя);
	СтруктураОбъекта.Вставить("Макеты"              , КоллекцияСКДВМассив(Объект.Макеты));
	СтруктураОбъекта.Вставить("МакетыГруппировок"   , КоллекцияСКДВМассив(Объект.МакетыГруппировок));
	СтруктураОбъекта.Вставить("МакетыЗаголовковГруппировок",
	                          КоллекцияСКДВМассив(Объект.МакетыЗаголовковГруппировок));
	СтруктураОбъекта.Вставить("МакетыПолей"         , КоллекцияСКДВМассив(Объект.МакетыПолей));
	СтруктураОбъекта.Вставить("МакетыПолейИтога"    , КоллекцияСКДВМассив(Объект.МакетыПолейИтога));
	СтруктураОбъекта.Вставить("ВложенныеСхемыКомпоновкиДанных",
	                          КоллекцияСКДВМассив(Объект.ВложенныеСхемыКомпоновкиДанных));

	Возврат СтруктураОбъекта;

КонецФункции // СКДВСтруктуру()

// Процедура - заполняет объект СКД СхемаКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - СхемаКомпоновкиДанных     - заполняемый объект
//     СтруктураОбъекта   - Структура                 - данные для заполнения объекта
//
Процедура СКДИзСтруктуры(Объект, СтруктураОбъекта) Экспорт

	Если НЕ ТипЗнч(Объект) = Тип("СхемаКомпоновкиДанных") Тогда
		Объект = Новый СхемаКомпоновкиДанных();
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "ИсточникиДанных");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "НаборыДанных", Истина);
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "СвязиНаборовДанных");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "ВычисляемыеПоля");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Параметры");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "ПоляИтога");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Макеты");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "МакетыГруппировок");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "МакетыЗаголовковГруппировок");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "МакетыПолей");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "МакетыПолейИтога");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "ВложенныеСхемыКомпоновкиДанных");

	Если СтруктураОбъекта.Свойство("ВариантыНастроек") Тогда
		ВариантПоУмолчанию = Неопределено;
		Если СтруктураОбъекта.Свойство("НастройкиПоУмолчанию") И Объект.ВариантыНастроек.Количество() > 0 Тогда
			Для Каждого ТекЭлемент Из СтруктураОбъекта.ВариантыНастроек Цикл
				Если ТекЭлемент.Имя = СтруктураОбъекта.НастройкиПоУмолчанию Тогда
					ВариантПоУмолчанию = ТекЭлемент;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если НЕ ВариантПоУмолчанию = Неопределено Тогда
				ЗначениеСКДИзСтруктуры(Объект.ВариантыНастроек[0], ВариантПоУмолчанию);
			Иначе
				Объект.ВариантыНастроек.Очистить();
			КонецЕсли;
		Иначе
			Объект.ВариантыНастроек.Очистить();
		КонецЕсли;
		Для Каждого ТекЭлемент Из СтруктураОбъекта.ВариантыНастроек Цикл
			Если НЕ ВариантПоУмолчанию = Неопределено И ТекЭлемент.Имя = СтруктураОбъекта.НастройкиПоУмолчанию Тогда
				Продолжить;
			КонецЕсли;
			НовыйЭлемент = Объект.ВариантыНастроек.Добавить();
			ЗначениеСКДИзСтруктуры(НовыйЭлемент, ТекЭлемент);
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры // СКДИзСтруктуры()

#КонецОбласти // ПреобразованияСКДИнтерфейсныеПроцедуры

#Область ПреобразованияДанныхФормИнтерфейсныеПроцедуры

// Функция - заполняет и возвращает структуру описания данных формы
// 
// Параметры:
//  Форма             - УправляемаяФорма        - форма для обработки
//  ТолькоСохраняемые - Булево                  - Истина - сохраняются только значения реквизитов
//                                                с признаком "Сохраняемые данные"
//                                                Ложь - сохраняются значения всех реквизитов
//  СписокСвойств        - Строка               - Список допустимых свойств
//                         Массив из Строка       (если пустой, то допустимы все свойства)
//  ИсключаяСвойства     - Строка               - Список исключаемых свойств
//                         Массив из Строка       (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура                                        - структура описания формы
//      *__Тип               - Строка                   - тип данных (ДанныеФормы)
//      *<имя реквизита>     - Структура                - описание и значение реквизита формы
//
Функция ДанныеФормыВСтруктуру(Форма,
                              ТолькоСохраняемые = Ложь,
                              СписокСвойств = Неопределено,
                              ИсключаяСвойства = Неопределено) Экспорт

	СтруктураДанных = Новый Структура();

	Если НЕ ТипЗнч(Форма) = Тип("ФормаКлиентскогоПриложения") Тогда
		СтруктураДанных.Вставить("__Тип", "Неопределено");
		Возврат СтруктураДанных;
	КонецЕсли;

	СтруктураДанных.Вставить("__Тип", СтрШаблонВнутр("ДанныеФормы.%1", Форма.ИмяФормы));

	РеквизитыФормы = Форма.ПолучитьРеквизиты();

	Для Каждого ТекРеквизит Из РеквизитыФормы Цикл

		Если ТолькоСохраняемые И НЕ ТекРеквизит.СохраняемыеДанные Тогда
			Продолжить;
		КонецЕсли;

		Если НЕ ИспользоватьСвойство(ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;

		ОписаниеРеквизита = Новый Структура();
		ОписаниеРеквизита.Вставить("ТипЗначения"      , ЗначениеВСтруктуру(ТекРеквизит.ТипЗначения));
		ОписаниеРеквизита.Вставить("Путь"             , ТекРеквизит.Путь);
		ОписаниеРеквизита.Вставить("Заголовок"        , ТекРеквизит.Заголовок);
		ОписаниеРеквизита.Вставить("СохраняемыеДанные", ТекРеквизит.СохраняемыеДанные);

		ЗначениеДляСохранения = Неопределено;

		ТипРеквизита = ТипЗнч(Форма[ТекРеквизит.Имя]);

		ЭтоДанныеФормы = (ТипРеквизита = Тип("ДанныеФормыСтруктура")
		              ИЛИ ТипРеквизита = Тип("ДанныеФормыСтруктураСКоллекцией")
		              ИЛИ ТипРеквизита = Тип("ДанныеФормыКоллекция")
		              ИЛИ ТипРеквизита = Тип("ДанныеФормыДерево"));
		Если ЭтоДанныеФормы Тогда
			ЗначениеДляСохранения = Форма.РеквизитФормыВЗначение(ТекРеквизит.Имя);
		Иначе
			ЗначениеДляСохранения = Форма[ТекРеквизит.Имя];
		КонецЕсли;

		ОписаниеРеквизита.Вставить("Значение", ЗначениеВСтруктуру(ЗначениеДляСохранения));

		СтруктураДанных.Вставить(ТекРеквизит.Имя, ОписаниеРеквизита);
	КонецЦикла;

	Возврат СтруктураДанных;

КонецФункции // ДанныеФормыВСтруктуру()

// Заполняет значения данных формы из структуры
//
// Параметры:
//  Форма               - УправляемаяФорма         - форма для заполнения данных
//  СтруктураДанных     - Структура                - данные для заполнения формы
//      *__Тип            - Строка                   - тип данных (ДанныеФормы)
//      *<имя реквизита>  - Структура                - описание и значение реквизита формы
//  ПроверятьИмяФормы   - Булево                   - Истина - если имя формы не соответствует сохраненным данным,
//                                                   то будет выдано исключение;
//                                                   Ложь - имя формы не проверяется
//  СоздаватьРеквизиты  - Булево                   - Истина - если реквизит отсутствует в форме,
//                                                   то будет создан новый;
//                                                   Ложь - новые реквизиты не создаются
//  СписокСвойств       - Строка                   - Список допустимых свойств
//                        Массив из Строка           (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка                   - Список исключаемых свойств
//                        Массив из Строка           (если пустой, то допустимы все свойства)
//
Процедура ДанныеФормыИзСтруктуры(Форма,
                                 СтруктураДанных,
                                 ПроверятьИмяФормы = Ложь,
                                 СоздаватьРеквизиты = Ложь,
                                 СписокСвойств = Неопределено,
                                 ИсключаяСвойства = Неопределено) Экспорт

	Если НЕ ТипЗнч(Форма) = Тип("ФормаКлиентскогоПриложения") Тогда
		ТекстОшибки = СтрШаблонВнутр("Попытка заполнения объекта типа ""%1"" данными для объекта типа ""%2""!",
		                             ТипЗнч(Форма),
		                             Тип("ФормаКлиентскогоПриложения"));
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;

	Если НЕ ЕстьТип(СтруктураДанных) Тогда
		ТекстОшибки = "В структуре данных для заполнения служебное поле ""__Тип"", поля структуры:";
		ДополнитьТекстПолямиСтруктуры(ТекстОшибки, СтруктураДанных);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;

	Если НЕ ПредставленияРавны(Лев(СтруктураДанных.__Тип, СтрДлина("ДанныеФормы")), "ДанныеФормы") Тогда
		ТекстОшибки = СтрШаблонВнутр("Тип данных ""%1"" структуры данных не является данными формы", СтруктураДанных.__Тип);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;

	Если ПроверятьИмяФормы
	   И ПредставленияРавны(СтруктураДанных.__Тип, СтрШаблонВнутр("ДанныеФормы.%1", Форма.ИмяФормы)) Тогда
		ТекстОшибки = СтрШаблонВнутр("Тип данных ""%1"" структуры данных не является данными формы ""%2""!",
                                     СтруктураДанных.__Тип,
                                     Форма.ИмяФормы);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;

	РеквизитыФормы = Форма.ПолучитьРеквизиты();

	ИменаРеквизитовФормы = Новый Соответствие();

	Для Каждого ТекРеквизит Из РеквизитыФормы Цикл
		ИменаРеквизитовФормы.Вставить(ТекРеквизит.Имя, ТекРеквизит);
	КонецЦикла;

	СоздаваемыеРеквизиты = Новый Массив();

	Для Каждого ТекРеквизит Из СтруктураДанных Цикл
		Если ПредставленияРавны(ТекРеквизит.Ключ, "__Тип") Тогда
			Продолжить;
		КонецЕсли;

		Если НЕ ИспользоватьСвойство(ТекРеквизит.Ключ, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;

		Если СоздаватьРеквизиты И ИменаРеквизитовФормы.Получить(ТекРеквизит.Ключ) = Неопределено Тогда
			СоздаваемыеРеквизиты.Добавить(Новый РеквизитФормы(ТекРеквизит.Ключ,
			                                                  ЗначениеИзСтруктуры(ТекРеквизит.Значение.ТипЗначения),
			                                                  ТекРеквизит.Значение.Путь,
			                                                  ТекРеквизит.Значение.Заголовок,
			                                                  ТекРеквизит.Значение.СохраняемыеДанные));               
		КонецЕсли;
	КонецЦикла;

	Если СоздаваемыеРеквизиты.Количество() > 0 Тогда
		Форма.ИзменитьРеквизиты(СоздаваемыеРеквизиты);
	КонецЕсли;

	Для Каждого ТекРеквизит Из СтруктураДанных Цикл
		Если ПредставленияРавны(ТекРеквизит.Ключ, "__Тип") Тогда
			Продолжить;
		КонецЕсли;

		Если НЕ ИспользоватьСвойство(ТекРеквизит.Ключ, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;

		РеквизитФормы = ИменаРеквизитовФормы.Получить(ТекРеквизит.Ключ);

		Если РеквизитФормы = Неопределено Тогда
			Продолжить;
		КонецЕсли;

		ТипРеквизита = ТипЗнч(Форма[ТекРеквизит.Ключ]);

		ЭтоДанныеФормы = (ТипРеквизита = Тип("ДанныеФормыСтруктура")
		              ИЛИ ТипРеквизита = Тип("ДанныеФормыСтруктураСКоллекцией")
		              ИЛИ ТипРеквизита = Тип("ДанныеФормыКоллекция")
		              ИЛИ ТипРеквизита = Тип("ДанныеФормыДерево"));
		Если ЭтоДанныеФормы Тогда
			Если ЭтоОбъект(ТекРеквизит.Значение.Значение) Тогда
				ЗначениеДляЗаполнения = Форма.РеквизитФормыВЗначение(ТекРеквизит.Ключ);
				ЗаполнитьОбъектИзСтруктуры(ЗначениеДляЗаполнения, ТекРеквизит.Значение.Значение, Истина);
			ИначеЕсли ЭтоНаборЗаписейРегистра(ТекРеквизит.Значение.Значение) Тогда
				ЗначениеДляЗаполнения = Форма.РеквизитФормыВЗначение(ТекРеквизит.Ключ);
				ЗаполнитьНаборЗаписейРегистраИзСтруктуры(ЗначениеДляЗаполнения, ТекРеквизит.Значение.Значение, Истина);
			Иначе
				ЗначениеДляЗаполнения = ЗначениеИзСтруктуры(ТекРеквизит.Значение.Значение);
			КонецЕсли;
			Форма.ЗначениеВРеквизитФормы(ЗначениеДляЗаполнения, ТекРеквизит.Ключ);
		Иначе
			Форма[ТекРеквизит.Ключ] = ЗначениеИзСтруктуры(ТекРеквизит.Значение.Значение);
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры // ДанныеФормыИзСтруктуры()

#КонецОбласти // ПреобразованияДанныхФормИнтерфейсныеПроцедуры

#Область ПреобразованияJSON

// Функция - возвращает представление описания объекта в текстовом формате JSON
//
// Параметры:
//  ОписаниеОбъекта     - Структура, Массив из Структура     - описание объекта для преобразования
// 
// Возвращаемое значение:
//  Строка - представление описания объекта в текстовом формате JSON
//
Функция ЗаписатьОписаниеОбъектаВJSON(Знач ОписаниеОбъекта) Экспорт

	Запись = Новый ЗаписьJSON();
	Запись.УстановитьСтроку(Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Unix, Символы.Таб));

	НастройкиСериализации = Новый НастройкиСериализацииJSON();
	НастройкиСериализации.ВариантЗаписиДаты = ВариантЗаписиДатыJSON.УниверсальнаяДата;
	НастройкиСериализации.ФорматСериализацииДаты = ФорматДатыJSON.Microsoft;

	Попытка
		ЗаписатьJSON(Запись, ОписаниеОбъекта, НастройкиСериализации, "ОбработчикЗаписиЗначенийJSON", ЭтотОбъект);
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;

	Возврат Запись.Закрыть();

КонецФункции // ЗаписатьОписаниеОбъектаВJSON()

// Функция - возвращает описание объекта, прочитанное из текстового формата JSON
//
// Параметры:
//  ТекстОписанияОбъекта       - Строка           - представление описания объекта в текстовом формате JSON
//  СвойстваСоЗначениемДата    - Массив, Строка   - список свойств, которые должны быть преобразованы в формат даты
// 
// Возвращаемое значение:
//  Структура, Массив из Структура     - описание объекта 
//
Функция ПрочитатьОписаниеОбъектаИзJSON(Знач ТекстОписанияОбъекта, Знач СвойстваСоЗначениемДата = Неопределено) Экспорт

	Чтение = Новый ЧтениеJSON();
	Чтение.УстановитьСтроку(ТекстОписанияОбъекта);

	Если ТипЗнч(СвойстваСоЗначениемДата) = Тип("Строка") Тогда
		СвойстваСоЗначениемДата = СтрРазделитьВнутр(СвойстваСоЗначениемДата, ",", Ложь);
	КонецЕсли;

	Если НЕ ТипЗнч(СвойстваСоЗначениемДата) = Тип("Массив") Тогда
		СвойстваСоЗначениемДата = Новый Массив();
	КонецЕсли;

	Попытка
		Возврат ПрочитатьJSON(Чтение,
		                      Ложь,
		                      СвойстваСоЗначениемДата,
		                      ФорматДатыJSON.Microsoft,
		                      "ОбработчикЧтенияЗначенийJSON",
		                      ЭтотОбъект);
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;

КонецФункции // ПрочитатьОписаниеОбъектаИзJSON()

// Обработчик записи значений JSON
// 
// Параметры:
//  Свойство                   - Строка       - записываемое свойство
//  Значение                   - Строка       - записываемое значение
//  ДополнительныеПараметры    - Структура    - дополнительные параметры для обработки
//  Отказ                      - Булево       - Истина - отказ от дальнейшей обработки
//
// Возвращаемое значение:
//  Строка     - значение свойства для записи
//
Функция ОбработчикЗаписиЗначенийJSON(Свойство, Значение, ДополнительныеПараметры, Отказ) Экспорт

	ТипЗначения = ТипЗнч(Значение);

	Если ТипЗначения = Тип("ХранилищеЗначения") Тогда
		Значение = СтрШаблонВнутр("/ValueStorage(%1)/", ЗначениеВСтрокуВнутр(Значение));
	ИначеЕсли ТипЗначения = Тип("УникальныйИдентификатор") Тогда
		Значение = СтрШаблонВнутр("/UniqueID(%1)/", СокрЛП(Значение));
	ИначеЕсли ТипЗначения = Тип("NULL") Тогда
		Значение = "/NULL()/";
	ИначеЕсли ТипЗначения = Тип("Неопределено") Тогда
		Значение = "/Undefined()/";
	Иначе
		Значение = СтрШаблонВнутр("/UnknownType(%1)/", ЗначениеВСтрокуВнутр(Значение));
	КонецЕсли;

	Возврат Значение;

КонецФункции // ОбработчикЗаписиЗначенийJSON()

// Обработчик чтения значений JSON
// 
// Параметры:
//  Свойство                   - Строка       - читаемое свойство
//  Значение                   - Строка       - читаемое значение
//  ДополнительныеПараметры    - Структура    - дополнительные параметры для обработки
//
// Возвращаемое значение:
//  Произвольный     - прочитанное значение
//
Функция ОбработчикЧтенияЗначенийJSON(Свойство, Значение, ДополнительныеПараметры) Экспорт

	Если ТипЗнч(Значение) = Тип("Строка") Тогда
		Если СтрокаНачинаетсяСВнутр(Значение, "/Date(") Тогда
			Значение = ПрочитатьДатуJSON(Значение, ФорматДатыJSON.Microsoft);
			Если Значение < '00020101000000' Тогда
				Значение = '00010101000000';
			КонецЕсли;
		ИначеЕсли СтрокаНачинаетсяСВнутр(Значение, "/ValueStorage(") Тогда
			Если Прав(Значение, 2) = ")/" Тогда
				Значение = ЗначениеИзСтрокиВнутр(Сред(Значение, 15, СтрДлина(Значение) - 16));
			КонецЕсли;
		ИначеЕсли СтрокаНачинаетсяСВнутр(Значение, "/UniqueID(") Тогда
			Если Прав(Значение, 2) = ")/" Тогда
				Значение = Новый УникальныйИдентификатор(Сред(Значение, 11, СтрДлина(Значение) - 12));
			КонецЕсли;
		ИначеЕсли Значение = "/NULL()/" Тогда
			Значение = NULL;
		ИначеЕсли Значение = "/Undefined()/" Тогда
			Значение = Неопределено;
		ИначеЕсли СтрокаНачинаетсяСВнутр(Значение, "/UnknownType(") Тогда
			Если Прав(Значение, 2) = ")/" Тогда
				Значение = ЗначениеИзСтрокиВнутр(Сред(Значение, 14, СтрДлина(Значение) - 15));
			КонецЕсли;
		Иначе
			Возврат Значение;
		КонецЕсли;
	КонецЕсли;

	Возврат Значение;

КонецФункции // ОбработчикЧтенияЗначенийJSON()

#КонецОбласти // ПреобразованияJSON

// Функция - возвращает версию библиотеки
// 
// Возвращаемое значение:
//     Строка - версия библиотеки
//
Функция Версия() Экспорт

	//@skip-warning
	Возврат ЭтотОбъект.ПолучитьМакет("ВерсияБиблиотеки").ПолучитьТекст();

КонецФункции // Версия()

#КонецОбласти // ПрограммныйИнтерфейс

#Область СлужебныйПрограммныйИнтерфейс

#Область ПреобразованияОбъектовСлужебные

// Возвращает структуру, содержащую информацию
// о переданном виде объектов метаданных
//
// Параметры:
//  Значение        - Строка        - Имя вида объектов метаданных (например, константа,
//                    Тип             ПланСчетов и т.п.), может передаваться в ед. мн. числе,
//                    Структура       тип объекта, объект или структура объекта
//  ТекИБ           - COMОбъект     - Информационная база, из которой будет получена информация
//                                    о виде объектов, Неопределено - текущая инф. база
//
// Возвращаемое значение:
//   Структура            - Содержимое
//     *Коллекция          - Менеджер                       - Менеджер вида объектов (например, СправочникиМенеджер)
//     *МетаКоллекция      - КоллекцияОбъектовМетаданных    - Коллекция метаданных вида объектов (например, Справочники)
//     *Имя                - Строка                         - Имя вида объектов (например, "ПланСчетов")
//     *ИмяКоллекции       - Строка                         - Имя коллекции вида объектов (например, "ПланыСчетов")
//     *Представление      - Строка                         - Представление вида объектов (например, "План счетов")
//     *ПредставлениеМ     - Строка                         - Представление коллекции вида объектов
//                                                            (например, "Планы счетов")
//     *ИмяТипа            - Строка                         - Имя типа (конкретный элемент, например, Контрагенты)
//     *Картинка           - Картинка                       - Картинка коллекции по умолчанию
//     *КартинкаОбъекта    - Картинка                       - Картинка объекта коллекции по умолчанию
//     *Конструктор        - Строка                         - Имя функции конструктора экземпляра объекта
//                                                            (например, СоздатьЭлемент)
//     *КонструкторАльт    - Строка                         - Имя альтернативной функции конструктора
//                                                            экземпляра объекта (например, СоздатьГруппу) 
//
Функция ПолучитьОписаниеВидаОбъектов(Знач Значение, Знач ТекИБ = Неопределено) Экспорт

	ИмяТипа = "";
	
	Если ТипЗнч(Значение) = Тип("Структура") Тогда
		Если Значение.__Тип = "УдалениеОбъекта" Тогда
			ИмяИлиТип = Значение.Ссылка.__Тип;
		Иначе
			ИмяИлиТип = Значение.__Тип;
		КонецЕсли;
	Иначе
		ИмяИлиТип = Значение;
	КонецЕсли;

	ТипИмениИлиТипа = ТипЗнч(ИмяИлиТип);

	Если ТипИмениИлиТипа = Тип("Тип") Тогда
		ОписаниеМетаданных = КэшМетаданных()[ИмяИлиТип];
		Если ОписаниеМетаданных = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		ПолноеИмяТипа = ОписаниеМетаданных.ПолноеИмя;
		ПозТчк = Найти(ПолноеИмяТипа, ".");
		НИмя = НРег(Лев(ПолноеИмяТипа, ПозТчк - 1));
		ИмяТипа = Сред(ПолноеИмяТипа, ПозТчк + 1);
	ИначеЕсли ТипИмениИлиТипа = Тип("Строка") Тогда
		НИмя = НРег(ИмяИлиТип);
		Если Найти(ИмяИлиТип, ".") > 0 Тогда
			ПозТчк = Найти(ИмяИлиТип, ".");
			НИмя = Лев(НИмя, ПозТчк - 1);
			ИмяТипа = Сред(ИмяИлиТип, ПозТчк + 1);
		КонецЕсли;
		НИмя = СтрЗаменить(СтрЗаменить(НИмя, "-", ""), " ", "");
	Иначе
		Возврат Неопределено;
	КонецЕсли;

	ОписаниеТипаКэш = КэшОписанийТипов().Получить(НИмя);

	Если ОписаниеТипаКэш = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;

	ОписаниеТипа = Новый Структура();

	ОписаниеТипа.Вставить("ИмяТипа"        , ИмяТипа);
	ОписаниеТипа.Вставить("Коллекция"      , ?(ТекИБ = Неопределено,
	                                           Вычислить(ОписаниеТипаКэш.Коллекция),
	                                           ТекИБ.Вычислить(ОписаниеТипаКэш.Коллекция)));
	ОписаниеТипа.Вставить("МетаКоллекция"  , ?(ТекИБ = Неопределено,
	                                           Метаданные[ОписаниеТипаКэш.Коллекция],
	                                           ТекИБ.Метаданные[ОписаниеТипаКэш.Коллекция]));
	ОписаниеТипа.Вставить("Имя"            , ОписаниеТипаКэш.Имя);
	ОписаниеТипа.Вставить("ИмяКоллекции"   , ОписаниеТипаКэш.Коллекция);
	ОписаниеТипа.Вставить("Представление"  , ОписаниеТипаКэш.Представление);
	ОписаниеТипа.Вставить("ПредставлениеМ" , ОписаниеТипаКэш.ПредставлениеМ);
	ОписаниеТипа.Вставить("Конструктор"    , ОписаниеТипаКэш.Конструктор);
	ОписаниеТипа.Вставить("КонструкторАльт", ОписаниеТипаКэш.КонструкторАльт);
	ОписаниеТипа.Вставить("Картинка");
	ОписаниеТипа.Вставить("КартинкаОбъекта");

	#Если Клиент Тогда
	ОписаниеТипа.Картинка        = БиблиотекаКартинок[ОписаниеТипаКэш.Картинка];
	ОписаниеТипа.КартинкаОбъекта = БиблиотекаКартинок[ОписаниеТипаКэш.КартинкаОбъекта];
	#КонецЕсли

	Возврат ОписаниеТипа;

КонецФункции // ПолучитьОписаниеВидаОбъектов()

// Возвращает соответствие таблиц СУБД объектам 1С
//
// Возвращаемое значение:
//   Соответствие                  - соответствие таблиц СУБД объектам 1С
//     * Ключ           - Строка      - имя таблицы СУБД
//     * Значение       - Структура   - Коллекция метаданных вида объектов (например, Справочники)
//        ** mainObject    - Строка      - имя основной таблицы объекта в 1С
//        ** tableName     - Строка      - имя таблицы в 1С
//        ** Purpose       - Строка      - назначение таблицы в 1С
//
Функция СтруктураХраненияБазыДанных() Экспорт

	ТаблицаХранения = ПолучитьСтруктуруХраненияБазыДанных(, Истина); // - ТаблицаЗначений

	СтруктураХранения = Новый Соответствие();

	Для Каждого ТекСтрока Из ТаблицаХранения Цикл
		
		Назначение = ВРег(ТекСтрока.Назначение);
		
		ЭтоИтоги = (Назначение = "ИТОГИ"
		        ИЛИ Назначение = "TOTALS"
		        ИЛИ Назначение = "ОБОРОТЫ"
		        ИЛИ Назначение = "TURNOVERS");
		
		ОписаниеТаблицы = Новый Структура();
		ОписаниеТаблицы.Вставить("purpose", ТекСтрока.Назначение);
		Если ПустаяСтрока(ТекСтрока.Метаданные) Тогда
			ОсновнойОбъект = ТекСтрока.ИмяТаблицыХранения;
			ИмяТаблицы = ТекСтрока.ИмяТаблицыХранения;
		ИначеЕсли ПустаяСтрока(ТекСтрока.ИмяТаблицы) Тогда
			ОсновнойОбъект = ТекСтрока.Метаданные;
			ИмяТаблицы = ТекСтрока.Метаданные;
		ИначеЕсли Назначение = "ОСНОВНАЯ"
		      ИЛИ Назначение = "MAIN"Тогда
			ОсновнойОбъект = ТекСтрока.ИмяТаблицы;
			ИмяТаблицы = ТекСтрока.ИмяТаблицы;
		ИначеЕсли Назначение = "РЕГИСТРАЦИЯИЗМЕНЕНИЙ"
		      ИЛИ Назначение = "CHANGERECORD"Тогда
			ОсновнойОбъект = ТекСтрока.Метаданные;
			ИмяТаблицы = ТекСтрока.ИмяТаблицы;
		ИначеЕсли Назначение = "РЕГИСТРАЦИЯИЗМЕНЕНИЙКОНСТАНТЫ"
		      ИЛИ Назначение = "CONSTANTSCHANGERECORD"Тогда
			ОсновнойОбъект = ТекСтрока.Метаданные;
			ИмяТаблицы = СтрШаблонВнутр("%1.Изменения", ТекСтрока.Метаданные);
		ИначеЕсли ЭтоИтоги Тогда
			ОсновнойОбъект = ТекСтрока.Метаданные;
			ИмяТаблицы = СтрШаблонВнутр("%1.%2", ТекСтрока.Метаданные, ТекСтрока.Назначение);
		Иначе
			ЧастиИмени = СтрРазделитьВнутр(ТекСтрока.ИмяТаблицы, ".");
			ОсновнойОбъект = СтрШаблонВнутр("%1.%2", ЧастиИмени[0], ЧастиИмени[1]);
			ИмяТаблицы = ТекСтрока.Метаданные;
		КонецЕсли;

		ОписаниеТаблицы.Вставить("mainObject", ОсновнойОбъект);
		ОписаниеТаблицы.Вставить("tableName", ИмяТаблицы);

		СтруктураХранения.Вставить(ТекСтрока.ИмяТаблицыХранения, ОписаниеТаблицы);	

	КонецЦикла;

	Возврат СтруктураХранения;

КонецФункции // СтруктураХраненияБазыДанных()

// Проверяет, что переданное значение является объектом регистра или его представлением
//
// Параметры:
//  Значение    - Произвольный - проверяемое значение или его представление
// 
// Возвращаемое значение:
//  Булево      - Истина - передан объект регистра или его представление,
//                Ложь   - в противном случае
//
Функция ЭтоОбъектРегистра(Значение) Экспорт

	ТипДляПроверки = Неопределено;

	ТипЗначения = ТипЗнч(Значение);

	Если ТипЗначения = Тип("Структура") Тогда
		Если ЕстьТип(Значение) Тогда
			ТипДляПроверки = Значение.__Тип;
		КонецЕсли;
	Иначе
		ТипДляПроверки = ТипЗначения;
	КонецЕсли;

	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипДляПроверки);

	Если ОписаниеВида = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;

	КоллекцииРегистров = Новый Соответствие();
	КоллекцииРегистров.Вставить("РегистрСведений"   , Истина);
	КоллекцииРегистров.Вставить("РегистрНакопления" , Истина);
	КоллекцииРегистров.Вставить("РегистрБухгалтерии", Истина);
	КоллекцииРегистров.Вставить("РегистрРасчета"    , Истина);

	Возврат (КоллекцииРегистров.Получить(ОписаниеВида.Имя) = Истина);

КонецФункции // ЭтоОбъектРегистра()

// Проверяет, что переданное значение является записью регистра или ее представлением
//
// Параметры:
//  Значение    - Произвольный - проверяемое значение или его представление
// 
// Возвращаемое значение:
//  Булево      - Истина - передана запись регистра или ее представление
//                Ложь   - в противном случае
//
Функция ЭтоЗаписьРегистра(Значение) Экспорт

	Если НЕ ЭтоОбъектРегистра(Значение) Тогда
		Возврат Ложь;
	КонецЕсли;

	ТипЗначения = ТипЗнч(Значение);

	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипЗначения);

	Если ОписаниеВида = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;

	Если ТипЗначения = Тип("Структура") И ЕстьТип(Значение) Тогда
		Возврат (Найти(Значение.__Тип, "Запись.") > 1);
	КонецЕсли;

	Возврат (ТипЗначения = Тип(СтрШаблонВнутр("%1Запись.%2", ОписаниеВида.Имя, ОписаниеВида.ИмяТипа)));

КонецФункции // ЭтоЗаписьРегистра()

// Проверяет, что переданное значение является набором записей регистра или его представлением
//
// Параметры:
//  Значение    - Произвольный - проверяемое значение или его представление
// 
// Возвращаемое значение:
//  Булево      - Истина - передан набор записей регистра или его представление,
//                Ложь   - в противном случае
//
Функция ЭтоНаборЗаписейРегистра(Значение) Экспорт

	Если НЕ ЭтоОбъектРегистра(Значение) Тогда
		Возврат Ложь;
	КонецЕсли;

	ТипЗначения = ТипЗнч(Значение);

	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипЗначения);

	Если ОписаниеВида = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;

	Если ТипЗначения = Тип("Структура") И ЕстьТип(Значение) Тогда
		Возврат (Найти(Значение.__Тип, "НаборЗаписей.") > 1);
	КонецЕсли;

	Возврат (ТипЗначения = Тип(СтрШаблонВнутр("%1НаборЗаписей.%2", ОписаниеВида.Имя, ОписаниеВида.ИмяТипа)));

КонецФункции // ЭтоНаборЗаписейРегистра()

// Проверяет, что переданное значение является значением ссылочного типа или его представлением
//
// Параметры:
//  Значение    - Произвольный - проверяемое значение или его представление
// 
// Возвращаемое значение:
//  Булево      - Истина - передано ссылочное значение или его представление,
//                Ложь   - в противном случае
//
Функция ЭтоЗначениеСсылочногоТипа(Значение) Экспорт

	ТипДляПроверки = Неопределено;

	ТипЗначения = ТипЗнч(Значение);

	Если ТипЗначения = Тип("Структура") Тогда
		Если ЕстьТип(Значение) Тогда
			Попытка
				ТипДляПроверки = Тип(Значение.__Тип);
			Исключение
				ТипДляПроверки = Неопределено;
			КонецПопытки;
		КонецЕсли;
	Иначе
		ТипДляПроверки = ТипЗначения;
	КонецЕсли;

	ОписаниеМетаданных = КэшМетаданных()[ТипДляПроверки];

	Если ОписаниеМетаданных = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;

	СсылочныеКоллекции = Новый Соответствие();
	СсылочныеКоллекции.Вставить("Справочники"            , Истина);
	СсылочныеКоллекции.Вставить("Документы"              , Истина);
	СсылочныеКоллекции.Вставить("Перечисления"           , Истина);
	СсылочныеКоллекции.Вставить("ПланыВидовХарактеристик", Истина);
	СсылочныеКоллекции.Вставить("ПланыСчетов"            , Истина);
	СсылочныеКоллекции.Вставить("ПланыОбмена"            , Истина);
	СсылочныеКоллекции.Вставить("ПланыВидовРасчета"      , Истина);
	СсылочныеКоллекции.Вставить("БизнесПроцессы"         , Истина);
	СсылочныеКоллекции.Вставить("Задачи"                 , Истина);

	Возврат (СсылочныеКоллекции.Получить(ОписаниеМетаданных.Коллекция) = Истина);

КонецФункции // ЭтоЗначениеСсылочногоТипа()

// Проверяет, что переданное значение является ссылкой на объект или ее представление
//
// Параметры:
//  Значение    - Произвольный - проверяемое значение или его представление
// 
// Возвращаемое значение:
//  Булево      - Истина - передано ссылочное значение или его представление,
//                Ложь   - в противном случае
//
Функция ЭтоСсылка(Значение) Экспорт

	Если НЕ ЭтоЗначениеСсылочногоТипа(Значение) Тогда
		Возврат Ложь;
	КонецЕсли;

	ТипЗначения = ТипЗнч(Значение);

	Если ТипЗначения = Тип("Структура") И ЕстьТип(Значение) Тогда
		Возврат (Найти(Значение.__Тип, "Ссылка.") > 1);
	КонецЕсли;

	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипЗначения);

	Если ОписаниеВида = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;

	Возврат (ТипЗначения = Тип(СтрШаблонВнутр("%1Ссылка.%2", ОписаниеВида.Имя, ОписаниеВида.ИмяТипа)));

КонецФункции // ЭтоСсылка()

// Проверяет, что переданное значение является ссылочным объектом или его представлением
//
// Параметры:
//  Значение    - Произвольный - проверяемое значение или его представление
// 
// Возвращаемое значение:
//  Булево      - Истина - передан ссылочный объект или его представление,
//                Ложь   - в противном случае
//
Функция ЭтоОбъект(Значение) Экспорт

	Если НЕ ЭтоЗначениеСсылочногоТипа(Значение) Тогда
		Возврат Ложь;
	КонецЕсли;

	ТипЗначения = ТипЗнч(Значение);

	Если ТипЗначения = Тип("Структура") И ЕстьТип(Значение) Тогда
		Возврат (Найти(Значение.__Тип, "Объект.") > 1);
	КонецЕсли;

	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипЗначения);

	Если ОписаниеВида = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;

	Возврат (ТипЗначения = Тип(СтрШаблонВнутр("%1Объект.%2", ОписаниеВида.Имя, ОписаниеВида.ИмяТипа)));

КонецФункции // ЭтоОбъект()

// Проверяет, что переданное значение является описанием типа
//
// Параметры:
//  Значение    - Произвольный - проверяемое значение или его представление
// 
// Возвращаемое значение:
//  Булево      - Истина - передано описание типов
//                Ложь   - в противном случае
//
Функция ЭтоОписаниеТипов(Значение) Экспорт

	Если НЕ ЭтоЗначениеСсылочногоТипа(Значение) Тогда
		Возврат Ложь;
	КонецЕсли;

	ТипЗначения = ТипЗнч(Значение);

	Если ЕстьТип(Значение) Тогда
		Возврат (Значение.__Тип = "ОписаниеТипов");
	КонецЕсли;

	Если ТипЗначения = Тип("Структура") Тогда
		Возврат (Значение.Свойство("Типы")
		       И Значение.Свойство("КвалификаторыСтроки")
		       И Значение.Свойство("КвалификаторыЧисла")
		       И Значение.Свойство("КвалификаторыДаты"));
	КонецЕсли;

	Возврат (ТипЗначения = Тип("ОписаниеТипов"));

КонецФункции // ЭтоОписаниеТипов()

// Проверяет существование объекта по ссылке
//
// Параметры:
//  Значение    - ЛюбаяСсылка - ссылка на объект информационной базы
// 
// Возвращаемое значение:
//  Булево      - Истина - объект по ссылке существует,
//                Ложь   - в противном случае
//
Функция СсылкаСуществует(Значение) Экспорт
    
    Если НЕ ЗначениеЗаполнено(Значение) Тогда
    	Возврат Ложь;
    КонецЕсли;
    
    ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипЗнч(Значение));
    
    Если ОписаниеВида = Неопределено Тогда
        Возврат Ложь;
    КонецЕсли;
    
    Запрос = Новый Запрос("ВЫБРАТЬ
                          |    Таб.Ссылка
                          |ИЗ
                          |    &ИмяТаблицы КАК Таб
                          |ГДЕ
                          |    Таб.Ссылка = &Ссылка");
    
    Запрос.Текст = СтрЗаменить(Запрос.Текст,
                               "&ИмяТаблицы",
                               СтрШаблонВнутр("%1.%2", ОписаниеВида.Имя, ОписаниеВида.ИмяТипа));
    
    Запрос.УстановитьПараметр("Ссылка", Значение);
    
    УстановитьПривилегированныйРежим(Истина);
    
    Возврат НЕ Запрос.Выполнить().Пустой();
    
КонецФункции // СсылкаСуществует()

// Возвращает имя пердопределенных данных для переданного значения
// требуется, т.к. в разных версиях различается способ получения имени предопределенных данных
//
// Параметры:
//  Значение        - СправочникСсылка    - Имя значение ссылочного типа (СправочникСсылка, ПеречислениеСсылка и т.п.)
//                    ПеречислениеСсылка
//                    ПланВидовХарактеристикСсылка
//                    ПланВидовРасчетовСсылка
//                    ПланСчетовСсылка
//                    ПланОбменаСсылка
// Возвращаемое значение:
//   Строка    - Имя предопределенных данных, если значение не является предопределенным, возвращается пустая строка
//
Функция ПолучитьИмяПредопределенныхДанных(Значение) Экспорт

	ОписаниеМетаданного = КэшМетаданных()[ТипЗнч(Значение)];

	Если НЕ ТипЗнч(ОписаниеМетаданного) = Тип("Структура") Тогда
		Возврат "";
	КонецЕсли;

	ИмяКоллекции = ОписаниеМетаданного.Коллекция;

	ИмяПредопределенныхДанных = "";

	ЕстьПредопределенные = (ИмяКоллекции = "Справочники"
	                    ИЛИ ИмяКоллекции = "ПланыВидовХарактеристик"
	                    ИЛИ ИмяКоллекции = "ПланыВидовРасчетов"
	                    ИЛИ ИмяКоллекции = "ПланыСчетов");

	Если ИмяКоллекции = "Перечисления" Тогда
		ИндексЗначения = Перечисления[ОписаниеМетаданного.Имя].Индекс(Значение);
		ИмяПредопределенныхДанных = Метаданные.Перечисления[ОписаниеМетаданного.Имя].ЗначенияПеречисления[ИндексЗначения].Имя;
	ИначеЕсли ИмяКоллекции = "ПланыОбмена" Тогда
		Если Совместимость8_3(6) Тогда
			Если Значение.ЭтотУзел Тогда
				ИмяПредопределенныхДанных = "ЭтотУзел";
			КонецЕсли;
		ИначеЕсли Значение.Предопределенный Тогда
			ИмяПредопределенныхДанных = "ЭтотУзел";
		КонецЕсли;
	ИначеЕсли ЕстьПредопределенные Тогда
		Если Совместимость8_3(6) Тогда
			ИмяПредопределенныхДанных = Значение.ИмяПредопределенныхДанных;
		Иначе
			Код = СтрШаблонВнутр("%1[ОписаниеМетаданного.Имя].ПолучитьИмяПредопределенного(Значение)", ИмяКоллекции);
			ИмяПредопределенныхДанных = Вычислить(Код);
		КонецЕсли;
	КонецЕсли;

	Возврат ИмяПредопределенныхДанных;	

КонецФункции // ПолучитьИмяПредопределенныхДанных()

// Проверяет использование свойства (по имени) в соответствии со списками используемых и исключаемых свойств
//
// Параметры:
//  ИмяСвойства         - Строка                    - Имя проверяемого свойства
//  СписокСвойств       - Строка, Массив из Строка  - Список допустимых свойств
//                                                    (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив из Строка  - Список исключаемых свойств
//                                                    (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Булево             - Истина - свойство используется; Ложь - свойство не используется
//
Функция ИспользоватьСвойство(Знач ИмяСвойства, Знач СписокСвойств = Неопределено, Знач ИсключаяСвойства = Неопределено)

	Если ТипЗнч(СписокСвойств) = Тип("Строка") Тогда
		СписокСвойств = СтрРазделитьВнутр(СписокСвойств, ",", Ложь);
	КонецЕсли;
	Если НЕ ТипЗнч(СписокСвойств) = Тип("Массив") Тогда
		СписокСвойств = Новый Массив();
	КонецЕсли;

	Если ТипЗнч(ИсключаяСвойства) = Тип("Строка") Тогда
		ИсключаяСвойства = СтрРазделитьВнутр(ИсключаяСвойства, ",", Ложь);
	КонецЕсли;
	Если НЕ ТипЗнч(ИсключаяСвойства) = Тип("Массив") Тогда
		ИсключаяСвойства = Новый Массив();
	КонецЕсли;

	Если СписокСвойств.Количество() = 0 И ИсключаяСвойства.Количество() = 0 Тогда
		Возврат Истина;
	КонецЕсли;

	Если НЕ ИсключаяСвойства.Найти(ИмяСвойства) = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;

	Возврат (НЕ СписокСвойств.Найти(ИмяСвойства) = Неопределено) ИЛИ СписокСвойств.Количество() = 0;

КонецФункции // ИспользоватьСвойство()

// Функция, возвращает строковое представление типа данных
// 
// Параметры:
//     ПарамТип  - Тип, Строка - тип данных
// 
// Возвращаемое значение:
//     Строка    - строковое представление типа данных
//
Функция ПолучитьТипСтрокой(Знач ПарамТип) Экспорт

	МетаТип = Метаданные.НайтиПоТипу(ПарамТип);
	Если НЕ МетаТип = Неопределено Тогда
		 Возврат МетаТип.ПолноеИмя();
	КонецЕсли;

	ВремСтрока = СокрЛП(ПарамТип);
	Если Найти(ВремСтрока, " ") = 0 И Найти(ВремСтрока, "-") = 0 Тогда
		Возврат ВремСтрока;
	КонецЕсли;

	СтрокаТипа = "";
	ВерхнийРегистр = Истина;
	Для й = 1 По СтрДлина(ВремСтрока) Цикл
		Символ = Сред(ВремСтрока, й, 1);
		Если Символ = " " ИЛИ Символ = "-" Тогда
			ВерхнийРегистр = Истина;
			Продолжить;
		КонецЕсли;
		Если ВерхнийРегистр Тогда
			Символ = ВРег(Символ);
			ВерхнийРегистр = Ложь;
		КонецЕсли;
		СтрокаТипа = СтрокаТипа + Символ;
	КонецЦикла;

	Возврат СтрокаТипа;

КонецФункции // ПолучитьТипСтрокой()

// Преобразует описание типов в структуру
//
// Параметры:
//  ОписаниеТипов            - ОписаниеТипов                - Преобразуемое значение
//
// Возвращаемое значение:
//   Структура                                          - результат преобразования
//     *Типы                          - Массив из Строка  - Список типов
//     *КвалификаторыЧисла            - Структура         - Описание квалификаторов числа
//        **Разрядность                 - Число             - Разрядность
//        **РазрядностьДробнойЧасти     - Число             - Разрядность дробной части
//        **ДопустимыйЗнак              - ДопустимыйЗнак    - Допустимый знак
//     *КвалификаторыСтроки           - Структура         - Описание квалификаторов строки
//        **Длина                       - Число             - Длина
//        **ДопустимаяДлина             - ДопустимаяДлина   - Разрядность дробной части
//     *КвалификаторыДаты             - Структура         - Описание квалификаторов даты
//        **ЧастиДаты                   - ЧастиДаты         - Части даты (Дата / Время)
//     *КвалификаторыДвоичныхДанных   - Структура         - Описание квалификаторов двоичных данных
//        **Длина                       - Число             - Длина
//        **ДопустимаяДлина             - ДопустимаяДлина   - Разрядность дробной части
//
Функция ОписаниеТиповВСтруктуру(ОписаниеТипов) Экспорт

	СтруктураОписаниеТипов = Новый Структура();
	СтруктураОписаниеТипов.Вставить("__Тип"                      , "ОписаниеТипов");
	СтруктураОписаниеТипов.Вставить("Типы"                       , Новый Массив());
	СтруктураОписаниеТипов.Вставить("КвалификаторыЧисла",
	                                Новый Структура("Разрядность, РазрядностьДробнойЧасти, ДопустимыйЗнак", 10, 0));
	СтруктураОписаниеТипов.Вставить("КвалификаторыСтроки",
	                                Новый Структура("Длина, ДопустимаяДлина", 10, "Переменная"));
	СтруктураОписаниеТипов.Вставить("КвалификаторыДаты",
	                                Новый Структура("ЧастиДаты", "ДатаВремя"));
	СтруктураОписаниеТипов.Вставить("КвалификаторыДвоичныхДанных",
	                                Новый Структура("Длина, ДопустимаяДлина", 0, "Переменная"));
								   
	Для Каждого ТекТип Из ОписаниеТипов.Типы() Цикл
		СтруктураОписаниеТипов.Типы.Добавить(ПолучитьТипСтрокой(ТекТип));
	КонецЦикла;

	СтруктураОписаниеТипов.КвалификаторыЧисла.Разрядность             = ОписаниеТипов.КвалификаторыЧисла.Разрядность;
	СтруктураОписаниеТипов.КвалификаторыЧисла.РазрядностьДробнойЧасти =
		ОписаниеТипов.КвалификаторыЧисла.РазрядностьДробнойЧасти;

	Если ОписаниеТипов.КвалификаторыЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Неотрицательный Тогда
		СтруктураОписаниеТипов.КвалификаторыЧисла.ДопустимыйЗнак = "Неотрицательный";
	Иначе
		СтруктураОписаниеТипов.КвалификаторыЧисла.ДопустимыйЗнак = "Любой";
	КонецЕсли;

	СтруктураОписаниеТипов.КвалификаторыСтроки.Длина = ОписаниеТипов.КвалификаторыСтроки.Длина;

	Если ОписаниеТипов.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Фиксированная Тогда
		СтруктураОписаниеТипов.КвалификаторыСтроки.ДопустимаяДлина = "Фиксированная";
	Иначе
		СтруктураОписаниеТипов.КвалификаторыСтроки.ДопустимаяДлина = "Переменная";
	КонецЕсли;

	Если ОписаниеТипов.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.Дата Тогда
		СтруктураОписаниеТипов.КвалификаторыДаты.ЧастиДаты = "Дата";
	ИначеЕсли ОписаниеТипов.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.Время Тогда
		СтруктураОписаниеТипов.КвалификаторыДаты.ЧастиДаты = "Время";
	Иначе
		СтруктураОписаниеТипов.КвалификаторыДаты.ЧастиДаты = "ДатаВремя";
	КонецЕсли;

	СтруктураОписаниеТипов.КвалификаторыДвоичныхДанных.Длина = ОписаниеТипов.КвалификаторыДвоичныхДанных.Длина;

	Если ОписаниеТипов.КвалификаторыДвоичныхДанных.ДопустимаяДлина = ДопустимаяДлина.Фиксированная Тогда
		СтруктураОписаниеТипов.КвалификаторыДвоичныхДанных.ДопустимаяДлина = "Фиксированная";
	Иначе
		СтруктураОписаниеТипов.КвалификаторыДвоичныхДанных.ДопустимаяДлина = "Переменная";
	КонецЕсли;

	Возврат СтруктураОписаниеТипов;

КонецФункции // ОписаниеТиповВСтруктуру()

// Получает описание типов из структуры
//
// Параметры:
//   СтруктураОписаниеТипов         - Структура            - структура описания типов для преобразования
//     *Типы                          - Массив            - Список типов
//     *КвалификаторыЧисла            - Структура         - Описание квалификаторов числа
//        **Разрядность                 - Число             - Разрядность
//        **РазрядностьДробнойЧасти     - Число             - Разрядность дробной части
//        **ДопустимыйЗнак              - ДопустимыйЗнак    - Допустимый знак
//     *КвалификаторыСтроки           - Структура         - Описание квалификаторов строки
//        **Длина                       - Число             - Длина
//        **ДопустимаяДлина             - ДопустимаяДлина   - Разрядность дробной части
//     *КвалификаторыДаты             - Структура         - Описание квалификаторов даты
//        **ЧастиДаты                   - ЧастиДаты         - Части даты (Дата / Время)
//     *КвалификаторыДвоичныхДанных   - Структура         - Описание квалификаторов двоичных данных
//        **Длина                       - Число             - Длина
//        **ДопустимаяДлина             - ДопустимаяДлина   - Разрядность дробной части
//
// Возвращаемое значение:
//  ОписаниеТипов            - Созданное описание типов
//
Функция ОписаниеТиповИзСтруктуры(СтруктураОписаниеТипов) Экспорт

	МассивТипов = Новый Массив();

	Для Каждого ТекТип Из СтруктураОписаниеТипов.Типы Цикл
		Попытка
			НовыйТип = Тип(СтрЗаменить(ТекТип, ".", "Ссылка."));
			МассивТипов.Добавить(НовыйТип);
		Исключение
			Продолжить;
		КонецПопытки;
	КонецЦикла;
	
	ПараметрКвалификатора = Вычислить("ДопустимыйЗнак." + СтруктураОписаниеТипов.КвалификаторыЧисла.ДопустимыйЗнак);
	КвалификаторыЧисла = Новый КвалификаторыЧисла(СтруктураОписаниеТипов.КвалификаторыЧисла.Разрядность,
	                                              СтруктураОписаниеТипов.КвалификаторыЧисла.РазрядностьДробнойЧасти,
	                                              ПараметрКвалификатора);

	ПараметрКвалификатора = Вычислить("ДопустимаяДлина." + СтруктураОписаниеТипов.КвалификаторыСтроки.ДопустимаяДлина);
	КвалификаторыСтроки = Новый КвалификаторыСтроки(СтруктураОписаниеТипов.КвалификаторыСтроки.Длина,
	                                                ПараметрКвалификатора);

	ПараметрКвалификатора = Вычислить("ЧастиДаты." + СтруктураОписаниеТипов.КвалификаторыДаты.ЧастиДаты);
	КвалификаторыДаты = Новый КвалификаторыДаты(ПараметрКвалификатора);

	ПараметрКвалификатора =
		Вычислить("ДопустимаяДлина." + СтруктураОписаниеТипов.КвалификаторыДвоичныхДанных.ДопустимаяДлина);
	КвалификаторыДвоичныхДанных = Новый КвалификаторыДвоичныхДанных(СтруктураОписаниеТипов.КвалификаторыСтроки.Длина,
	                                                                ПараметрКвалификатора);
																		  
	Возврат Новый ОписаниеТипов(МассивТипов,
								КвалификаторыЧисла,
								КвалификаторыСтроки,
								КвалификаторыДаты,
								КвалификаторыДвоичныхДанных);

КонецФункции // ОписаниеТиповИзСтруктуры()

// Функция, возвращает признак использования реквизита иерархического объекта
// 
// Параметры:
//     Объект         - СправочникОбъект, СправочникСсылка                         - проверяемый объект 
//                      ПланВидовХарактеристикОбъект, ПланВидовХарактеристикСсылка
//     МетаСвойство   - ОбъектМетаданныхРеквизит                                   - проверяемый реквизит
//     МетаОбъект     - ОбъектМетаданных                                           - метаданные проверяемого объекта
//
// Возвращаемое значение:
//     Булево         - Истина - реквизит используется для объекта,
//                    - Ложь - в противном случае
//
Функция СвойствоИерархическогоОбъектаИспользуется(Объект, МетаСвойство, МетаОбъект = Неопределено)

	Если МетаОбъект = Неопределено Тогда
		МетаОбъект = Объект.Метаданные();
	КонецЕсли;

	Если НЕ МетаОбъект.Иерархический Тогда
		Возврат Истина;
	КонецЕсли;

	Если СтрокаНачинаетсяСВнутр(МетаОбъект.ПолноеИмя(), "Справочник.")
	   И МетаОбъект.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов
	 ИЛИ СтрокаНачинаетсяСВнутр(МетаОбъект.ПолноеИмя(), "ПланВидовХарактеристик.") Тогда

		Если (Объект.ЭтоГруппа
			  И МетаСвойство.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
		 ИЛИ (НЕ Объект.ЭтоГруппа
		      И МетаСвойство.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы) Тогда

			Возврат Ложь;

		КонецЕсли;

	КонецЕсли;

	Возврат Истина;

КонецФункции // СвойствоОбъектаИспользуется()

// Проверяет использование свойства объекта и добавляет в структуру
//
// Параметры:
//  СтруктураОбъекта    - Структура                   - заполняемая структура объекта
//  Объект              - Объект, ЛюбаяСсылка         - преобразуемый объект
//  ИмяСвойства         - Строка                      - имя добавляемого свойства
//  СписокСвойств       - Строка, Массив из Строка    - список допустимых свойств
//                                                      (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив из Строка    - список исключаемых свойств
//                                                      (если пустой, то допустимы все свойства)
//
Процедура СвойствоОбъектаВСтруктуру(СтруктураОбъекта,
                                    Объект,
                                    ИмяСвойства,
                                    СписокСвойств = Неопределено,
                                    ИсключаяСвойства = Неопределено)

	Если НЕ ИспользоватьСвойство(ИмяСвойства, СписокСвойств, ИсключаяСвойства) Тогда
		Возврат;
	КонецЕсли;

	СтруктураОбъекта.Вставить(ИмяСвойства, ЗначениеВСтруктуру(Объект[ИмяСвойства]));

КонецПроцедуры // СвойствоОбъектаВСтруктуру()

// Проверяет использование свойства объекта и заполняет значение свойства из структуры
//
// Параметры:
//  Объект              - Объект                    - Заполняемый объект
//  СтруктураОбъекта    - Структура                 - Структура объекта
//  ИмяСвойства         - Строка                    - Имя проверяемого свойства
//  ПолучатьБитыеСсылки - Булево                    - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//  СписокСвойств       - Строка, Массив из Строка  - Список допустимых свойств
//                                                    (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив из Строка  - Список исключаемых свойств
//                                                    (если пустой, то допустимы все свойства)
//
Процедура СвойствоОбъектаИзСтруктуры(Объект,
                                     СтруктураОбъекта,
                                     ИмяСвойства,
                                     ПолучатьБитыеСсылки = Ложь,
                                     СписокСвойств = Неопределено,
                                     ИсключаяСвойства = Неопределено)

	Если НЕ СтруктураОбъекта.Свойство(ИмяСвойства) Тогда
		Возврат;
	КонецЕсли;

	Если НЕ ИспользоватьСвойство(ИмяСвойства, СписокСвойств, ИсключаяСвойства) Тогда
		Возврат;
	КонецЕсли;

	Попытка
		Объект[ИмяСвойства] = ЗначениеИзСтруктуры(СтруктураОбъекта[ИмяСвойства], ПолучатьБитыеСсылки);
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВызватьИсключение СтрШаблонВнутр("Ошибка получения значения свойства ""%1"":%2%3",
		                                 ИмяСвойства,
		                                 Символы.ПС,
		                                 ТекстОшибки);
	КонецПопытки;

КонецПроцедуры // СвойствоОбъектаИзСтруктуры()

// Добавляет данные табличной части объекта в структуру
//
// Параметры:
//  СтруктураОбъекта   - Структура                 - Заполняемая структура объекта
//  Объект             - Объект, ЛюбаяСсылка       - Преобразуемый объект
//  ИмяТЧ              - Строка                    - Имя преобразуемой табличной части
//  СписокСвойств      - Строка, Массив из Строка  - Список допустимых свойств
//                                                   (если пустой, то допустимы все свойства)
//  ИсключаяСвойства   - Строка, Массив из Строка  - Список исключаемых свойств
//                                                   (если пустой, то допустимы все свойства)
//
Процедура ТЧОбъектаВСтруктуру(СтруктураОбъекта,
                              Объект,
                              ИмяТЧ,
                              СписокСвойств = Неопределено,
                              ИсключаяСвойства = Неопределено)

	Если НЕ ИспользоватьСвойство("__ТЧ." + ИмяТЧ, СписокСвойств, ИсключаяСвойства) Тогда
		Возврат;
	КонецЕсли;

	Если НЕ СтруктураОбъекта.Свойство("__ТЧ") Тогда
		СтруктураОбъекта.Вставить("__ТЧ", Новый Структура());
	КонецЕсли;

	МетаОбъект = Объект.Метаданные();

	МетаТЧ = МетаОбъект.ТабличныеЧасти.Найти(ИмяТЧ);

	Если МетаТЧ = Неопределено Тогда
		Возврат;
	КонецЕсли;

	МассивСтрок = Новый Массив();
	Для Каждого ТекСтрока Из Объект[ИмяТЧ] Цикл

		СтруктураСтроки = Новый Структура();
		СтруктураСтроки.Вставить("__Индекс", Объект[ИмяТЧ].Индекс(ТекСтрока));
		СтруктураСтроки.Вставить("НомерСтроки", ТекСтрока.НомерСтроки);

		Для Каждого ТекРеквизит Из МетаТЧ.Реквизиты Цикл
			ПутьКДанным = СтрШаблонВнутр("%1.%2", ИмяТЧ, ТекРеквизит.Имя);
			Если НЕ ИспользоватьСвойство(ПутьКДанным, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекРеквизит.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекРеквизит.Имя]));
		КонецЦикла;

		МассивСтрок.Добавить(СтруктураСтроки);

	КонецЦикла;

	СтруктураОбъекта.__ТЧ.Вставить(ИмяТЧ, МассивСтрок);

КонецПроцедуры // ТЧОбъектаВСтруктуру()

// Заполняет табличную часть объекта из структуры
//
// Параметры:
//  Объект                - Объект, ЛюбаяСсылка       - Заполняемый объект
//  СтруктураОбъекта      - Структура                 - Структура данных объекта
//  ИмяТЧ                 - Строка                    - Имя преобразуемой табличной части
//  ПолучатьБитыеСсылки   - Булево                    - Истина - если объект по ссылке не существует,
//                                                      будет возвращена битая ссылка;
//                                                      Ложь - будет возвращена пустая ссылка
//  СписокСвойств         - Строка, Массив из Строка  - Список допустимых свойств
//                                                      (если пустой, то допустимы все свойства)
//  ИсключаяСвойства      - Строка, Массив из Строка  - Список исключаемых свойств
//                                                      (если пустой, то допустимы все свойства)
//
Процедура ТЧОбъектаИзСтруктуры(Объект,
                               СтруктураОбъекта,
                               ИмяТЧ,
                               ПолучатьБитыеСсылки = Ложь,
                               СписокСвойств = Неопределено,
                               ИсключаяСвойства = Неопределено)

	Если НЕ СтруктураОбъекта.Свойство("__ТЧ") Тогда
		Возврат;
	КонецЕсли;

	Если НЕ СтруктураОбъекта.__ТЧ.Свойство(ИмяТЧ) Тогда
		Возврат;
	КонецЕсли;

	Если НЕ ИспользоватьСвойство("__ТЧ." + ИмяТЧ, СписокСвойств, ИсключаяСвойства) Тогда
		Возврат;
	КонецЕсли;

	МетаОбъект = Объект.Метаданные();

	МетаТЧ = МетаОбъект.ТабличныеЧасти.Найти(ИмяТЧ);

	Если МетаТЧ = Неопределено Тогда
		Возврат;
	КонецЕсли;

	Объект[ИмяТЧ].Очистить();

	МассивСтрок = СтруктураОбъекта.__ТЧ[ИмяТЧ];

	Для й = 0 По МассивСтрок.ВГраница() Цикл

		ТекСтрока   = МассивСтрок[й];
		НоваяСтрока = Объект[ИмяТЧ].Добавить();

		Для Каждого ТекРеквизит Из МетаТЧ.Реквизиты Цикл

			Если НЕ ТекСтрока.Свойство(ТекРеквизит.Имя) Тогда
				Продолжить;
			КонецЕсли;

			ПутьКДанным = СтрШаблонВнутр("%1.%2", ИмяТЧ, ТекРеквизит.Имя);
			Если НЕ ИспользоватьСвойство(ПутьКДанным, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;

			Попытка
				НоваяСтрока[ТекРеквизит.Имя] = ЗначениеИзСтруктуры(ТекСтрока[ТекРеквизит.Имя], ПолучатьБитыеСсылки);
			Исключение
				ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
				ВызватьИсключение СтрШаблонВнутр("Ошибка получения значения свойства ""%1"" табличной части ""%2"", в строке %3:%4%5",
				                                 ТекРеквизит.Имя,
				                                 ИмяТЧ,
				                                 й,
				                                 Символы.ПС,
				                                 ТекстОшибки);
			КонецПопытки;

		КонецЦикла;

	КонецЦикла;

КонецПроцедуры // ТЧОбъектаИзСтруктуры()

// Преобразует значения субконто записи регистра бухгалтерии в структуру
//
// Параметры:
//  Запись              - РегистрБухгалтерииЗапись    - Преобразуемая запись регистра бухгалтерии
//  ДтКт                - Строка                      - признак Дт/Кт - "Дт", "Кт", "" 
//  СписокСвойств       - Строка, Массив из Строка    - Список допустимых свойств
//                                                      (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив из Строка    - Список исключаемых свойств
//                                                      (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Массив из Структура                                    - результат преобразования
//     *НомерСтроки      - Число                            - Номер субконто
//     *ВидСубконто      - ПланВидовХарактеристикСсылка     - Вид субконто
//     *Значение         - Произвольный                     - Значение субконто
//
Функция ЗначенияСубконтоЗаписиВСтруктуру(Запись,
                                         ДтКт,
                                         СписокСвойств = Неопределено,
                                         ИсключаяСвойства = Неопределено)

	ВидыСубконто = Запись["Счет" + ДтКт].ВидыСубконто;
	ЗначенияСубконто = Запись["Субконто" + ДтКт];

	МассивСубконто = Новый Массив();
	й = 1;
	Для Каждого ТекСтрокаВида Из ВидыСубконто Цикл
		ПутьКДанным = СтрШаблонВнутр("Субконто%1%2", ДтКт, Формат(й, "ЧДЦ=; ЧГ="));
		Если НЕ ИспользоватьСвойство(ПутьКДанным, СписокСвойств, ИсключаяСвойства) Тогда
			й = й + 1;
			Продолжить;
		КонецЕсли;
		ОписаниеСубконто = Новый Структура();
		ОписаниеСубконто.Вставить("НомерСтроки", й);
		ОписаниеСубконто.Вставить("ВидСубконто", ЗначениеВСтруктуру(ТекСтрокаВида.ВидСубконто));
		ОписаниеСубконто.Вставить("Значение"   , ЗначениеВСтруктуру(ЗначенияСубконто[ТекСтрокаВида.ВидСубконто]));
		МассивСубконто.Добавить(ОписаниеСубконто);
		й = й + 1;
	КонецЦикла;

	Возврат МассивСубконто;

КонецФункции // ЗначенияСубконтоВСтруктуру()

// Заполняет значения субконто записи регистра бухгалтерии из структуры
//
// Параметры:
//  Запись              - РегистрБухгалтерииЗапись  - Заполняемая запись регистра бухгалтерии
//  СтруктураЗаписи     - Структура                 - Структура данных записи регистра бухгалтерии 
//  ДтКт                - Строка                    - признак Дт/Кт - "Дт", "Кт", "" 
//  ПолучатьБитыеСсылки - Булево                    - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//  СписокСвойств       - Строка, Массив из Строка  - Список допустимых свойств
//                                                    (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив из Строка  - Список исключаемых свойств
//                                                    (если пустой, то допустимы все свойства)
//
Процедура ЗначенияСубконтоЗаписиИзСтруктуры(Запись,
                                            СтруктураЗаписи,
                                            ДтКт,
                                            ПолучатьБитыеСсылки = Ложь,
                                            СписокСвойств = Неопределено,
                                            ИсключаяСвойства = Неопределено)

	ИмяСубконто = СтрШаблонВнутр("Субконто%1", ДтКт);
	ВидыСубконто = Запись["Счет" + ДтКт].ВидыСубконто;
	ЗначенияСубконто = Запись[ИмяСубконто];

	МассивСубконто = СтруктураЗаписи[ИмяСубконто];

	й = 1;
	Для Каждого ТекСтрока Из МассивСубконто Цикл

		ИмяСвойства = СтрШаблонВнутр("%1%2", ИмяСубконто, Формат(й, "ЧДЦ=; ЧГ="));
		Если НЕ ИспользоватьСвойство(ИмяСвойства, СписокСвойств, ИсключаяСвойства) Тогда
			й = й + 1;
			Продолжить;
		КонецЕсли;

		ВидСубконто = ЗначениеИзСтруктуры(ТекСтрока.ВидСубконто, ПолучатьБитыеСсылки);

		Если НЕ ЗначениеЗаполнено(ВидСубконто) Тогда
			й = й + 1;
			Продолжить;
		КонецЕсли;

		СтрокаВида = ВидыСубконто.Найти(ВидСубконто, "ВидСубконто");

		Если СтрокаВида = Неопределено Тогда
			й = й + 1;
			Продолжить;
		КонецЕсли;

		ЗначенияСубконто[ВидСубконто] = ЗначениеИзСтруктуры(ТекСтрока.Значение, ПолучатьБитыеСсылки);

		й = й + 1;

	КонецЦикла;

КонецПроцедуры // ЗначенияСубконтоИзСтруктуры()

// Заполняет значение измерения записи регистра бухгалтерии из структуры
// с учетом признаков учета счета
//
// Параметры:
//  Запись               - РегистрБухгалтерииЗапись    - Заполняемая запись регистра бухгалтерии
//  СтруктураЗаписи      - Структура                   - Структура данных записи регистра бухгалтерии 
//  ОписаниеПоля         - ОбъектМетаданных.Измерение  - Описание метаданных измерения регистра 
//  ДтКт                 - Строка                      - признак Дт/Кт - "Дт", "Кт", "" 
//  ПолучатьБитыеСсылки  - Булево                      - Истина - если объект по ссылке не существует,
//                                                       будет возвращена битая ссылка;
//                                                       Ложь - будет возвращена пустая ссылка
//  СписокСвойств        - Строка, Массив из Строка    - Список допустимых свойств
//                                                       (если пустой, то допустимы все свойства)
//  ИсключаяСвойства     - Строка, Массив из Строка    - Список исключаемых свойств
//                                                       (если пустой, то допустимы все свойства)
//
Процедура ЗаполнитьИзмерениеРегистраБухгалтерии(Запись,
                                                СтруктураЗаписи,
                                                ОписаниеПоля,
                                                ДтКт,
                                                ПолучатьБитыеСсылки = Ложь,
                                                СписокСвойств = Неопределено,
                                                ИсключаяСвойства = Неопределено)

	Если НЕ (СтруктураЗаписи.Свойство(ОписаниеПоля.Имя + ДтКт)
			 И ИспользоватьСвойство(ОписаниеПоля.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
		Возврат;
	КонецЕсли;

	ЗаполнятьЗначение = Истина;

	Если НЕ ОписаниеПоля.ПризнакУчета = Неопределено Тогда
		Если НЕ Запись["Счет" + ДтКт][ОписаниеПоля.ПризнакУчета.Имя] Тогда
			ЗаполнятьЗначение = Ложь;
			Запись[ОписаниеПоля.Имя + ДтКт] = NULL;
		КонецЕсли;
	КонецЕсли;

	Если ЗаполнятьЗначение Тогда
		Запись[ОписаниеПоля.Имя + ДтКт] = ЗначениеИзСтруктуры(СтруктураЗаписи[ОписаниеПоля.Имя + ДтКт],
		                                                      ПолучатьБитыеСсылки);
	КонецЕсли;

КонецПроцедуры // ЗаполнитьИзмерениеРегистраБухгалтерии()

// Заполняет значение ресурса записи регистра бухгалтерии из структуры
// с учетом признаков учета счета
//
// Параметры:
//  Запись              - РегистрБухгалтерииЗапись      - Заполняемая запись регистра бухгалтерии
//  СтруктураЗаписи     - Структура                     - Структура данных записи регистра бухгалтерии 
//  ОписаниеПоля        - ОбъектМетаданных.Ресурс       - Описание метаданных ресурса регистра 
//  ДтКт                - Строка                        - признак Дт/Кт - "Дт", "Кт", "" 
//  СписокСвойств       - Строка, Массив из Строка      - Список допустимых свойств
//                                                        (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив из Строка      - Список исключаемых свойств
//                                                        (если пустой, то допустимы все свойства)
//
Процедура ЗаполнитьРесурсРегистраБухгалтерии(Запись,
                                             СтруктураЗаписи,
                                             ОписаниеПоля,
                                             ДтКт,
                                             СписокСвойств,
                                             ИсключаяСвойства)

	Если НЕ (СтруктураЗаписи.Свойство(ОписаниеПоля.Имя + ДтКт)
			 И ИспользоватьСвойство(ОписаниеПоля.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
		Возврат;
	КонецЕсли;

	ЗаполнятьЗначение = Истина;

	Если НЕ ОписаниеПоля.ПризнакУчета = Неопределено Тогда
		Если НЕ Запись["Счет" + ДтКт][ОписаниеПоля.ПризнакУчета.Имя] Тогда
			ЗаполнятьЗначение = Ложь;
			Запись[ОписаниеПоля.Имя + ДтКт] = NULL;
		КонецЕсли;
	КонецЕсли;

	Если ЗаполнятьЗначение Тогда
		Запись[ОписаниеПоля.Имя + ДтКт] = ЗначениеИзСтруктуры(СтруктураЗаписи[ОписаниеПоля.Имя + ДтКт]);
	КонецЕсли;

КонецПроцедуры // ЗаполнитьРесурсРегистраБухгалтерии()

#КонецОбласти // ПреобразованияОбъектовСлужебные

#Область ПреобразованиеОбъектовОбработчики

// Получает правило преобразования в структуру для указанного типа значений
//
// Параметры:
//  ПолноеИмяТипа         - Строка    - Имя типа преобразуемого значения
//
// Возвращаемое значение:
//   Структура                      - Правило выгрузки типа
//     *ФункцияДополнения - Строка    - имя функции дополнительной обработки данных при выгрузке
//     *Модуль            - Модуль    - модуль из которого будет вызвана функция дополнения
//
Функция ПолучитьПравилоВыгрузкиТипа(ПолноеИмяТипа)

	Правила = ПолучитьПравилаВыгрузкиТипов();

	Возврат Правила[ПолноеИмяТипа];

КонецФункции // ПолучитьПравилоВыгрузкиТипа()

// Добавляет правило преобразования в структуру для указанного типа значений
//
// Параметры:
//    ТипИсточника         - Строка                   - Имя типа преобразуемого значения
//    ФункцияДополнения    - Строка                   - Имя функции преобразования значения
//    Модуль               - УправляемаяФорма, Модуль - модуль, содержащий функцию дополнения,
//                                                      Неопределено - функция будет вызвана
//                                                      из модуля обработки (этот модуль)
//
Процедура ДобавитьПравилоВыгрузкиТипа(ТипИсточника, ФункцияДополнения, Модуль = Неопределено) Экспорт

	Если НЕ ТипЗнч(ПравилаВыгрузкиТипов) = Тип("Соответствие") Тогда
		ПравилаВыгрузкиТипов = Новый Соответствие();
	КонецЕсли;

	ПравилаВыгрузкиТипов.Вставить(ТипИсточника, Новый Структура("ФункцияДополнения, Модуль", ФункцияДополнения, Модуль));

КонецПроцедуры // ДобавитьПравилоВыгрузкиТипа()

// Переопределяемая процедура, позволяющая дополнить алгоритмы преобразования данных в структуру
//
// Параметры:
//
// Возвращаемое значение:
//   Соответствие                             - правила выгрузки типов
//     *<ТипЗначения>       - Структура         - Имя выгружаемого типа значения
//       **ФункцияДополнения  - Строка            - Имя функции дополнительной обработки данных при выгрузке
//       **Модуль             - Модуль            - модуль из которого будет вызвана функция дополнения
//
Функция ПолучитьПравилаВыгрузкиТипов()

	Если НЕ ТипЗнч(ПравилаВыгрузкиТипов) = Тип("Соответствие") Тогда
		ПравилаВыгрузкиТипов = Новый Соответствие();
	КонецЕсли;

	Возврат ПравилаВыгрузкиТипов;

КонецФункции // ПолучитьПравилаВыгрузкиТипов()

// Получает правило преобразования данных из структуры для указанного типа значений
//
// Параметры:
//  ПолноеИмяТипа            - Строка                - Имя типа преобразуемого значения
//
// Возвращаемое значение:
//    Структура                                 - Правило выгрузки типа
//      *ТипЗначения          - Строка            - Имя типа значения целевых данных
//      *ФункцияПоиска        - Строка            - Имя функции поиска значения
//
Функция ПолучитьПравилоЗагрузкиТипа(ПолноеИмяТипа)

	Правила = ПолучитьПравилаЗагрузкиТипов();

	Правило = Правила[ПолноеИмяТипа];

	Если Правило = Неопределено Тогда
		Правило = Новый Структура("ТипЗначения, ФункцияПоиска, Модуль", ПолноеИмяТипа, "НайтиЗначениеПоОписанию");
	КонецЕсли;

	Возврат Правило;

КонецФункции // ПолучитьПравилоЗагрузкиТипа()

// Добавляет правило преобразования данных из структуры для указанного типа значений
//
// Параметры:
//    ТипИсточника             - Строка                   - Имя типа преобразуемого значения
//    ТипПриемника             - Строка                   - Имя типа целевого значения
//    ФункцияПоиска            - Строка                   - Имя функции поиска значения
//    Модуль                   - УправляемаяФорма, Модуль - модуль, содержащий функцию поиска,
//                                                          Неопределено - функция будет вызвана
//                                                          из модуля обработки (этот модуль)
//
Процедура ДобавитьПравилоЗагрузкиТипа(ТипИсточника, ТипПриемника, ФункцияПоиска, Модуль = Неопределено) Экспорт

	Если НЕ ТипЗнч(ПравилаЗагрузкиТипов) = Тип("Соответствие") Тогда
		ПравилаЗагрузкиТипов = Новый Соответствие();
	КонецЕсли;

	ПравилаЗагрузкиТипов.Вставить(ТипИсточника, Новый Структура());
	ПравилаЗагрузкиТипов[ТипИсточника].Вставить("ТипЗначения"  , ТипПриемника);
	ПравилаЗагрузкиТипов[ТипИсточника].Вставить("ФункцияПоиска", ФункцияПоиска);
	ПравилаЗагрузкиТипов[ТипИсточника].Вставить("Модуль"       , Модуль);

КонецПроцедуры // ДобавитьПравилоЗагрузкиТипа()

// Переопределяемая процедура, позволяющая дополнить алгоритмы преобразования данных из структуры
//
// Параметры:
//
// Возвращаемое значение:
//   Соответствие                                  - правила выгрузки типов
//     *Ключ                     - Строка            - имя типа значения преобразованных данных
//     *Значение                 - Структура
//       **ТипЗначения             - Строка            - имя типа значения целевых данных
//       **ФункцияПоиска           - Строка            - имя функции поиска значения
//
Функция ПолучитьПравилаЗагрузкиТипов()

	Если НЕ ТипЗнч(ПравилаЗагрузкиТипов) = Тип("Соответствие") Тогда
		ПравилаЗагрузкиТипов = Новый Соответствие();
	КонецЕсли;

	Возврат ПравилаЗагрузкиТипов;

КонецФункции // ПолучитьПравилаЗагрузкиТипов()

// Функция поиска значений по структуре описания (шаблон процедуры поиска)
// Ищет значение по имени предопределенных данных, затем по полному иидентификатору,
// затем по представлению (наименованию)
//
// Параметры:
//   ОписаниеВида            - Структура             - Описание вида значения
//   МетаОбъект              - ОписаниеМетаданных    - Описание метаданных обрабатываемого типа значений
//   ОписаниеЗначения        - Структура             - Структура значения для обработки
//   ПоискПоНаименованию     - Булево                - Истина - если значение не найдено по идентификатору,
//                                                     выполнить поиск по наименованию
//
// Возвращаемое значение:
//   ЛюбаяСсылка            - найденное значение
//
//@skip-warning
Функция НайтиЗначениеПоОписанию(ОписаниеВида, МетаОбъект, ОписаниеЗначения, Знач ПоискПоНаименованию = Ложь) Экспорт

	Коллекция = ОписаниеВида.Коллекция;

	Если ОписаниеЗначения.Свойство("ИмяПредопределенныхДанных") И ЗначениеЗаполнено(ОписаниеЗначения.ИмяПредопределенныхДанных) Тогда
		Если ПредставленияРавны(ОписаниеВида.Имя, "ПланОбмена")
		   И ПредставленияРавны(ОписаниеЗначения.ИмяПредопределенныхДанных, "ЭтотУзел") Тогда
			Возврат Коллекция[МетаОбъект.Имя].ЭтотУзел();
		Иначе
			Возврат Коллекция[МетаОбъект.Имя][ОписаниеЗначения.ИмяПредопределенныхДанных];
		КонецЕсли;
	Иначе
		Если ОписаниеЗначения.Свойство("ИдПолный") Тогда
			ВремСсылка = ЗначениеИзСтрокиВнутр(ОписаниеЗначения.ИдПолный);
		ИначеЕсли ОписаниеЗначения.Свойство("Ид") Тогда
			ВремСсылка = Коллекция[МетаОбъект.Имя].ПолучитьСсылку(Новый УникальныйИдентификатор(ОписаниеЗначения.Ид));
		Иначе
			ВремСсылка = Неопределено;
		КонецЕсли;
		Если СсылкаСуществует(ВремСсылка) Тогда
			Возврат ВремСсылка;
		КонецЕсли;
	КонецЕсли;

	Если ПоискПоНаименованию Тогда
		ПоискПоНаименованию = (ОписаниеЗначения.Свойство("Представление")
		                     И НЕ ПустаяСтрока(ОписаниеЗначения.Представление)
		                     И (ПредставленияРавны(ОписаниеВида.Имя, "Справочник")
		                    ИЛИ ПредставленияРавны(ОписаниеВида.Имя, "ПланВидовХарактеристик")
		                    ИЛИ ПредставленияРавны(ОписаниеВида.Имя, "ПланСчетов")
		                    ИЛИ ПредставленияРавны(ОписаниеВида.Имя, "ПланВидовРасчета")
		                    ИЛИ ПредставленияРавны(ОписаниеВида.Имя, "ПланОбмена")
		                    ИЛИ ПредставленияРавны(ОписаниеВида.Имя, "Задача")));
	КонецЕсли;

	Если ПоискПоНаименованию Тогда

		ВремСсылка = Коллекция[МетаОбъект.Имя].НайтиПоНаименованию(ОписаниеЗначения.Представление, Истина); 
		Если НЕ ВремСсылка.Пустая() Тогда
			Возврат ВремСсылка;
		КонецЕсли;

	КонецЕсли;

	Возврат Коллекция[МетаОбъект.Имя].ПустаяСсылка();

КонецФункции // НайтиЗначениеПоОписанию()

#КонецОбласти // ПреобразованиеОбъектовОбработчики

#Область ПреобразованияОбъектовПоВидам

// Преобразует элемент справочника в структуру
//
// Параметры:
//  Объект              - Объект, ЛюбаяСсылка       - Преобразуемый объект
//  СписокСвойств       - Строка, Массив(Строка)    - Список допустимых свойств
//                                                    (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)    - Список исключаемых свойств
//                                                    (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура                                       - результат преобразования
//     *Ссылка                        - Структура      - Описание ссылки на объект
//        **Тип                         - Строка         - Текстовое описание типа объекта
//        **Ид                          - Строка         - Уникальный идентификатор ссылки
//        **ИдПолный                    - Строка         - Преставление ссылки на объект,
//                                                         полученное функцией ЗначениеВСтрокуВнутр
//        **Предопределенный            - Булево         - Истина - предопределенное значение; Ложь - в противном случае
//        **ИмяПредопределенныхДанных   - Строка         - Имя предопределенного значения
//        **Представление               - Строка         - Стандатрное строковое представление объекта
//        **<имя поля>                  - Произвольный   - Дополнительные поля добавленные при выгрузке
//     *__ТЧ                          - Массив         - Массив табличных частей объекта
//     *<имя поля>                    - Произвольный   - Значения реквизитов объекта
//
Функция СправочникВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт

	СтруктураОбъекта = Новый Структура();

	МетаОбъект = Объект.Метаданные();

	Если НЕ ТипЗнч(Объект) = Тип(СтрШаблонВнутр("СправочникОбъект.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("СправочникОбъект.%1", МетаОбъект.Имя));

	Если Объект.Ссылка.Пустая() Тогда
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.ПолучитьСсылкуНового()));
	Иначе
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.Ссылка));
	КонецЕсли;

	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ЭтоГруппа", СписокСвойств, ИсключаяСвойства);

	СтруктураОбъекта.Вставить("Родитель", Неопределено);
	Если МетаОбъект.Иерархический Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Родитель", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;

	СтруктураОбъекта.Вставить("Владелец", Неопределено);
	Если МетаОбъект.Владельцы.Количество() > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Владелец", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;

	СтруктураОбъекта.Вставить("Код", Неопределено);
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Код", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;

	СтруктураОбъекта.Вставить("Наименование", Неопределено);
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;

	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		Если НЕ СвойствоИерархическогоОбъектаИспользуется(Объект, ТекРеквизит, МетаОбъект) Тогда
			Продолжить;
		КонецЕсли;
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;

	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		Если НЕ СвойствоИерархическогоОбъектаИспользуется(Объект, ТекТЧ, МетаОбъект) Тогда
			Продолжить;
		КонецЕсли;
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;

	Возврат СтруктураОбъекта;

КонецФункции // СправочникВСтруктуру()

// Заполняет справочник из структуры
//
// Параметры:
//  Объект               - Объект                    - Заполняемый объект
//  СтруктураОбъекта     - Структура                 - Данные для заполнения объекта
//     *Ссылка                        - Структура      - Описание ссылки на объект
//        **Тип                         - Строка         - Текстовое описание типа объекта
//        **Ид                          - Строка         - Уникальный идентификатор ссылки
//        **ИдПолный                    - Строка         - Преставление ссылки на объект,
//                                                         полученное функцией ЗначениеВСтрокуВнутр
//        **Предопределенный            - Булево         - Истина - предопределенное значение; Ложь - в противном случае
//        **ИмяПредопределенныхДанных   - Строка         - Имя предопределенного значения
//        **Представление               - Строка         - Стандатрное строковое представление объекта
//        **<имя поля>                  - Произвольный   - Дополнительные поля добавленные при выгрузке
//     *__ТЧ                          - Массив         - Массив табличных частей объекта
//     *<имя поля>                    - Произвольный   - Значения реквизитов объекта
//  ПолучатьБитыеСсылки  - Булево                   - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//  СписокСвойств        - Строка                   - Список допустимых свойств
//                         Массив из Строка           (если пустой, то допустимы все свойства)
//  ИсключаяСвойства     - Строка                   - Список исключаемых свойств
//                         Массив из Строка           (если пустой, то допустимы все свойства)
//
Процедура СправочникИзСтруктуры(Объект,
                                СтруктураОбъекта,
                                ПолучатьБитыеСсылки = Ложь,
                                СписокСвойств = Неопределено,
                                ИсключаяСвойства = Неопределено) Экспорт

	МетаОбъект = Объект.Метаданные();

	МетаСвойства = Метаданные.СвойстваОбъектов;

	СвойствоОбъектаИзСтруктуры(Объект,
	                           СтруктураОбъекта,
	                           "ПометкаУдаления",
	                           ,
	                           СписокСвойств,
	                           ИсключаяСвойства);

	Если МетаОбъект.Иерархический Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "Родитель",
		                           ПолучатьБитыеСсылки,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЕсли;

	Если МетаОбъект.Владельцы.Количество() > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "Владелец",
		                           ПолучатьБитыеСсылки,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЕсли;

	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "Код",
		                           ,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЕсли;

	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "Наименование",
		                           ,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЕсли;

	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		Если МетаОбъект.Иерархический И МетаОбъект.ВидИерархии = МетаСвойства.ВидИерархии.ИерархияГруппИЭлементов Тогда
			Если (Объект.ЭтоГруппа И ТекРеквизит.Использование = МетаСвойства.ИспользованиеРеквизита.ДляЭлемента)
			 ИЛИ (НЕ Объект.ЭтоГруппа И ТекРеквизит.Использование = МетаСвойства.ИспользованиеРеквизита.ДляГруппы)Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           ТекРеквизит.Имя,
		                           ПолучатьБитыеСсылки,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЦикла;

	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		Если МетаОбъект.Иерархический И МетаОбъект.ВидИерархии = МетаСвойства.ВидИерархии.ИерархияГруппИЭлементов Тогда
			Если (Объект.ЭтоГруппа И ТекТЧ.Использование = МетаСвойства.ИспользованиеРеквизита.ДляЭлемента)
			 ИЛИ (НЕ Объект.ЭтоГруппа И ТекТЧ.Использование = МетаСвойства.ИспользованиеРеквизита.ДляГруппы)Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		ТЧОбъектаИзСтруктуры(Объект,
		                     СтруктураОбъекта,
		                     ТекТЧ.Имя,
		                     ПолучатьБитыеСсылки,
		                     СписокСвойств,
		                     ИсключаяСвойства);
	КонецЦикла;

КонецПроцедуры // СправочникИзСтруктуры()

// Преобразует счет в структуру
//
// Параметры:
//  Объект              - Объект, ЛюбаяСсылка       - Преобразуемый объект
//  СписокСвойств       - Строка, Массив(Строка)    - Список допустимых свойств
//                                                    (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)    - Список исключаемых свойств
//                                                    (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура                                       - результат преобразования
//     *Ссылка                        - Структура      - Описание ссылки на объект
//        **Тип                         - Строка         - Текстовое описание типа объекта
//        **Ид                          - Строка         - Уникальный идентификатор ссылки
//        **ИдПолный                    - Строка         - Преставление ссылки на объект,
//                                                         полученное функцией ЗначениеВСтрокуВнутр
//        **Предопределенный            - Булево         - Истина - предопределенное значение; Ложь - в противном случае
//        **ИмяПредопределенныхДанных   - Строка         - Имя предопределенного значения
//        **Представление               - Строка         - Стандатрное строковое представление объекта
//        **<имя поля>                  - Произвольный   - Дополнительные поля добавленные при выгрузке
//     *__ТЧ                          - Массив         - Массив табличных частей объекта
//     *<имя поля>                    - Произвольный   - Значения реквизитов объекта
Функция ПланСчетовВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт

	СтруктураОбъекта = Новый Структура();

	МетаОбъект = Объект.Метаданные();

	Если НЕ ТипЗнч(Объект) = Тип(СтрШаблонВнутр("ПланСчетовОбъект.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("ПланСчетовОбъект.%1", МетаОбъект.Имя));

	Если Объект.Ссылка.Пустая() Тогда
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.ПолучитьСсылкуНового()));
	Иначе
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.Ссылка));
	КонецЕсли;

	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Забалансовый", СписокСвойств, ИсключаяСвойства);

	Если ИспользоватьСвойство("Вид", СписокСвойств, ИсключаяСвойства) Тогда
		Если Объект.Вид = ВидСчета.Активный Тогда
			СтруктураОбъекта.Вставить("Вид", "Активный");
		ИначеЕсли Объект.Вид = ВидСчета.Пассивный Тогда
			СтруктураОбъекта.Вставить("Вид", "Пассивный");
		Иначе
			СтруктураОбъекта.Вставить("Вид", "АктивноПассивный");
		КонецЕсли;
	КонецЕсли;

	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Родитель", СписокСвойств, ИсключаяСвойства);

	СтруктураОбъекта.Вставить("Код", Неопределено);
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Код", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;

	СтруктураОбъекта.Вставить("Порядок", Неопределено);
	Если МетаОбъект.ДлинаПорядка > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Порядок", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;

	СтруктураОбъекта.Вставить("Наименование", Неопределено);
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;

	Для Каждого ТекПризнак Из МетаОбъект.ПризнакиУчета Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекПризнак.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;

	СтруктураОбъекта.Вставить("ВидыСубконто", Новый Массив());
	Если ИспользоватьСвойство("ВидыСубконто", СписокСвойств, ИсключаяСвойства)
	   И МетаОбъект.МаксКоличествоСубконто > 0 Тогда
		й = 1;
		Для Каждого ТекСтрока Из Объект.ВидыСубконто Цикл
			ОписаниеСубконто = Новый Структура();
			ОписаниеСубконто.Вставить("НомерСтроки", й);
			ОписаниеСубконто.Вставить("ВидСубконто", ЗначениеВСтруктуру(ТекСтрока.ВидСубконто));
			ОписаниеСубконто.Вставить("ТолькоОбороты", ТекСтрока.ТолькоОбороты);

			Для Каждого ТекПризнак Из МетаОбъект.ПризнакиУчетаСубконто Цикл
				ОписаниеСубконто.Вставить(ТекПризнак.Имя, ТекСтрока[ТекПризнак.Имя]);
			КонецЦикла;
			СтруктураОбъекта.ВидыСубконто.Добавить(ОписаниеСубконто);
			й = й + 1;
		КонецЦикла;
	КонецЕсли;

	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;

	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;

	Возврат СтруктураОбъекта;

КонецФункции // ПланСчетовВСтруктуру()

// Заполняет счет из структуры
//
// Параметры:
//  Объект               - Объект                    - Заполняемый объект
//  СтруктураОбъекта     - Структура                 - Данные для заполнения объекта
//     *Ссылка                        - Структура      - Описание ссылки на объект
//        **Тип                         - Строка         - Текстовое описание типа объекта
//        **Ид                          - Строка         - Уникальный идентификатор ссылки
//        **ИдПолный                    - Строка         - Преставление ссылки на объект,
//                                                         полученное функцией ЗначениеВСтрокуВнутр
//        **Предопределенный            - Булево         - Истина - предопределенное значение; Ложь - в противном случае
//        **ИмяПредопределенныхДанных   - Строка         - Имя предопределенного значения
//        **Представление               - Строка         - Стандатрное строковое представление объекта
//        **<имя поля>                  - Произвольный   - Дополнительные поля добавленные при выгрузке
//     *__ТЧ                          - Массив         - Массив табличных частей объекта
//     *<имя поля>                    - Произвольный   - Значения реквизитов объекта
//  ПолучатьБитыеСсылки  - Булево                   - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//  СписокСвойств        - Строка                   - Список допустимых свойств
//                         Массив из Строка           (если пустой, то допустимы все свойства)
//  ИсключаяСвойства     - Строка                   - Список исключаемых свойств
//                         Массив из Строка           (если пустой, то допустимы все свойства)
//
Процедура ПланСчетовИзСтруктуры(Объект,
                                СтруктураОбъекта,
                                ПолучатьБитыеСсылки = Ложь,
                                СписокСвойств = Неопределено,
                                ИсключаяСвойства = Неопределено) Экспорт

	МетаОбъект = Объект.Метаданные();

	СвойствоОбъектаИзСтруктуры(Объект,
	                           СтруктураОбъекта,
	                           "ПометкаУдаления",
	                           ,
	                           СписокСвойств,
	                           ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект,
	                           СтруктураОбъекта,
	                           "Забалансовый",
	                           ,
	                           СписокСвойств,
	                           ИсключаяСвойства);
	Если ИспользоватьСвойство("Вид", СписокСвойств, ИсключаяСвойства) Тогда
		Объект.Вид = Вычислить("ВидСчета." + СтруктураОбъекта.Вид);
	КонецЕсли;

	СвойствоОбъектаИзСтруктуры(Объект,
	                           СтруктураОбъекта,
	                           "Родитель",
	                           ПолучатьБитыеСсылки,
	                           СписокСвойств,
	                           ИсключаяСвойства);

	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "Код",
		                           ,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЕсли;

	Если МетаОбъект.ДлинаПорядка > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "Порядок",
		                           ,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЕсли;

	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "Наименование",
		                           ,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЕсли;

	Для Каждого ТекПризнак Из МетаОбъект.ПризнакиУчета Цикл
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           ТекПризнак.Имя,
		                           ПолучатьБитыеСсылки,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЦикла;

	ЕстьСубконто = (СтруктураОбъекта.Свойство("ВидыСубконто")
	              И ИспользоватьСвойство("ВидыСубконто", СписокСвойств, ИсключаяСвойства)
	              И МетаОбъект.МаксКоличествоСубконто > 0);

	Если ЕстьСубконто Тогда
		Объект.ВидыСубконто.Очистить();
		Для Каждого ТекСтрока Из СтруктураОбъекта.ВидыСубконто Цикл
			Если Объект.ВидыСубконто.Количество() >= МетаОбъект.МаксКоличествоСубконто Тогда
				Прервать;
			КонецЕсли;
			НоваяСтрока = Объект.ВидыСубконто.Добавить();
			НоваяСтрока.ВидСубконто		= ЗначениеИзСтруктуры(ТекСтрока.ВидСубконто, ПолучатьБитыеСсылки);
			НоваяСтрока.ТолькоОбороты	= ТекСтрока.ТолькоОбороты;

			Для Каждого ТекПризнак Из МетаОбъект.ПризнакиУчетаСубконто Цикл
				Если НЕ ТекСтрока.Свойство(ТекПризнак.Имя) Тогда
					Продолжить;
				КонецЕсли;
				НоваяСтрока[ТекПризнак.Имя] = ТекСтрока[ТекПризнак.Имя];
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;

	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           ТекРеквизит.Имя,
		                           ПолучатьБитыеСсылки,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЦикла;

	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаИзСтруктуры(Объект,
		                     СтруктураОбъекта,
		                     ТекТЧ.Имя,
		                     ПолучатьБитыеСсылки,
		                     СписокСвойств,
		                     ИсключаяСвойства);
	КонецЦикла;

КонецПроцедуры // ПланСчетовИзСтруктуры()

// Преобразует элемент плана видов характеристик в структуру
//
// Параметры:
//  Объект              - Объект, ЛюбаяСсылка       - Преобразуемый объект
//  СписокСвойств       - Строка                    - Список допустимых свойств
//                        Массив из Строка            (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка                    - Список исключаемых свойств
//                        Массив из Строка            (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура                                       - результат преобразования
//     *Ссылка                        - Структура      - Описание ссылки на объект
//        **Тип                         - Строка         - Текстовое описание типа объекта
//        **Ид                          - Строка         - Уникальный идентификатор ссылки
//        **ИдПолный                    - Строка         - Преставление ссылки на объект,
//                                                         полученное функцией ЗначениеВСтрокуВнутр
//        **Предопределенный            - Булево         - Истина - предопределенное значение; Ложь - в противном случае
//        **ИмяПредопределенныхДанных   - Строка         - Имя предопределенного значения
//        **Представление               - Строка         - Стандатрное строковое представление объекта
//        **<имя поля>                  - Произвольный   - Дополнительные поля добавленные при выгрузке
//     *__ТЧ                          - Массив         - Массив табличных частей объекта
//     *<имя поля>                    - Произвольный   - Значения реквизитов объекта
//
Функция ПланВидовХарактеристикВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт

	СтруктураОбъекта = Новый Структура();

	МетаОбъект = Объект.Метаданные();

	Если НЕ ТипЗнч(Объект) = Тип(СтрШаблонВнутр("ПланВидовХарактеристикОбъект.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("ПланВидовХарактеристикОбъект.%1", МетаОбъект.Имя));

	Если Объект.Ссылка.Пустая() Тогда
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.ПолучитьСсылкуНового()));
	Иначе
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.Ссылка));
	КонецЕсли;

	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ЭтоГруппа", СписокСвойств, ИсключаяСвойства);

	СтруктураОбъекта.Вставить("Родитель", Неопределено);
	Если МетаОбъект.Иерархический Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Родитель", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;

	СтруктураОбъекта.Вставить("Код", Неопределено);
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Код", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;

	СтруктураОбъекта.Вставить("Наименование", Неопределено);
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;

	СтруктураОбъекта.Вставить("ТипЗначения", ОписаниеТиповВСтруктуру(Объект.ТипЗначения));

	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		Если НЕ СвойствоИерархическогоОбъектаИспользуется(Объект, ТекРеквизит) Тогда
			Продолжить;
		КонецЕсли;
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;

	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		Если НЕ СвойствоИерархическогоОбъектаИспользуется(Объект, ТекТЧ) Тогда
			Продолжить;
		КонецЕсли;
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;

	Возврат СтруктураОбъекта;

КонецФункции // ПланВидовХарактеристикВСтруктуру()

// Заполняет элемент плана вида характеристик из структуры
//
// Параметры:
//  Объект               - Объект                    - Заполняемый объект
//  СтруктураОбъекта     - Структура                 - Данные для заполнения объекта
//     *Ссылка                        - Структура      - Описание ссылки на объект
//        **Тип                         - Строка         - Текстовое описание типа объекта
//        **Ид                          - Строка         - Уникальный идентификатор ссылки
//        **ИдПолный                    - Строка         - Преставление ссылки на объект,
//                                                         полученное функцией ЗначениеВСтрокуВнутр
//        **Предопределенный            - Булево         - Истина - предопределенное значение; Ложь - в противном случае
//        **ИмяПредопределенныхДанных   - Строка         - Имя предопределенного значения
//        **Представление               - Строка         - Стандатрное строковое представление объекта
//        **<имя поля>                  - Произвольный   - Дополнительные поля добавленные при выгрузке
//     *__ТЧ                          - Массив         - Массив табличных частей объекта
//     *<имя поля>                    - Произвольный   - Значения реквизитов объекта
//  ПолучатьБитыеСсылки  - Булево                   - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//  СписокСвойств        - Строка                   - Список допустимых свойств
//                         Массив из Строка           (если пустой, то допустимы все свойства)
//  ИсключаяСвойства     - Строка                   - Список исключаемых свойств
//                         Массив из Строка           (если пустой, то допустимы все свойства)
//
Процедура ПланВидовХарактеристикИзСтруктуры(Объект,
                                            СтруктураОбъекта,
                                            ПолучатьБитыеСсылки = Ложь,
                                            СписокСвойств = Неопределено,
                                            ИсключаяСвойства = Неопределено) Экспорт

	МетаОбъект = Объект.Метаданные();

	СвойствоОбъектаИзСтруктуры(Объект,
	                           СтруктураОбъекта,
	                           "ПометкаУдаления",
	                           ,
	                           СписокСвойств,
	                           ИсключаяСвойства);

	Если МетаОбъект.Иерархический Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "Родитель",
		                           ПолучатьБитыеСсылки,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЕсли;

	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "Код",
		                           ,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЕсли;

	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "Наименование",
		                           ,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЕсли;

	Если СтруктураОбъекта.ТипЗначения.Типы.Количество() > 0 Тогда
		Объект.ТипЗначения = ОписаниеТиповИзСтруктуры(СтруктураОбъекта.ТипЗначения);
	КонецЕсли;

	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		Если МетаОбъект.Иерархический Тогда
			Если (Объект.ЭтоГруппа
				  И ТекРеквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
			 ИЛИ (НЕ Объект.ЭтоГруппа
			      И ТекРеквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы)Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           ТекРеквизит.Имя,
		                           ПолучатьБитыеСсылки,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЦикла;

	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		Если МетаОбъект.Иерархический Тогда
			Если (Объект.ЭтоГруппа И ТекТЧ.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
			 ИЛИ (НЕ Объект.ЭтоГруппа И ТекТЧ.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы)Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		ТЧОбъектаИзСтруктуры(Объект,
		                     СтруктураОбъекта,
		                     ТекТЧ.Имя,
		                     ПолучатьБитыеСсылки,
		                     СписокСвойств,
		                     ИсключаяСвойства);
	КонецЦикла;

КонецПроцедуры // ПланВидовХарактеристикИзСтруктуры()

// Преобразует вид расчета в структуру
//
// Параметры:
//  Объект              - Объект, ЛюбаяСсылка       - Преобразуемый объект
//  СписокСвойств       - Строка                    - Список допустимых свойств
//                        Массив из Строка            (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка                    - Список исключаемых свойств
//                        Массив из Строка            (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура                                       - результат преобразования
//     *Ссылка                        - Структура      - Описание ссылки на объект
//        **Тип                         - Строка         - Текстовое описание типа объекта
//        **Ид                          - Строка         - Уникальный идентификатор ссылки
//        **ИдПолный                    - Строка         - Преставление ссылки на объект,
//                                                         полученное функцией ЗначениеВСтрокуВнутр
//        **Предопределенный            - Булево         - Истина - предопределенное значение; Ложь - в противном случае
//        **ИмяПредопределенныхДанных   - Строка         - Имя предопределенного значения
//        **Представление               - Строка         - Стандатрное строковое представление объекта
//        **<имя поля>                  - Произвольный   - Дополнительные поля добавленные при выгрузке
//     *__ТЧ                          - Массив         - Массив табличных частей объекта
//     *<имя поля>                    - Произвольный   - Значения реквизитов объекта
//
Функция ПланВидовРасчетаВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт

	СтруктураОбъекта = Новый Структура();

	МетаОбъект = Объект.Метаданные();

	Если НЕ ТипЗнч(Объект) = Тип(СтрШаблонВнутр("ПланВидовРасчетаОбъект.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("ПланВидовРасчетаОбъект.%1", МетаОбъект.Имя));

	Если Объект.Ссылка.Пустая() Тогда
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.ПолучитьСсылкуНового()));
	Иначе
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.Ссылка));
	КонецЕсли;

	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);

	СтруктураОбъекта.Вставить("БазовыеВидыРасчета", Новый Массив());
	Если НЕ МетаОбъект.ЗависимостьОтВидовРасчета =
			Метаданные.СвойстваОбъектов.ИспользованиеБазыПланаВидовРасчета.НеИспользовать
	   И ИспользоватьСвойство("БазовыеВидыРасчета", СписокСвойств, ИсключаяСвойства) Тогда
		Для Каждого ТекВР Из Объект.БазовыеВидыРасчета Цикл
			СтруктураОбъекта.БазовыеВидыРасчета.Добавить(ЗначениеВСтруктуру(ТекВР.ВидРасчета));
		КонецЦикла;
	КонецЕсли;

	СтруктураОбъекта.Вставить("ВедущиеВидыРасчета", Новый Массив());
	Если ИспользоватьСвойство("ВедущиеВидыРасчета", СписокСвойств, ИсключаяСвойства) Тогда
		Для Каждого ТекВР Из Объект.ВедущиеВидыРасчета Цикл
			СтруктураОбъекта.ВедущиеВидыРасчета.Добавить(ЗначениеВСтруктуру(ТекВР.ВидРасчета));
		КонецЦикла;
	КонецЕсли;

	СтруктураОбъекта.Вставить("ВытесняющиеВидыРасчета", Новый Массив());
	Если МетаОбъект.ИспользованиеПериодаДействия
	   И ИспользоватьСвойство("ВытесняющиеВидыРасчета", СписокСвойств, ИсключаяСвойства) Тогда
		Для Каждого ТекВР Из Объект.ВытесняющиеВидыРасчета Цикл
			СтруктураОбъекта.ВытесняющиеВидыРасчета.Добавить(ЗначениеВСтруктуру(ТекВР.ВидРасчета));
		КонецЦикла;
	КонецЕсли;

	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПериодДействияБазовый", СписокСвойств, ИсключаяСвойства);

	СтруктураОбъекта.Вставить("Код", Неопределено);
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Код", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	СтруктураОбъекта.Вставить("Наименование", Неопределено);
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;

	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;

	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;

	Возврат СтруктураОбъекта;

КонецФункции // ПланВидовРасчетаВСтруктуру()

// Заполняет вид расчета из структуры
//
// Параметры:
//  Объект               - Объект                    - Заполняемый объект
//  СтруктураОбъекта     - Структура                 - Данные для заполнения объекта
//     *Ссылка                        - Структура      - Описание ссылки на объект
//        **Тип                         - Строка         - Текстовое описание типа объекта
//        **Ид                          - Строка         - Уникальный идентификатор ссылки
//        **ИдПолный                    - Строка         - Преставление ссылки на объект,
//                                                         полученное функцией ЗначениеВСтрокуВнутр
//        **Предопределенный            - Булево         - Истина - предопределенное значение; Ложь - в противном случае
//        **ИмяПредопределенныхДанных   - Строка         - Имя предопределенного значения
//        **Представление               - Строка         - Стандатрное строковое представление объекта
//        **<имя поля>                  - Произвольный   - Дополнительные поля добавленные при выгрузке
//     *__ТЧ                          - Массив         - Массив табличных частей объекта
//     *<имя поля>                    - Произвольный   - Значения реквизитов объекта
//  ПолучатьБитыеСсылки  - Булево                   - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//  СписокСвойств        - Строка                   - Список допустимых свойств
//                         Массив из Строка           (если пустой, то допустимы все свойства)
//  ИсключаяСвойства     - Строка                   - Список исключаемых свойств
//                         Массив из Строка           (если пустой, то допустимы все свойства)
//
Процедура ПланВидовРасчетаИзСтруктуры(Объект,
                                      СтруктураОбъекта,
                                      ПолучатьБитыеСсылки = Ложь,
                                      СписокСвойств = Неопределено,
                                      ИсключаяСвойства = Неопределено) Экспорт

	МетаОбъект = Объект.Метаданные();

	СвойствоОбъектаИзСтруктуры(Объект,
	                           СтруктураОбъекта,
	                           "ПометкаУдаления",
	                           ,
	                           СписокСвойств,
	                           ИсключаяСвойства);

	Если НЕ МетаОбъект.ЗависимостьОтВидовРасчета =
	     Метаданные.СвойстваОбъектов.ИспользованиеБазыПланаВидовРасчета.НеИспользовать
	   И ИспользоватьСвойство("БазовыеВидыРасчета", СписокСвойств, ИсключаяСвойства) Тогда
		Объект.БазовыеВидыРасчета.Очистить();
		Для Каждого ТекВР Из СтруктураОбъекта.БазовыеВидыРасчета Цикл
			ВремВР = ЗначениеИзСтруктуры(ТекВР, ПолучатьБитыеСсылки);
			Если НЕ ЗначениеЗаполнено(ВремВР) Тогда
				Продолжить;
			КонецЕсли;
			НоваяСтрока = Объект.БазовыеВидыРасчета.Добавить();
			НоваяСтрока.ВидРасчета = ВремВР;
		КонецЦикла;
	КонецЕсли;

	Если ИспользоватьСвойство("ВедущиеВидыРасчета", СписокСвойств, ИсключаяСвойства) Тогда
		Объект.ВедущиеВидыРасчета.Очистить();
		Для Каждого ТекВР Из СтруктураОбъекта.ВедущиеВидыРасчета Цикл
			ВремВР = ЗначениеИзСтруктуры(ТекВР, ПолучатьБитыеСсылки);
			Если НЕ ЗначениеЗаполнено(ВремВР) Тогда
				Продолжить;
			КонецЕсли;
			НоваяСтрока = Объект.ВедущиеВидыРасчета.Добавить();
			НоваяСтрока.ВидРасчета = ВремВР;
		КонецЦикла;
	КонецЕсли;

	Если МетаОбъект.ИспользованиеПериодаДействия
	   И ИспользоватьСвойство("ВытесняющиеВидыРасчета", СписокСвойств, ИсключаяСвойства) Тогда
		Объект.ВытесняющиеВидыРасчета.Очистить();
		Для Каждого ТекВР Из СтруктураОбъекта.ВытесняющиеВидыРасчета Цикл
			ВремВР = ЗначениеИзСтруктуры(ТекВР, ПолучатьБитыеСсылки);
			Если НЕ ЗначениеЗаполнено(ВремВР) Тогда
				Продолжить;
			КонецЕсли;
			НоваяСтрока = Объект.ВытесняющиеВидыРасчета.Добавить();
			НоваяСтрока.ВидРасчета = ВремВР;
		КонецЦикла;
	КонецЕсли;

	СвойствоОбъектаИзСтруктуры(Объект,
	                           СтруктураОбъекта,
	                           "ПериодДействияБазовый",
	                           ,
	                           СписокСвойств,
	                           ИсключаяСвойства);

	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "Код",
		                           ,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЕсли;

	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "Наименование",
		                           ,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЕсли;

	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           ТекРеквизит.Имя,
		                           ПолучатьБитыеСсылки,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЦикла;

	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаИзСтруктуры(Объект,
		                     СтруктураОбъекта,
		                     ТекТЧ.Имя,
		                     ПолучатьБитыеСсылки,
		                     СписокСвойств,
		                     ИсключаяСвойства);
	КонецЦикла;

КонецПроцедуры // ПланВидовРасчетаИзСтруктуры()

// Преобразует узел обмена в структуру
//
// Параметры:
//  Объект              - Объект, ЛюбаяСсылка       - Преобразуемый объект
//  СписокСвойств       - Строка, Массив(Строка)    - Список допустимых свойств
//                                                    (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)    - Список исключаемых свойств
//                                                    (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура                                       - результат преобразования
//     *Ссылка                        - Структура      - Описание ссылки на объект
//        **Тип                         - Строка         - Текстовое описание типа объекта
//        **Ид                          - Строка         - Уникальный идентификатор ссылки
//        **ИдПолный                    - Строка         - Преставление ссылки на объект,
//                                                         полученное функцией ЗначениеВСтрокуВнутр
//        **Предопределенный            - Булево         - Истина - предопределенное значение; Ложь - в противном случае
//        **ИмяПредопределенныхДанных   - Строка         - Имя предопределенного значения
//        **Представление               - Строка         - Стандатрное строковое представление объекта
//        **<имя поля>                  - Произвольный   - Дополнительные поля добавленные при выгрузке
//     *__ТЧ                          - Массив         - Массив табличных частей объекта
//     *<имя поля>                    - Произвольный   - Значения реквизитов объекта
//
Функция ПланОбменаВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт

	СтруктураОбъекта = Новый Структура();

	МетаОбъект = Объект.Метаданные();

	Если НЕ ТипЗнч(Объект) = Тип(СтрШаблонВнутр("ПланОбменаОбъект.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("ПланОбменаОбъект.%1", МетаОбъект.Имя));

	Если Объект.Ссылка.Пустая() Тогда
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.ПолучитьСсылкуНового()));
	Иначе
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.Ссылка));
	КонецЕсли;

	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);

	// совместимость с версиями < 8.3.5
	Попытка
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ЭтотУзел", СписокСвойств, ИсключаяСвойства);
	Исключение
		Если ИспользоватьСвойство("ЭтотУзел", СписокСвойств, ИсключаяСвойства) Тогда
			Если Объект.Ссылка.Пустая() Тогда
				СтруктураОбъекта.Вставить("ЭтотУзел", ПланыОбмена[МетаОбъект.Имя].ЭтотУзел() = Объект.ПолучитьСсылкуНового());
			Иначе
				СтруктураОбъекта.Вставить("ЭтотУзел", ПланыОбмена[МетаОбъект.Имя].ЭтотУзел() = Объект.Ссылка);
			КонецЕсли;
		КонецЕсли;
	КонецПопытки;
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "НомерОтправленного", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "НомерПринятого", СписокСвойств, ИсключаяСвойства);

	СтруктураОбъекта.Вставить("Код", Неопределено);
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Код", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;

	СтруктураОбъекта.Вставить("Наименование", Неопределено);
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;

	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;

	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;

	Возврат СтруктураОбъекта;

КонецФункции // ПланОбменаВСтруктуру()

// Заполняет узел плана обмена из структуры
//
// Параметры:
//  Объект               - Объект                    - Заполняемый объект
//  СтруктураОбъекта     - Структура                 - Данные для заполнения объекта
//     *Ссылка                        - Структура      - Описание ссылки на объект
//        **Тип                         - Строка         - Текстовое описание типа объекта
//        **Ид                          - Строка         - Уникальный идентификатор ссылки
//        **ИдПолный                    - Строка         - Преставление ссылки на объект,
//                                                         полученное функцией ЗначениеВСтрокуВнутр
//        **Предопределенный            - Булево         - Истина - предопределенное значение; Ложь - в противном случае
//        **ИмяПредопределенныхДанных   - Строка         - Имя предопределенного значения
//        **Представление               - Строка         - Стандатрное строковое представление объекта
//        **<имя поля>                  - Произвольный   - Дополнительные поля добавленные при выгрузке
//     *__ТЧ                          - Массив         - Массив табличных частей объекта
//     *<имя поля>                    - Произвольный   - Значения реквизитов объекта
//  ПолучатьБитыеСсылки  - Булево                   - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//  СписокСвойств        - Строка                   - Список допустимых свойств
//                         Массив из Строка           (если пустой, то допустимы все свойства)
//  ИсключаяСвойства     - Строка                   - Список исключаемых свойств
//                         Массив из Строка           (если пустой, то допустимы все свойства)
//
Процедура ПланОбменаИзСтруктуры(Объект,
                                СтруктураОбъекта,
                                ПолучатьБитыеСсылки = Ложь,
                                СписокСвойств = Неопределено,
                                ИсключаяСвойства = Неопределено) Экспорт

	МетаОбъект = Объект.Метаданные();

	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "ПометкаУдаления", , СписокСвойств, ИсключаяСвойства);

	Если Совместимость8_3(5) Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "ЭтотУзел",
		                           ,
		                           СписокСвойств, ИсключаяСвойства);
	КонецЕсли;

	Если НЕ Объект.ЭтотУзел Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "НомерОтправленного",
		                           ,
		                           СписокСвойств,
		                           ИсключаяСвойства);
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "НомерПринятого",
		                           ,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЕсли;

	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "Код",
		                           ,
		                           СписокСвойств, ИсключаяСвойства);
	КонецЕсли;

	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "Наименование",
		                           ,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЕсли;

	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           ТекРеквизит.Имя,
		                           ПолучатьБитыеСсылки,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЦикла;

	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаИзСтруктуры(Объект,
		                     СтруктураОбъекта,
		                     ТекТЧ.Имя,
		                     ПолучатьБитыеСсылки,
		                     СписокСвойств,
		                     ИсключаяСвойства);
	КонецЦикла;

КонецПроцедуры // ПланОбменаИзСтруктуры()

// Преобразует документ в структуру
//
// Параметры:
//  Объект              - Объект, ЛюбаяСсылка      - Преобразуемый объект
//  СписокСвойств       - Строка                   - Список допустимых свойств
//                        Массив из Строка           (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка                   - Список исключаемых свойств
//                        Массив из Строка           (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура                                       - результат преобразования
//     *Ссылка                        - Структура      - Описание ссылки на объект
//        **Тип                         - Строка         - Текстовое описание типа объекта
//        **Ид                          - Строка         - Уникальный идентификатор ссылки
//        **ИдПолный                    - Строка         - Преставление ссылки на объект,
//                                                         полученное функцией ЗначениеВСтрокуВнутр
//        **Предопределенный            - Булево         - Истина - предопределенное значение; Ложь - в противном случае
//        **ИмяПредопределенныхДанных   - Строка         - Имя предопределенного значения
//        **Представление               - Строка         - Стандатрное строковое представление объекта
//        **<имя поля>                  - Произвольный   - Дополнительные поля добавленные при выгрузке
//     *__ТЧ                          - Массив         - Массив табличных частей объекта
//     *<имя поля>                    - Произвольный   - Значения реквизитов объекта
//
Функция ДокументВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт

	СтруктураОбъекта = Новый Структура();

	МетаОбъект = Объект.Метаданные();

	Если НЕ ТипЗнч(Объект) = Тип(СтрШаблонВнутр("ДокументОбъект.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("ДокументОбъект.%1", МетаОбъект.Имя));

	Если Объект.Ссылка.Пустая() Тогда
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.ПолучитьСсылкуНового()));
	Иначе
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.Ссылка));
	КонецЕсли;

	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Проведен", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Дата", СписокСвойств, ИсключаяСвойства);

	СтруктураОбъекта.Вставить("Номер", Неопределено);
	// TODO: Тут еще нужно проверить использование нумератора
	Если МетаОбъект.ДлинаНомера > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Номер", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;

	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;

	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;

	Если ИспользоватьСвойство("Движения", СписокСвойств, ИсключаяСвойства) Тогда
		СтруктураОбъекта.Вставить("Движения", ДвиженияДокументаВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства));
	КонецЕсли;

	Возврат СтруктураОбъекта;

КонецФункции // ДокументВСтруктуру()

// Заполняет документ из структуры
//
// Параметры:
//  Объект               - Объект                    - Заполняемый объект
//  СтруктураОбъекта     - Структура                 - Данные для заполнения объекта
//     *Ссылка                        - Структура      - Описание ссылки на объект
//        **Тип                         - Строка         - Текстовое описание типа объекта
//        **Ид                          - Строка         - Уникальный идентификатор ссылки
//        **ИдПолный                    - Строка         - Преставление ссылки на объект,
//                                                         полученное функцией ЗначениеВСтрокуВнутр
//        **Предопределенный            - Булево         - Истина - предопределенное значение; Ложь - в противном случае
//        **ИмяПредопределенныхДанных   - Строка         - Имя предопределенного значения
//        **Представление               - Строка         - Стандатрное строковое представление объекта
//        **<имя поля>                  - Произвольный   - Дополнительные поля добавленные при выгрузке
//     *__ТЧ                          - Массив         - Массив табличных частей объекта
//     *<имя поля>                    - Произвольный   - Значения реквизитов объекта
//  ПолучатьБитыеСсылки  - Булево                   - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//  СписокСвойств        - Строка                   - Список допустимых свойств
//                         Массив из Строка           (если пустой, то допустимы все свойства)
//  ИсключаяСвойства     - Строка                   - Список исключаемых свойств
//                         Массив из Строка           (если пустой, то допустимы все свойства)
//
Процедура ДокументИзСтруктуры(Объект,
                              СтруктураОбъекта,
                              ПолучатьБитыеСсылки = Ложь,
                              СписокСвойств = Неопределено,
                              ИсключаяСвойства = Неопределено) Экспорт

	МетаОбъект = Объект.Метаданные();

	СвойствоОбъектаИзСтруктуры(Объект,
	                           СтруктураОбъекта,
	                           "ПометкаУдаления",
	                           ,
	                           СписокСвойств,
	                           ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект,
	                           СтруктураОбъекта,
	                           "Проведен",
	                           ,
	                           СписокСвойств,
	                           ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект,
	                           СтруктураОбъекта,
	                           "Дата",
	                           ,
	                           СписокСвойств,
	                           ИсключаяСвойства);

	// TODO: Тут еще нужно проверить использование нумератора
	Если МетаОбъект.ДлинаНомера > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "Номер",
		                           ,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЕсли;

	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           ТекРеквизит.Имя,
		                           ПолучатьБитыеСсылки,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЦикла;

	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаИзСтруктуры(Объект,
		                     СтруктураОбъекта,
		                     ТекТЧ.Имя,
		                     ПолучатьБитыеСсылки,
		                     СписокСвойств,
		                     ИсключаяСвойства);
	КонецЦикла;

	Если ИспользоватьСвойство("Движения", СписокСвойств, ИсключаяСвойства) И СтруктураОбъекта.Свойство("Движения") Тогда
		ДвиженияДокументаИзСтруктуры(Объект,
		                             СтруктураОбъекта.Движения,
		                             ПолучатьБитыеСсылки,
		                             СписокСвойств,
		                             ИсключаяСвойства);
	КонецЕсли;

КонецПроцедуры // ДокументИзСтруктуры()

// Преобразует бизнес-процесс в структуру
//
// Параметры:
//  Объект              - Объект, ЛюбаяСсылка       - Преобразуемый объект
//  СписокСвойств       - Строка, Массив(Строка)    - Список допустимых свойств
//                                                    (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)    - Список исключаемых свойств
//                                                    (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура                                       - результат преобразования
//     *Ссылка                        - Структура      - Описание ссылки на объект
//        **Тип                         - Строка         - Текстовое описание типа объекта
//        **Ид                          - Строка         - Уникальный идентификатор ссылки
//        **ИдПолный                    - Строка         - Преставление ссылки на объект,
//                                                         полученное функцией ЗначениеВСтрокуВнутр
//        **Предопределенный            - Булево         - Истина - предопределенное значение; Ложь - в противном случае
//        **ИмяПредопределенныхДанных   - Строка         - Имя предопределенного значения
//        **Представление               - Строка         - Стандатрное строковое представление объекта
//        **<имя поля>                  - Произвольный   - Дополнительные поля добавленные при выгрузке
//     *__ТЧ                          - Массив         - Массив табличных частей объекта
//     *<имя поля>                    - Произвольный   - Значения реквизитов объекта
//
Функция БизнесПроцессВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт

	СтруктураОбъекта = Новый Структура();

	МетаОбъект = Объект.Метаданные();

	Если НЕ ТипЗнч(Объект) = Тип(СтрШаблонВнутр("БизнесПроцессОбъект.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("БизнесПроцессОбъект.%1", МетаОбъект.Имя));

	Если Объект.Ссылка.Пустая() Тогда
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.ПолучитьСсылкуНового()));
	Иначе
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.Ссылка));
	КонецЕсли;

	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Дата", СписокСвойств, ИсключаяСвойства);

	СтруктураОбъекта.Вставить("Номер", Неопределено);
	Если МетаОбъект.ДлинаНомера > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Номер", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;

	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Стартован", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Завершен", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ВедущаяЗадача", СписокСвойств, ИсключаяСвойства);

	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;

	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;

	Возврат СтруктураОбъекта;

КонецФункции // БизнесПроцессВСтруктуру()

// Заполняет бизнес-процесс из структуры
//
// Параметры:
//  Объект               - Объект                    - Заполняемый объект
//  СтруктураОбъекта     - Структура                 - Данные для заполнения объекта
//     *Ссылка                        - Структура      - Описание ссылки на объект
//        **Тип                         - Строка         - Текстовое описание типа объекта
//        **Ид                          - Строка         - Уникальный идентификатор ссылки
//        **ИдПолный                    - Строка         - Преставление ссылки на объект,
//                                                         полученное функцией ЗначениеВСтрокуВнутр
//        **Предопределенный            - Булево         - Истина - предопределенное значение; Ложь - в противном случае
//        **ИмяПредопределенныхДанных   - Строка         - Имя предопределенного значения
//        **Представление               - Строка         - Стандатрное строковое представление объекта
//        **<имя поля>                  - Произвольный   - Дополнительные поля добавленные при выгрузке
//     *__ТЧ                          - Массив         - Массив табличных частей объекта
//     *<имя поля>                    - Произвольный   - Значения реквизитов объекта
//  ПолучатьБитыеСсылки  - Булево                   - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//  СписокСвойств        - Строка                   - Список допустимых свойств
//                         Массив из Строка           (если пустой, то допустимы все свойства)
//  ИсключаяСвойства     - Строка                   - Список исключаемых свойств
//                         Массив из Строка           (если пустой, то допустимы все свойства)
//
Процедура БизнесПроцессИзСтруктуры(Объект,
                                   СтруктураОбъекта,
                                   ПолучатьБитыеСсылки = Ложь,
                                   СписокСвойств = Неопределено,
                                   ИсключаяСвойства = Неопределено) Экспорт

	МетаОбъект = Объект.Метаданные();

	СвойствоОбъектаИзСтруктуры(Объект,
	                           СтруктураОбъекта,
	                           "ПометкаУдаления",
	                           ,
	                           СписокСвойств,
	                           ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект,
	                           СтруктураОбъекта,
	                           "Дата",
	                           ,
	                           СписокСвойств,
	                           ИсключаяСвойства);

	Если МетаОбъект.ДлинаНомера > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "Номер",
		                           ,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЕсли;

	СвойствоОбъектаИзСтруктуры(Объект,
	                           СтруктураОбъекта,
	                           "Стартован",
	                           ,
	                           СписокСвойств,
	                           ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект,
	                           СтруктураОбъекта,
	                           "Завершен",
	                           ,
	                           СписокСвойств,
	                           ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект,
	                           СтруктураОбъекта,
	                           "ВедущаяЗадача",
	                           ПолучатьБитыеСсылки,
	                           СписокСвойств,
	                           ИсключаяСвойства);

	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           ТекРеквизит.Имя,
		                           ПолучатьБитыеСсылки,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЦикла;

	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаИзСтруктуры(Объект,
		                     СтруктураОбъекта,
		                     ТекТЧ.Имя,
		                     ПолучатьБитыеСсылки,
		                     СписокСвойств,
		                     ИсключаяСвойства);
	КонецЦикла;

КонецПроцедуры // БизнесПроцессИзСтруктуры()

// Преобразует задачу в структуру
//
// Параметры:
//  Объект              - Объект, ЛюбаяСсылка       - Преобразуемый объект
//  СписокСвойств       - Строка, Массив(Строка)    - Список допустимых свойств
//                                                    (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)    - Список исключаемых свойств
//                                                    (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура                                       - результат преобразования
//     *Ссылка                        - Структура      - Описание ссылки на объект
//        **Тип                         - Строка         - Текстовое описание типа объекта
//        **Ид                          - Строка         - Уникальный идентификатор ссылки
//        **ИдПолный                    - Строка         - Преставление ссылки на объект,
//                                                         полученное функцией ЗначениеВСтрокуВнутр
//        **Предопределенный            - Булево         - Истина - предопределенное значение; Ложь - в противном случае
//        **ИмяПредопределенныхДанных   - Строка         - Имя предопределенного значения
//        **Представление               - Строка         - Стандатрное строковое представление объекта
//        **<имя поля>                  - Произвольный   - Дополнительные поля добавленные при выгрузке
//     *__ТЧ                          - Массив         - Массив табличных частей объекта
//     *<имя поля>                    - Произвольный   - Значения реквизитов объекта
//
Функция ЗадачаВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт

	СтруктураОбъекта = Новый Структура();

	МетаОбъект = Объект.Метаданные();

	Если НЕ ТипЗнч(Объект) = Тип(СтрШаблонВнутр("ЗадачаОбъект.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("ЗадачаОбъект.%1", МетаОбъект.Имя));

	Если Объект.Ссылка.Пустая() Тогда
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.ПолучитьСсылкуНового()));
	Иначе
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.Ссылка));
	КонецЕсли;

	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Дата", СписокСвойств, ИсключаяСвойства);

	СтруктураОбъекта.Вставить("Номер", Неопределено);
	Если МетаОбъект.ДлинаНомера > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Номер", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;

	СтруктураОбъекта.Вставить("Наименование", Неопределено);
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;

	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "БизнесПроцесс", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Выполнена", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ТочкаМаршрута", СписокСвойств, ИсключаяСвойства);

	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;

	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;

	Возврат СтруктураОбъекта;

КонецФункции // ЗадачаВСтруктуру()

// Заполняет задачу из структуры
//
// Параметры:
//  Объект               - Объект                    - Заполняемый объект
//  СтруктураОбъекта     - Структура                 - Данные для заполнения объекта
//     *Ссылка                        - Структура      - Описание ссылки на объект
//        **Тип                         - Строка         - Текстовое описание типа объекта
//        **Ид                          - Строка         - Уникальный идентификатор ссылки
//        **ИдПолный                    - Строка         - Преставление ссылки на объект,
//                                                         полученное функцией ЗначениеВСтрокуВнутр
//        **Предопределенный            - Булево         - Истина - предопределенное значение; Ложь - в противном случае
//        **ИмяПредопределенныхДанных   - Строка         - Имя предопределенного значения
//        **Представление               - Строка         - Стандатрное строковое представление объекта
//        **<имя поля>                  - Произвольный   - Дополнительные поля добавленные при выгрузке
//     *__ТЧ                          - Массив         - Массив табличных частей объекта
//     *<имя поля>                    - Произвольный   - Значения реквизитов объекта
//  ПолучатьБитыеСсылки  - Булево                   - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//  СписокСвойств       - Строка, Массив(Строка)    - Список допустимых свойств
//                                                    (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)    - Список исключаемых свойств
//                                                    (если пустой, то допустимы все свойства)
//
Процедура ЗадачаИзСтруктуры(Объект,
                            СтруктураОбъекта,
                            ПолучатьБитыеСсылки = Ложь,
                            СписокСвойств = Неопределено,
                            ИсключаяСвойства = Неопределено) Экспорт

	МетаОбъект = Объект.Метаданные();

	СвойствоОбъектаИзСтруктуры(Объект,
	                           СтруктураОбъекта,
	                           "ПометкаУдаления",
	                           ,
	                           СписокСвойств,
	                           ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект,
	                           СтруктураОбъекта,
	                           "Дата",
	                           СписокСвойств,
	                           ИсключаяСвойства);

	Если МетаОбъект.ДлинаНомера > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "Номер",
		                           ,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЕсли;

	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           "Наименование",
		                           ,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЕсли;

	СвойствоОбъектаИзСтруктуры(Объект,
	                           СтруктураОбъекта,
	                           "БизнесПроцесс",
	                           ПолучатьБитыеСсылки,
	                           СписокСвойств,
	                           ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект,
	                           СтруктураОбъекта,
	                           "Выполнена",
	                           ,
	                           СписокСвойств,
	                           ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект,
	                           СтруктураОбъекта,
	                           "ТочкаМаршрута",
	                           ПолучатьБитыеСсылки,
	                           СписокСвойств,
	                           ИсключаяСвойства);

	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаИзСтруктуры(Объект,
		                           СтруктураОбъекта,
		                           ТекРеквизит.Имя,
		                           ПолучатьБитыеСсылки,
		                           СписокСвойств,
		                           ИсключаяСвойства);
	КонецЦикла;

	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаИзСтруктуры(Объект,
		                     СтруктураОбъекта,
		                     ТекТЧ.Имя,
		                     ПолучатьБитыеСсылки,
		                     СписокСвойств,
		                     ИсключаяСвойства);
	КонецЦикла;

КонецПроцедуры // ЗадачаИзСтруктуры()

// Преобразует набор записей регистра сведений в структуру
//
// Параметры:
//  НаборЗаписей        - РегистрСведенийНаборЗаписей    - набор записей регистра сведений для преобразования
//  СписокСвойств       - Строка, Массив(Строка)         - Список допустимых свойств
//                                                         (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)         - Список исключаемых свойств
//                                                         (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура                              - результат преобразования
//     *Отбор          - Структура            - Описание отбора записей регистра
//        **<имя поля>   - Произвольный         - Значение отбора
//     *Записи         - Массив(Структура)    - Массив записей регистра
//        **<имя поля>   - Произвольный         - Значения измерений, ресурсов и реквизитов записи регистра
//
Функция НаборЗаписейРегистраСведенийВСтруктуру(НаборЗаписей,
                                               СписокСвойств = Неопределено,
                                               ИсключаяСвойства = Неопределено) Экспорт

	СтруктураОбъекта = Новый Структура();

	МетаОбъект = НаборЗаписей.Метаданные();

	Если НЕ ТипЗнч(НаборЗаписей) = Тип(СтрШаблонВнутр("РегистрСведенийНаборЗаписей.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("РегистрСведенийНаборЗаписей.%1", МетаОбъект.Имя));

	СтруктураОбъекта.Вставить("Отбор", Новый Структура());

	Если МетаОбъект.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
		СтруктураОбъекта.Отбор.Вставить("Регистратор", ЗначениеВСтруктуру(НаборЗаписей.Отбор.Регистратор.Значение));
	Иначе
		Если НЕ МетаОбъект.ПериодичностьРегистраСведений =
				Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
			СтруктураОбъекта.Отбор.Вставить("Период", НаборЗаписей.Отбор.Период.Значение);
		КонецЕсли;

		Для Каждого ТекЭлемент Из НаборЗаписей.Отбор Цикл
			Если НЕ ИспользоватьСвойство(ТекЭлемент.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураОбъекта.Отбор.Вставить(ТекЭлемент.Имя, ЗначениеВСтруктуру(ТекЭлемент.Значение));
		КонецЦикла;
	КонецЕсли;

	МассивСтрок = Новый Массив();

	НомерСтроки = 1;

	//@skip-warning
	Для Каждого ТекСтрока Из НаборЗаписей Цикл

		СтруктураСтроки = Новый Структура();

		Если МетаОбъект.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
			СтруктураСтроки.Вставить("Регистратор", ЗначениеВСтруктуру(ТекСтрока.Регистратор));
			Если ИспользоватьСвойство("НомерСтроки", СписокСвойств, ИсключаяСвойства) Тогда
				СтруктураСтроки.Вставить("НомерСтроки",
				                         ?(ТекСтрока.НомерСтроки = 0, НомерСтроки, ТекСтрока.НомерСтроки));
			КонецЕсли;
			СтруктураСтроки.Вставить("Активность", ТекСтрока.Активность);
		КонецЕсли;

		Если НЕ МетаОбъект.ПериодичностьРегистраСведений =
				Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
			СтруктураСтроки.Вставить("Период", ТекСтрока.Период);
		КонецЕсли;

		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;

		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;

		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;

		МассивСтрок.Добавить(СтруктураСтроки);

		НомерСтроки = НомерСтроки + 1;
	КонецЦикла;

	СтруктураОбъекта.Вставить("Записи", МассивСтрок);

	Возврат СтруктураОбъекта;

КонецФункции // НаборЗаписейРегистраСведенийВСтруктуру()

// Заполняет набор записей регистра сведений из структуры
//
// Параметры:
//  НаборЗаписей         - РегистрСведенийНаборЗаписей   - Набор записей регистра для заполнения
//  СтруктураОбъекта     - Структура                     - Данные для заполнения объекта
//     *Отбор              - Структура                     - Описание отбора записей регистра
//        **<имя поля>       - Произвольный                  - Значение отбора
//     *Записи             - Массив(Структура)             - Массив записей регистра
//        **<имя поля>       - Произвольный                  - Значения измерений, ресурсов и реквизитов записи регистра
//  ПолучатьБитыеСсылки  - Булево                        - Истина - если объект по ссылке не существует,
//                                                         будет возвращена битая ссылка;
//                                                         Ложь - будет возвращена пустая ссылка
//  СписокСвойств        - Строка                        - Список допустимых свойств
//                         Массив из Строка                (если пустой, то допустимы все свойства)
//  ИсключаяСвойства     - Строка                        - Список исключаемых свойств
//                         Массив из Строка                (если пустой, то допустимы все свойства)
//
Процедура НаборЗаписейРегистраСведенийИзСтруктуры(НаборЗаписей,
                                                  СтруктураОбъекта,
                                                  ПолучатьБитыеСсылки = Ложь,
                                                  СписокСвойств = Неопределено,
                                                  ИсключаяСвойства = Неопределено) Экспорт

	МетаОбъект = НаборЗаписей.Метаданные();

	Если МетаОбъект.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
		НаборЗаписей.Отбор.Регистратор.Установить(ЗначениеИзСтруктуры(СтруктураОбъекта.Отбор.Регистратор,
		                                                              ПолучатьБитыеСсылки));
	Иначе
		Если НЕ МетаОбъект.ПериодичностьРегистраСведений =
				Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
			НаборЗаписей.Отбор.Период.Установить(ЗначениеИзСтруктуры(СтруктураОбъекта.Отбор.Период,
			                                                         ПолучатьБитыеСсылки));
		КонецЕсли;

		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ (СтруктураОбъекта.Отбор.Свойство(ТекПоле.Имя)
			   И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НаборЗаписей.Отбор[ТекПоле.Имя].Установить(ЗначениеИзСтруктуры(СтруктураОбъекта.Отбор[ТекПоле.Имя],
			                                                               ПолучатьБитыеСсылки));
		КонецЦикла;
	КонецЕсли;

	НаборЗаписей.Очистить();

	Для Каждого ТекЗапись Из СтруктураОбъекта.Записи Цикл

		НоваяЗапись = НаборЗаписей.Добавить();

		Если МетаОбъект.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
			НоваяЗапись.Регистратор = ЗначениеИзСтруктуры(ТекЗапись.Регистратор, ПолучатьБитыеСсылки);
			НоваяЗапись.Активность = ЗначениеИзСтруктуры(ТекЗапись.Активность);
		КонецЕсли;

		Если НЕ МетаОбъект.ПериодичностьРегистраСведений =
				Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
			НоваяЗапись.Период = ЗначениеИзСтруктуры(ТекЗапись.Период);
		КонецЕсли;

		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя], ПолучатьБитыеСсылки);
		КонецЦикла;

		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя], ПолучатьБитыеСсылки);
		КонецЦикла;

		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя], ПолучатьБитыеСсылки);
		КонецЦикла;
	КонецЦикла;

КонецПроцедуры // НаборЗаписейРегистраСведенийИзСтруктуры()

// Преобразует набор записей регистра накопления в структуру
//
// Параметры:
//  НаборЗаписей        - РегистрНакопленияНаборЗаписей    - набор записей регистра накопления для преобразования
//  СписокСвойств       - Строка, Массив(Строка)           - Список допустимых свойств
//                                                           (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)           - Список исключаемых свойств
//                                                           (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура                              - результат преобразования
//     *Отбор          - Структура            - Описание отбора записей регистра
//        **<имя поля>   - Произвольный         - Значение отбора
//     *Записи         - Массив(Структура)    - Массив записей регистра
//        **<имя поля>   - Произвольный         - Значения измерений, ресурсов и реквизитов записи регистра
//
Функция НаборЗаписейРегистраНакопленияВСтруктуру(НаборЗаписей,
                                                 СписокСвойств = Неопределено,
                                                 ИсключаяСвойства = Неопределено) Экспорт

	СтруктураОбъекта = Новый Структура();

	МетаОбъект = НаборЗаписей.Метаданные();

	Если НЕ ТипЗнч(НаборЗаписей) = Тип(СтрШаблонВнутр("РегистрНакопленияНаборЗаписей.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("РегистрНакопленияНаборЗаписей.%1", МетаОбъект.Имя));

	СтруктураОбъекта.Вставить("Отбор", Новый Структура());

	СтруктураОбъекта.Отбор.Вставить("Регистратор", ЗначениеВСтруктуру(НаборЗаписей.Отбор.Регистратор.Значение));

	МассивСтрок = Новый Массив();

	НомерСтроки = 1;

	//@skip-warning
	Для Каждого ТекСтрока Из НаборЗаписей Цикл

		СтруктураСтроки = Новый Структура();

		СтруктураСтроки.Вставить("Регистратор", ЗначениеВСтруктуру(ТекСтрока.Регистратор));

		Если ИспользоватьСвойство("НомерСтроки", СписокСвойств, ИсключаяСвойства) Тогда
			СтруктураСтроки.Вставить("НомерСтроки", ?(ТекСтрока.НомерСтроки = 0, НомерСтроки, ТекСтрока.НомерСтроки));
		КонецЕсли;

		СтруктураСтроки.Вставить("Активность", ТекСтрока.Активность);

		Если МетаОбъект.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
			СтруктураСтроки.Вставить("ВидДвижения",
			                         ?(ТекСтрока.ВидДвижения = ВидДвиженияНакопления.Приход, "Приход", "Расход"));
		КонецЕсли;

		СтруктураСтроки.Вставить("Период", ТекСтрока.Период);

		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;

		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;

		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;

		МассивСтрок.Добавить(СтруктураСтроки);

		НомерСтроки = НомерСтроки + 1;
	КонецЦикла;

	СтруктураОбъекта.Вставить("Записи", МассивСтрок);

	Возврат СтруктураОбъекта;

КонецФункции // НаборЗаписейРегистраНакопленияВСтруктуру()

// Заполняет набор записей регистра накопления из структуры
//
// Параметры:
//  НаборЗаписей         - РегистрСведенийНаборЗаписей   - Набор записей регистра для заполнения
//  СтруктураОбъекта     - Структура                     - Данные для заполнения объекта
//     *Отбор              - Структура                     - Описание отбора записей регистра
//        **<имя поля>       - Произвольный                  - Значение отбора
//     *Записи             - Массив(Структура)             - Массив записей регистра
//        **<имя поля>       - Произвольный                  - Значения измерений, ресурсов и реквизитов записи регистра
//  ПолучатьБитыеСсылки  - Булево                        - Истина - если объект по ссылке не существует,
//                                                         будет возвращена битая ссылка;
//                                                         Ложь - будет возвращена пустая ссылка
//  СписокСвойств        - Строка, Массив(Строка)        - Список допустимых свойств
//                                                         (если пустой, то допустимы все свойства)
//  ИсключаяСвойства     - Строка, Массив(Строка)        - Список исключаемых свойств
//                                                         (если пустой, то допустимы все свойства)
//
Процедура НаборЗаписейРегистраНакопленияИзСтруктуры(НаборЗаписей,
                                                    СтруктураОбъекта,
                                                    ПолучатьБитыеСсылки = Ложь,
                                                    СписокСвойств = Неопределено,
                                                    ИсключаяСвойства = Неопределено) Экспорт

	МетаОбъект = НаборЗаписей.Метаданные();

	НаборЗаписей.Отбор.Регистратор.Установить(ЗначениеИзСтруктуры(СтруктураОбъекта.Отбор.Регистратор,
	                                                              ПолучатьБитыеСсылки));

	НаборЗаписей.Очистить();

	Для Каждого ТекЗапись Из СтруктураОбъекта.Записи Цикл

		НоваяЗапись = НаборЗаписей.Добавить();

		НоваяЗапись.Регистратор = ЗначениеИзСтруктуры(ТекЗапись.Регистратор, ПолучатьБитыеСсылки);

		НоваяЗапись.Активность = ЗначениеИзСтруктуры(ТекЗапись.Активность);

		Если МетаОбъект.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
			НоваяЗапись.ВидДвижения = Вычислить("ВидДвиженияНакопления." + ТекЗапись.ВидДвижения);
		КонецЕсли;

		НоваяЗапись.Период = ЗначениеИзСтруктуры(ТекЗапись.Период);

		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя)
			   И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя], ПолучатьБитыеСсылки);
		КонецЦикла;

		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя)
			   И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя]);
		КонецЦикла;

		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя)
			   И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя], ПолучатьБитыеСсылки);
		КонецЦикла;
	КонецЦикла;

КонецПроцедуры // НаборЗаписейРегистраНакопленияИзСтруктуры()

// Преобразует набор записей регистра бухгалтерии в структуру
//
// Параметры:
//  НаборЗаписей        - РегистрБухгалтерииНаборЗаписей    - набор записей регистра бухгалтерии для преобразования
//  СписокСвойств       - Строка, Массив(Строка)            - Список допустимых свойств
//                                                            (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)            - Список исключаемых свойств
//                                                            (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура                              - результат преобразования
//     *Отбор          - Структура            - Описание отбора записей регистра
//        **<имя поля>   - Произвольный         - Значение отбора
//     *Записи         - Массив(Структура)    - Массив записей регистра
//        **<имя поля>   - Произвольный         - Значения измерений, ресурсов и реквизитов записи регистра
//
Функция НаборЗаписейРегистраБухгалтерииВСтруктуру(НаборЗаписей,
                                                  СписокСвойств = Неопределено,
                                                  ИсключаяСвойства = Неопределено) Экспорт

	СтруктураОбъекта = Новый Структура();

	МетаОбъект = НаборЗаписей.Метаданные();

	Если НЕ ТипЗнч(НаборЗаписей) = Тип(СтрШаблонВнутр("РегистрБухгалтерииНаборЗаписей.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("РегистрБухгалтерииНаборЗаписей.%1", МетаОбъект.Имя));

	СтруктураОбъекта.Вставить("Отбор", Новый Структура());

	СтруктураОбъекта.Отбор.Вставить("Регистратор", ЗначениеВСтруктуру(НаборЗаписей.Отбор.Регистратор.Значение));

	МассивСтрок = Новый Массив();

	НомерСтроки = 1;

	//@skip-warning
	Для Каждого ТекСтрока Из НаборЗаписей Цикл

		СтруктураСтроки = Новый Структура();

		СтруктураСтроки.Вставить("Регистратор", ЗначениеВСтруктуру(ТекСтрока.Регистратор));

		Если ИспользоватьСвойство("НомерСтроки", СписокСвойств, ИсключаяСвойства) Тогда
			СтруктураСтроки.Вставить("НомерСтроки", ?(ТекСтрока.НомерСтроки = 0, НомерСтроки, ТекСтрока.НомерСтроки));
		КонецЕсли;

		СтруктураСтроки.Вставить("Активность", ТекСтрока.Активность);

		СтруктураСтроки.Вставить("Период", ТекСтрока.Период);

		Если МетаОбъект.ДлинаУточненияПериода > 0
		   И ИспользоватьСвойство("УточнениеПериода", СписокСвойств, ИсключаяСвойства) Тогда
			СтруктураСтроки.Вставить("УточнениеПериода", ТекСтрока.УточнениеПериода);
		КонецЕсли;

		Если МетаОбъект.Корреспонденция Тогда
			СтруктураСтроки.Вставить("СчетДт", ЗначениеВСтруктуру(ТекСтрока.СчетДт));
			СтруктураСтроки.Вставить("СчетКт", ЗначениеВСтруктуру(ТекСтрока.СчетКт));

			СтруктураСтроки.Вставить("СубконтоДт",
			                         ЗначенияСубконтоЗаписиВСтруктуру(ТекСтрока, "Дт", СписокСвойств, ИсключаяСвойства));
			СтруктураСтроки.Вставить("СубконтоКт",
			                         ЗначенияСубконтоЗаписиВСтруктуру(ТекСтрока, "Кт", СписокСвойств, ИсключаяСвойства));
		Иначе
			СтруктураСтроки.Вставить("ВидДвижения",
			                         ?(ТекСтрока.ВидДвижения = ВидДвиженияБухгалтерии.Дебет, "Дебет", "Кредит"));

			СтруктураСтроки.Вставить("Счет", ЗначениеВСтруктуру(ТекСтрока.Счет));

			СтруктураСтроки.Вставить("Субконто",
			                         ЗначенияСубконтоЗаписиВСтруктуру(ТекСтрока, "", СписокСвойств, ИсключаяСвойства));
		КонецЕсли;

		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			Если МетаОбъект.Корреспонденция И НЕ ТекПоле.Балансовый Тогда
				СтруктураСтроки.Вставить(ТекПоле.Имя + "Дт", ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя + "Дт"]));
				СтруктураСтроки.Вставить(ТекПоле.Имя + "Кт", ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя + "Кт"]));
			Иначе
				СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
			КонецЕсли;
		КонецЦикла;

		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			Если МетаОбъект.Корреспонденция И НЕ ТекПоле.Балансовый Тогда
				СтруктураСтроки.Вставить(ТекПоле.Имя + "Дт", ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя + "Дт"]));
				СтруктураСтроки.Вставить(ТекПоле.Имя + "Кт", ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя + "Кт"]));
			Иначе
				СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
			КонецЕсли;
		КонецЦикла;

		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;

		МассивСтрок.Добавить(СтруктураСтроки);

		НомерСтроки = НомерСтроки + 1;
	КонецЦикла;

	СтруктураОбъекта.Вставить("Записи", МассивСтрок);

	Возврат СтруктураОбъекта;

КонецФункции // НаборЗаписейРегистраБухгалтерииВСтруктуру()

// Заполняет набор записей регистра бухгалтерии из структуры
//
// Параметры:
//  НаборЗаписей         - РегистрСведенийНаборЗаписей   - Набор записей регистра для заполнения
//  СтруктураОбъекта     - Структура                     - Данные для заполнения объекта
//     *Отбор              - Структура                     - Описание отбора записей регистра
//        **<имя поля>       - Произвольный                  - Значение отбора
//     *Записи             - Массив(Структура)             - Массив записей регистра
//        **<имя поля>       - Произвольный                  - Значения измерений, ресурсов и реквизитов записи регистра
//  ПолучатьБитыеСсылки  - Булево                        - Истина - если объект по ссылке не существует,
//                                                         будет возвращена битая ссылка;
//                                                         Ложь - будет возвращена пустая ссылка
//  СписокСвойств        - Строка, Массив(Строка)        - Список допустимых свойств
//                                                         (если пустой, то допустимы все свойства)
//  ИсключаяСвойства     - Строка, Массив(Строка)        - Список исключаемых свойств
//                                                         (если пустой, то допустимы все свойства)
//
Процедура НаборЗаписейРегистраБухгалтерииИзСтруктуры(НаборЗаписей,
                                                     СтруктураОбъекта,
                                                     ПолучатьБитыеСсылки = Ложь,
                                                     СписокСвойств = Неопределено,
                                                     ИсключаяСвойства = Неопределено) Экспорт

	МетаОбъект = НаборЗаписей.Метаданные();

	НаборЗаписей.Отбор.Регистратор.Установить(ЗначениеИзСтруктуры(СтруктураОбъекта.Отбор.Регистратор));

	НаборЗаписей.Очистить();

	Для Каждого ТекЗапись Из СтруктураОбъекта.Записи Цикл

		НоваяЗапись = НаборЗаписей.Добавить();

		НоваяЗапись.Регистратор = ЗначениеИзСтруктуры(ТекЗапись.Регистратор, ПолучатьБитыеСсылки);
		НоваяЗапись.Активность  = ЗначениеИзСтруктуры(ТекЗапись.Активность);
		НоваяЗапись.Период      = ЗначениеИзСтруктуры(ТекЗапись.Период);

		Если МетаОбъект.ДлинаУточненияПериода > 0
		   И ИспользоватьСвойство("УточнениеПериода", СписокСвойств, ИсключаяСвойства) Тогда
			НоваяЗапись.УточнениеПериода = ЗначениеИзСтруктуры(ТекЗапись.УточнениеПериода);
		КонецЕсли;

		Если МетаОбъект.Корреспонденция Тогда
			НоваяЗапись.СчетДт = ЗначениеИзСтруктуры(ТекЗапись.СчетДт, ПолучатьБитыеСсылки);
			НоваяЗапись.СчетКт = ЗначениеИзСтруктуры(ТекЗапись.СчетКт, ПолучатьБитыеСсылки);

			ЗначенияСубконтоЗаписиИзСтруктуры(НоваяЗапись,
			                                  ТекЗапись,
			                                  "Дт",
			                                  ПолучатьБитыеСсылки,
			                                  СписокСвойств,
			                                  ИсключаяСвойства);
			ЗначенияСубконтоЗаписиИзСтруктуры(НоваяЗапись,
			                                  ТекЗапись,
			                                  "Кт",
			                                  ПолучатьБитыеСсылки,
			                                  СписокСвойств,
			                                  ИсключаяСвойства);
		Иначе
			НоваяЗапись.ВидДвижения = Вычислить("ВидДвиженияБухгалтерии." + ТекЗапись.ВидДвижения);
			НоваяЗапись.Счет        = ЗначениеИзСтруктуры(ТекЗапись.Счет, ПолучатьБитыеСсылки);

			ЗначенияСубконтоЗаписиИзСтруктуры(НоваяЗапись,
			                                  ТекЗапись,
			                                  "",
			                                  ПолучатьБитыеСсылки,
			                                  СписокСвойств,
			                                  ИсключаяСвойства);
		КонецЕсли;

		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если МетаОбъект.Корреспонденция И НЕ ТекПоле.Балансовый Тогда
				ЗаполнитьИзмерениеРегистраБухгалтерии(НоваяЗапись, ТекЗапись, ТекПоле, "Дт",
				                                      ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
				ЗаполнитьИзмерениеРегистраБухгалтерии(НоваяЗапись, ТекЗапись, ТекПоле, "Кт",
				                                      ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
			Иначе
				ЗаполнитьИзмерениеРегистраБухгалтерии(НоваяЗапись, ТекЗапись, ТекПоле, "",
				                                      ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
			КонецЕсли;
		КонецЦикла;

		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если МетаОбъект.Корреспонденция И НЕ ТекПоле.Балансовый Тогда
				ЗаполнитьРесурсРегистраБухгалтерии(НоваяЗапись, ТекЗапись, ТекПоле, "Дт",
				                                   СписокСвойств, ИсключаяСвойства);
				ЗаполнитьРесурсРегистраБухгалтерии(НоваяЗапись, ТекЗапись, ТекПоле, "Кт",
				                                   СписокСвойств, ИсключаяСвойства);
			Иначе
				ЗаполнитьРесурсРегистраБухгалтерии(НоваяЗапись, ТекЗапись, ТекПоле, "",
				                                   СписокСвойств, ИсключаяСвойства);
			КонецЕсли;
		КонецЦикла;

		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя)
					И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя], ПолучатьБитыеСсылки);
		КонецЦикла;
	КонецЦикла;

КонецПроцедуры // НаборЗаписейРегистраБухгалтерииИзСтруктуры()

// Преобразует набор записей регистра расчета в структуру
//
// Параметры:
//  НаборЗаписей        - РегистрРасчетаНаборЗаписей    - набор записей регистра расчета для преобразования
//  СписокСвойств       - Строка, Массив(Строка)        - Список допустимых свойств
//                                                        (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)        - Список исключаемых свойств
//                                                        (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура                              - результат преобразования
//     *Отбор          - Структура            - Описание отбора записей регистра
//        **<имя поля>   - Произвольный         - Значение отбора
//     *Записи         - Массив(Структура)    - Массив записей регистра
//        **<имя поля>   - Произвольный         - Значения измерений, ресурсов и реквизитов записи регистра
//
Функция НаборЗаписейРегистраРасчетаВСтруктуру(НаборЗаписей,
                                              СписокСвойств = Неопределено,
                                              ИсключаяСвойства = Неопределено) Экспорт

	СтруктураОбъекта = Новый Структура();

	МетаОбъект = НаборЗаписей.Метаданные();

	Если НЕ ТипЗнч(НаборЗаписей) = Тип(СтрШаблонВнутр("РегистрРасчетаНаборЗаписей.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("РегистрРасчетаНаборЗаписей.%1", МетаОбъект.Имя));

	СтруктураОбъекта.Вставить("Отбор", Новый Структура());

	СтруктураОбъекта.Отбор.Вставить("Регистратор", ЗначениеВСтруктуру(НаборЗаписей.Отбор.Регистратор.Значение));

	Для Каждого ТекЭлемент Из НаборЗаписей.Отбор Цикл
		Если НЕ ИспользоватьСвойство(ТекЭлемент.Имя, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		СтруктураОбъекта.Отбор.Вставить(ТекЭлемент.Имя, ЗначениеВСтруктуру(ТекЭлемент.Значение));
	КонецЦикла;

	МассивСтрок = Новый Массив();

	НомерСтроки = 1;

	//@skip-warning
	Для Каждого ТекСтрока Из НаборЗаписей Цикл

		СтруктураСтроки = Новый Структура();

		СтруктураСтроки.Вставить("Регистратор", ЗначениеВСтруктуру(ТекСтрока.Регистратор));

		Если ИспользоватьСвойство("НомерСтроки", СписокСвойств, ИсключаяСвойства) Тогда
			СтруктураСтроки.Вставить("НомерСтроки", ?(ТекСтрока.НомерСтроки = 0, НомерСтроки, ТекСтрока.НомерСтроки));
		КонецЕсли;

		СтруктураСтроки.Вставить("Активность"       , ТекСтрока.Активность);
		СтруктураСтроки.Вставить("ВидРасчета"       , ЗначениеВСтруктуру(ТекСтрока.ВидРасчета));
		СтруктураСтроки.Вставить("Сторно"           , ТекСтрока.Сторно);
		СтруктураСтроки.Вставить("ПериодРегистрации", ТекСтрока.ПериодРегистрации);

		Если МетаОбъект.БазовыйПериод Тогда
			СтруктураСтроки.Вставить("БазовыйПериодНачало", ТекСтрока.БазовыйПериодНачало);
			СтруктураСтроки.Вставить("БазовыйПериодКонец" , ТекСтрока.БазовыйПериодКонец);
		КонецЕсли;

		Если МетаОбъект.ПериодДействия Тогда
			СтруктураСтроки.Вставить("ПериодДействия"      , ТекСтрока.ПериодДействия);
			СтруктураСтроки.Вставить("ПериодДействияНачало", ТекСтрока.ПериодДействияНачало);
			СтруктураСтроки.Вставить("ПериодДействияКонец" , ТекСтрока.ПериодДействияКонец);

			МассивПериодов = Новый Массив();

			Для Каждого ТекПериод Из ТекСтрока.ФактическийПериодДействия Цикл
				МассивПериодов.Добавить(Новый Структура("ДатаНачала, ДатаОкончания",
				                                        ТекПериод.ДатаНачала, ТекПериод.ДатаОкончания));
			КонецЦикла;
			СтруктураСтроки.Вставить("ФактическийПериодДействия", МассивПериодов);
		КонецЕсли;

		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;

		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;

		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;

		МассивСтрок.Добавить(СтруктураСтроки);

		НомерСтроки = НомерСтроки + 1;
	КонецЦикла;

	СтруктураОбъекта.Вставить("Записи", МассивСтрок);

	Возврат СтруктураОбъекта;

КонецФункции // НаборЗаписейРегистраРасчетаВСтруктуру()

// Заполняет набор записей регистра расчета из структуры
//
// Параметры:
//  НаборЗаписей         - РегистрСведенийНаборЗаписей   - Набор записей регистра для заполнения
//  СтруктураОбъекта     - Структура                     - Данные для заполнения объекта
//     *Отбор              - Структура                     - Описание отбора записей регистра
//        **<имя поля>       - Произвольный                  - Значение отбора
//     *Записи             - Массив(Структура)             - Массив записей регистра
//        **<имя поля>       - Произвольный                  - Значения измерений, ресурсов и реквизитов записи регистра
//  ПолучатьБитыеСсылки  - Булево                        - Истина - если объект по ссылке не существует,
//                                                         будет возвращена битая ссылка;
//                                                         Ложь - будет возвращена пустая ссылка
//  СписокСвойств        - Строка                        - Список допустимых свойств
//                         Массив из Строка                (если пустой, то допустимы все свойства)
//  ИсключаяСвойства     - Строка                        - Список исключаемых свойств
//                         Массив из Строка                (если пустой, то допустимы все свойства)
//
Процедура НаборЗаписейРегистраРасчетаИзСтруктуры(НаборЗаписей,
                                                 СтруктураОбъекта,
                                                 ПолучатьБитыеСсылки = Ложь,
                                                 СписокСвойств = Неопределено,
                                                 ИсключаяСвойства = Неопределено) Экспорт

	МетаОбъект = НаборЗаписей.Метаданные();

	НаборЗаписей.Отбор.Регистратор.Установить(ЗначениеИзСтруктуры(СтруктураОбъекта.Отбор.Регистратор));

	Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
		Если НЕ (СтруктураОбъекта.Отбор.Свойство(ТекПоле.Имя)
			     И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
			Продолжить;
		КонецЕсли;
		НаборЗаписей.Отбор[ТекПоле.Имя].Установить(ЗначениеИзСтруктуры(СтруктураОбъекта.Отбор[ТекПоле.Имя],
		                                                               ПолучатьБитыеСсылки));
	КонецЦикла;

	НаборЗаписей.Очистить();

	Для Каждого ТекЗапись Из СтруктураОбъекта.Записи Цикл

		НоваяЗапись = НаборЗаписей.Добавить();

		НоваяЗапись.Регистратор       = ЗначениеИзСтруктуры(ТекЗапись.Регистратор, ПолучатьБитыеСсылки);
		НоваяЗапись.Активность        = ЗначениеИзСтруктуры(ТекЗапись.Активность);
		НоваяЗапись.ВидРасчета        = ЗначениеИзСтруктуры(ТекЗапись.ВидРасчета, ПолучатьБитыеСсылки);
		НоваяЗапись.Сторно            = ЗначениеИзСтруктуры(ТекЗапись.Сторно);
		НоваяЗапись.ПериодРегистрации = ЗначениеИзСтруктуры(ТекЗапись.ПериодРегистрации);

		Если МетаОбъект.БазовыйПериод Тогда
			НоваяЗапись.БазовыйПериодНачало = ЗначениеИзСтруктуры(ТекЗапись.БазовыйПериодНачало);
			НоваяЗапись.БазовыйПериодКонец = ЗначениеИзСтруктуры(ТекЗапись.БазовыйПериодКонец);
		КонецЕсли;

		Если МетаОбъект.ПериодДействия Тогда
			НоваяЗапись.ПериодДействияНачало = ЗначениеИзСтруктуры(ТекЗапись.ПериодДействияНачало);
			НоваяЗапись.ПериодДействияКонец  = ЗначениеИзСтруктуры(ТекЗапись.ПериодДействияКонец);
		КонецЕсли;

		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя], ПолучатьБитыеСсылки);
		КонецЦикла;

		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя]);
		КонецЦикла;

		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя], ПолучатьБитыеСсылки);
		КонецЦикла;
	КонецЦикла;

КонецПроцедуры // НаборЗаписейРегистраРасчетаИзСтруктуры()

#КонецОбласти // ПреобразованияОбъектовПоВидам

#КонецОбласти // СлужебныйПрограммныйИнтерфейс

#Область СлужебныеПроцедурыИФункции

#Область ПреобразованияКоллекций

// Функция определяет тип значения, сохраненного в массив или структуру
// для преобразования в значение 1С
//
// Параметры:
//        СтруктураЗначения        - Структура, Массив        - Проверяемое значения
//
// Возвращаемое значение:
//   Тип            - Тип 1С (Массив, Структура, Соответствие, СписокЗначений, ТаблицаЗначений, ДеревоЗначений, ЛюбаяСсылка)
//
Функция СтруктураТипЗнч(СтруктураЗначения)

	Если ТипЗнч(СтруктураЗначения) = Тип("Массив") Тогда
		Если СтруктураЗначения.Количество() = 0 Тогда
			Возврат Тип("Массив");
		КонецЕсли;
		Если ТипЗнч(СтруктураЗначения[0]) = Тип("Структура") Тогда
			ЭтоСоответствие = (СтруктураЗначения[0].Свойство("Ключ")
				             И СтруктураЗначения[0].Свойство("Значение"));
			ЭтоСписок = (СтруктураЗначения[0].Свойство("Представление")
				       И СтруктураЗначения[0].Свойство("Значение")
				       И СтруктураЗначения[0].Свойство("Пометка"));
			Если ЭтоСоответствие Тогда
				Возврат Тип("Соответствие");
			ИначеЕсли ЭтоСписок Тогда
				Возврат Тип("СписокЗначений");
			Иначе
				Возврат Тип("ТаблицаЗначений");
			КонецЕсли;
		КонецЕсли;
		Возврат Тип("Массив");
	ИначеЕсли ТипЗнч(СтруктураЗначения) = Тип("Структура") Тогда
		Если ЕстьТип(СтруктураЗначения) Тогда
			ПравилоЗагрузки = ПолучитьПравилоЗагрузкиТипа(СтруктураЗначения.__Тип);
			Возврат Тип(ПравилоЗагрузки.ТипЗначения);
		ИначеЕсли ЭтоОписаниеТипов(СтруктураЗначения) Тогда
			Если ТипЗнч(СтруктураЗначения.Типы) = Тип("Массив") Тогда
				Возврат Тип("ОписаниеТипов");
			КонецЕсли;
		ИначеЕсли СтруктураЗначения.Свойство("Строки") Тогда
			Если ТипЗнч(СтруктураЗначения.Строки) = Тип("Массив") Тогда
				Возврат Тип("ДеревоЗначений");
			КонецЕсли;
		КонецЕсли;

		Возврат Тип("Структура");
	Иначе
		Возврат ТипЗнч(СтруктураЗначения);
	КонецЕсли;

КонецФункции // СтруктураТипЗнч()

// Функция рекурсивно преобразует структуру значений в структуру с "простыми" типами
//
// Параметры:
//        Значение        - Структура        - Значение для преобразования
//
// Возвращаемое значение:
//   Структура                        - Результат преобразования
//       *__Тип       - Строка          - тип значения (Структура, ФиксированнаяСтруктура)
//       *<элемент>   - Произвольный    - элемент структуры
//
Функция СтруктураВСтруктуру(Значение)

	ТипЗначения = ТипЗнч(Значение);

	ВремСтруктура = Новый Структура();

	Если ТипЗначения = Тип("Структура") Тогда
		ВремСтруктура.Вставить("__Тип", "Структура");
	ИначеЕсли ТипЗначения = Тип("ФиксированнаяСтруктура") Тогда
		ВремСтруктура.Вставить("__Тип", "ФиксированнаяСтруктура");
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	Если НЕ (ТипЗначения = Тип("Структура")
		  ИЛИ ТипЗначения = Тип("ФиксированнаяСтруктура")) Тогда
		Возврат Неопределено;
	КонецЕсли;

	Для Каждого ТекЭлемент Из Значение Цикл
		ВремСтруктура.Вставить(ТекЭлемент.Ключ, ЗначениеВСтруктуру(ТекЭлемент.Значение));
	КонецЦикла;

	Возврат ВремСтруктура;

КонецФункции // СтруктураВСтруктуру()

// Функция рекурсивно преобразует структуру с "простыми" типами значений в структуру значений 1С
//
// Параметры:
//   СтруктураЗначения        - Структура     - Значение для преобразования
//   ПолучатьБитыеСсылки      - Булево        - Истина - если объект по ссылке не существует,
//                                              будет возвращена битая ссылка;
//                                              Ложь - будет возвращена пустая ссылка
//
// Возвращаемое значение:
//   Структура, ФиксированнаяСтруктура        - Результат преобразования
//
Функция СтруктураИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки = Ложь)

	Если НЕ ТипЗнч(СтруктураЗначения) = Тип("Структура") Тогда
		Возврат Неопределено;
	КонецЕсли;

	ВремСтруктура = Новый Структура();

	Тип = "Структура";

	Для Каждого ТекЭлемент Из СтруктураЗначения Цикл
		Если ПредставленияРавны(ТекЭлемент.Ключ, "__Тип") Тогда
			Тип = ТекЭлемент.Значение;
		КонецЕсли;
		ВремСтруктура.Вставить(ТекЭлемент.Ключ, ЗначениеИзСтруктуры(ТекЭлемент.Значение, ПолучатьБитыеСсылки));
	КонецЦикла;

	Если ПредставленияРавны(Тип, "ФиксированнаяСтруктура") Тогда
		ВремСтруктура = Новый ФиксированнаяСтруктура(ВремСтруктура);
	КонецЕсли;

	Возврат ВремСтруктура;

КонецФункции // СтруктураИзСтруктуры()

// Функция рекурсивно преобразует массив значений в массив с "простыми" типами
//
// Параметры:
//        Значение        - Массив        - Значение для преобразования
//
// Возвращаемое значение:
//   Структура                     - Результат преобразования
//       *__Тип       - Строка       - Тип значения (Массив, ФиксированныйМассив)
//       * Элементы   - Массив       - элементы массива
//
Функция МассивВСтруктуру(Значение)

	ТипЗначения = ТипЗнч(Значение);

	ВремМассив = Новый Структура();

	Если ТипЗначения = Тип("Массив") Тогда
		ВремМассив.Вставить("__Тип", "Массив");
	ИначеЕсли ТипЗначения = Тип("ФиксированныйМассив") Тогда
		ВремМассив.Вставить("__Тип", "ФиксированныйМассив");
	Иначе
		Возврат Неопределено;
	КонецЕсли;

	ВремМассив.Вставить("Элементы", Новый Массив());

	Для Каждого ТекЗначение Из Значение Цикл
		ВремМассив.Элементы.Добавить(ЗначениеВСтруктуру(ТекЗначение));
	КонецЦикла;

	Возврат ВремМассив;

КонецФункции // МассивВСтруктуру()

// Функция рекурсивно преобразует массив с "простыми" типами значений в массив значений 1С
//
// Параметры:
//   СтруктураЗначения           - Массив        - Значение для преобразования
//   ПолучатьБитыеСсылки         - Булево        - Истина - если объект по ссылке не существует,
//                                                 будет возвращена битая ссылка;
//                                                 Ложь - будет возвращена пустая ссылка
//
// Возвращаемое значение:
//   Массив, ФиксированныйМассив            - Результат преобразования
//
Функция МассивИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки = Ложь)

	ВремМассив = Новый Массив();

	Элементы = Неопределено;

	Тип = Неопределено;
	ТипЗначения = ТипЗнч(СтруктураЗначения);

	Если ТипЗначения = Тип("Массив") Тогда
		Элементы = СтруктураЗначения;
		Тип = "Массив";
	ИначеЕсли ТипЗначения = Тип("Структура") Тогда
		Если НЕ ЕстьТип(СтруктураЗначения) Тогда
			Возврат Неопределено;
		КонецЕсли;

		Если ПредставленияРавны(СтруктураЗначения.__Тип, "Массив")
		 ИЛИ ПредставленияРавны(СтруктураЗначения.__Тип, "ФиксированныйМассив") Тогда
			Элементы = СтруктураЗначения.Элементы;
			Тип = СтруктураЗначения.__Тип;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;

	Для Каждого ТекЭлемент Из Элементы Цикл
		ВремМассив.Добавить(ЗначениеИзСтруктуры(ТекЭлемент, ПолучатьБитыеСсылки));
	КонецЦикла;

	Если ПредставленияРавны(Тип, "ФиксированныйМассив") Тогда
		ВремМассив = Новый ФиксированныйМассив(ВремМассив);
	КонецЕсли;
	 
	Возврат ВремМассив;

КонецФункции // МассивИзСтруктуры()

// Функция рекурсивно преобразует соответствие значений в массив структур с "простыми" типами
//
// Параметры:
//        Значение        - Соответствие        - Значение для преобразования
//
// Возвращаемое значение:
//   Структура                              - Результат преобразования
//       *__Тип        - Строка               - Тип значения (Соответствие, ФиксированноеСоответствие)
//       *Элементы     - Массив из Структура  - элементы соответствия
//           *Ключ       - Произвольный         - ключ элемента соответствия
//           *Значение   - Произвольный         - значение элемента соответствия
//
Функция СоответствиеВСтруктуру(Значение)

	ТипЗначения = ТипЗнч(Значение);

	ВремСоответствие = Новый Структура();

	Если ТипЗначения = Тип("Соответствие") Тогда
		ВремСоответствие.Вставить("__Тип", "Соответствие");
	ИначеЕсли ТипЗначения = Тип("ФиксированноеСоответствие") Тогда
		ВремСоответствие.Вставить("__Тип", "ФиксированноеСоответствие");
	Иначе
		Возврат Неопределено;
	КонецЕсли;

	Если НЕ (ТипЗначения = Тип("Соответствие")
	 ИЛИ ТипЗначения = Тип("ФиксированноеСоответствие")) Тогда
		Возврат Неопределено;
	КонецЕсли;

	ВремСоответствие.Вставить("Элементы", Новый Массив());

	Для Каждого ТекЭлемент Из Значение Цикл
		ВремСоответствие.Элементы.Добавить(Новый Структура("Ключ,
		                                                   |Значение",
		                                                   ЗначениеВСтруктуру(ТекЭлемент.Ключ),
		                                                   ЗначениеВСтруктуру(ТекЭлемент.Значение)));
	КонецЦикла;

	Возврат ВремСоответствие;

КонецФункции // СоответствиеВСтруктуру()

// Функция рекурсивно преобразует массив структур с "простыми" типами значений в соответствие значений 1С
//
// Параметры:
//   СтруктураЗначения    - Массив из Структура    - Значение для преобразования
//     *Ключ                - Произвольный           - Ключ элемента соответствия
//     *Значение            - Произвольный           - Значение элемента соответствия
//   ПолучатьБитыеСсылки    - Булево                 - Истина - если объект по ссылке не существует,
//                                                     будет возвращена битая ссылка;
//                                                     Ложь - будет возвращена пустая ссылка
//
// Возвращаемое значение:
//   Соответствие, ФиксированноеСоответствие        - Результат преобразования
//
Функция СоответствиеИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки = Ложь)

	ВремСоответствие = Новый Соответствие();

	Элементы = Неопределено;

	Тип = Неопределено;
	ТипЗначения = ТипЗнч(СтруктураЗначения);

	Если ТипЗначения = Тип("Массив") Тогда
		Элементы = СтруктураЗначения;
		Тип = "Соответствие";
	ИначеЕсли ТипЗначения = Тип("Структура") Тогда
		Если НЕ ЕстьТип(СтруктураЗначения) Тогда
			Возврат Неопределено;
		КонецЕсли;

		Если ПредставленияРавны(СтруктураЗначения.__Тип, "Соответствие")
		 ИЛИ ПредставленияРавны(СтруктураЗначения.__Тип, "ФиксированноеСоответствие") Тогда
			Элементы = СтруктураЗначения.Элементы;
			Тип = СтруктураЗначения.__Тип;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;

	Для Каждого ТекЭлемент Из Элементы Цикл
		ВремСоответствие.Вставить(ЗначениеИзСтруктуры(ТекЭлемент.Ключ, ПолучатьБитыеСсылки),
		                          ЗначениеИзСтруктуры(ТекЭлемент.Значение, ПолучатьБитыеСсылки));
	КонецЦикла;

	Если ПредставленияРавны(Тип, "ФиксированноеСоответствие") Тогда
		ВремСоответствие = Новый ФиксированноеСоответствие(ВремСоответствие);
	КонецЕсли;

	Возврат ВремСоответствие;

КонецФункции // СоответствиеИзСтруктуры()

// Функция рекурсивно преобразует список значений в массив структур с "простыми" типами
//
// Параметры:
//        Значение        - СписокЗначений        - Значение для преобразования
//
// Возвращаемое значение:
//   Структура                                   - Результат преобразования
//       *__Тип             - Строка               - Тип значения (СписокЗначений)
//       *Элементы          - Массив из Структура  - элементы списка
//          **Значение        - Произвольный         - Значение элемента списка значений
//          **Представление   - Строка               - Представление элемента списка значений
//          **Пометка         - Булево               - Пометка элемента списка значений
//
Функция СписокЗначенийВСтруктуру(Значение)

	Если НЕ ТипЗнч(Значение) = Тип("СписокЗначений") Тогда
		Возврат Неопределено;
	КонецЕсли;

	ВремСписок = Новый Структура();
	ВремСписок.Вставить("__Тип"   , "СписокЗначений");
	ВремСписок.Вставить("Элементы", Новый Массив());

	Для Каждого ТекЭлемент Из Значение Цикл
		ВремЭлемент = Новый Структура();
		ВремЭлемент.Вставить("Значение"     , ЗначениеВСтруктуру(ТекЭлемент.Значение));
		ВремЭлемент.Вставить("Представление", ТекЭлемент.Представление);
		ВремЭлемент.Вставить("Пометка"      , ТекЭлемент.Пометка);
		ВремЭлемент.Вставить("Картинка"     , Неопределено);

		ВремСписок.Элементы.Добавить(ВремЭлемент);
	КонецЦикла;

	Возврат ВремСписок;

КонецФункции // СписокЗначенийВСтруктуру()

// Функция рекурсивно преобразует массив структур с "простыми" типами значений в список значений 1С
//
// Параметры:
//   СтруктураЗначения    - Структура             - Значение для преобразования
//     *__Тип               - Строка                - Тип значения (СписокЗначений)
//     *Элементы            - Массив из Структура   - элементы списка
//        **Значение          - Произвольный          - Значение элемента списка значений
//        **Представление     - Строка                - Представление элемента списка значений
//        **Пометка           - Булево                - Пометка элемента списка значений
//   ПолучатьБитыеСсылки    - Булево              - Истина - если объект по ссылке не существует,
//                                                  будет возвращена битая ссылка;
//                                                  Ложь - будет возвращена пустая ссылка
//
// Возвращаемое значение:
//   СписокЗначений            - Результат преобразования
//
Функция СписокЗначенийИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки = Ложь)

	ТипЗначения = ТипЗнч(СтруктураЗначения);

	Если ТипЗначения = Тип("Массив") Тогда
		Элементы = СтруктураЗначения;
	ИначеЕсли ТипЗначения = Тип("Структура") Тогда
		Если НЕ ЕстьТип(СтруктураЗначения) Тогда
			Возврат Неопределено;
		КонецЕсли;

		Если ПредставленияРавны(СтруктураЗначения.__Тип, "СписокЗначений") Тогда
			Элементы = СтруктураЗначения.Элементы;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;

	Если Элементы.Количество() = 0 Тогда
		Возврат Новый СписокЗначений();
	КонецЕсли;

	Если Элементы[0].Свойство("Значение")  = Неопределено Тогда
		Возврат Новый СписокЗначений();
	КонецЕсли;

	ВремСписок = Новый СписокЗначений();
	Для Каждого ТекЭлемент Из Элементы Цикл
		ВремСписок.Добавить(ЗначениеИзСтруктуры(ТекЭлемент.Значение, ПолучатьБитыеСсылки),
		                    ТекЭлемент.Представление,
		                    ТекЭлемент.Пометка);
	КонецЦикла;

	Возврат ВремСписок;

КонецФункции // СписокЗначенийИзСтруктуры()

// Функция рекурсивно преобразует строку таблицы/дерева значений в структуру с "простыми" типами
//
// Параметры:
//    СтрокаЗначений    - СтрокаТаблицыЗначений          - Строка для преобразования
//                        СтрокаДереваЗначений
//    СписокСвойств     - Массив из Строка, Структура    - Список заполняемых полей строки
//
// Возвращаемое значение:
//   Структура                                    - Результат преобразования
//      *<Имя колонки>        - Произвольный        - Значение поля строки таблицы/дерева
//
Функция СтрокаЗначенийВСтруктуру(СтрокаЗначений, СписокСвойств)

	ВремСтрока = Новый Структура();

	Для Каждого ТекСвойство Из СписокСвойств Цикл
		Если ТипЗнч(ТекСвойство) = Тип("КлючИЗначение") Тогда
			ВремСтрока.Вставить(ТекСвойство.Ключ, ЗначениеВСтруктуру(СтрокаЗначений[ТекСвойство.Ключ]));
		Иначе
			ВремСтрока.Вставить(ТекСвойство, ЗначениеВСтруктуру(СтрокаЗначений[ТекСвойство]));
		КонецЕсли;
	КонецЦикла;

	Возврат ВремСтрока;

КонецФункции // СтрокаЗначенийВСтруктуру()

// Процедура рекурсивно заполняет строку таблицы/дерева значений данными из структуры с "простыми" типами значений
//
// Параметры:
//   СтрокаЗначений      - СтрокаТаблицыЗначений       - Строка для преобразования
//                         СтрокаДереваЗначений
//   СтруктураЗначений   - Структура                   - Значение для преобразования
//      *<Имя колонки>     - Произвольный                - Значение поля строки таблицы/дерева
//   ПолучатьБитыеСсылки  - Булево                     - Истина - если объект по ссылке не существует,
//                                                       будет возвращена битая ссылка;
//                                                       Ложь - будет возвращена пустая ссылка
//   СписокСвойств      - Массив из Строка, Структура  - Список заполняемых полей строки
//
Процедура СтрокаЗначенийИзСтруктуры(СтрокаЗначений,
                                    СтруктураЗначений,
                                    ПолучатьБитыеСсылки = Ложь,
                                    СписокСвойств = Неопределено)

	Если СписокСвойств = Неопределено Тогда
		СписокСвойств = Новый Массив();
		Для Каждого ТекЭлемент Из СтруктураЗначений Цикл
			СписокСвойств.Добавить(ТекЭлемент.Ключ);
		КонецЦикла;
	КонецЕсли;

	Для Каждого ТекСвойство Из СписокСвойств Цикл
		Если ТипЗнч(ТекСвойство) = Тип("КлючИЗначение") Тогда
			ИмяКолонки = ТекСвойство.Ключ;
		ИначеЕсли ТипЗнч(ТекСвойство) = Тип("КолонкаТаблицыЗначений")
		      ИЛИ ТипЗнч(ТекСвойство) = Тип("КолонкаДереваЗначений") Тогда
			ИмяКолонки = ТекСвойство.Имя;
		Иначе
			ИмяКолонки = ТекСвойство;
		КонецЕсли;
		СтрокаЗначений[ИмяКолонки] = ЗначениеИзСтруктуры(СтруктураЗначений[ИмяКолонки], ПолучатьБитыеСсылки);
	КонецЦикла;

КонецПроцедуры // СтрокаЗначенийИзСтруктуры()

// Функция рекурсивно преобразует таблицу значений в массив структур с "простыми" типами
//
// Параметры:
//        Значение       - ТаблицаЗначений        - Значение для преобразования
//
// Возвращаемое значение:
//   Структура                              - результат преобразования
//     *__Тип          - Строка               - тип значения (ТаблицаЗначений)
//     *Колонки        - Структура            - описания колонок таблицы
//        **<Имя колонки>   - Структура         - описание колонки таблицы
//             ***Заголовок   - Строка            - заголовок колонки
//             ***ТипЗначения - Структура         - описание типа колонки
//             ***Ширина      - Строка            - ширина колонки по умолчанию
//     *Строки         - Массив из Структура  - строки таблицы значений
//        **<Имя колонки>   - Произвольный    - значение поля таблицы значений
//
Функция ТаблицаЗначенийВСтруктуру(Значение, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено)

	Если НЕ ТипЗнч(Значение) = Тип("ТаблицаЗначений") Тогда
		Возврат Неопределено;
	КонецЕсли;

	ВремТаб = Новый Структура();
	ВремТаб.Вставить("__Тип"  , "ТаблицаЗначений");
	ВремТаб.Вставить("Колонки", Новый Структура());
	ВремТаб.Вставить("Строки" , Новый Массив());

	Для Каждого ТекКолонка Из Значение.Колонки Цикл
		Если НЕ ИспользоватьСвойство(ТекКолонка.Имя, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;

		ОписаниеКолонки = Новый Структура();
		ОписаниеКолонки.Вставить("Заголовок"  , ТекКолонка.Заголовок);
		ОписаниеКолонки.Вставить("ТипЗначения", ЗначениеВСтруктуру(ТекКолонка.ТипЗначения));
		ОписаниеКолонки.Вставить("Ширина"     , ТекКолонка.Ширина);

		ВремТаб.Колонки.Вставить(ТекКолонка.Имя, ОписаниеКолонки);
	КонецЦикла;

	Для Каждого ТекСтрока Из Значение Цикл
		ВремТаб.Строки.Добавить(СтрокаЗначенийВСтруктуру(ТекСтрока, ВремТаб.Колонки));
	КонецЦикла;

	Возврат ВремТаб;

КонецФункции // ТаблицаЗначенийВСтруктуру()

// Функция рекурсивно преобразует массив структур с "простыми" типами значений в таблицу значений 1С
//
// Параметры:
//   СтруктураЗначения  - Структура           - Значение для преобразования
//     *__Тип             - Строка              - тип значения (ТаблицаЗначений)
//     *Колонки           - Структура           - описания колонок таблицы
//        **<Имя колонки>   - Структура           - описание колонки таблицы
//             ***Заголовок   - Строка              - заголовок колонки
//             ***ТипЗначения - Структура           - описание типа колонки
//             ***Ширина      - Строка              - ширина колонки по умолчанию
//     *Строки         - Массив из Структура    - строки таблицы значений
//        **<Имя колонки>   - Произвольный        - значение поля таблицы значений
//   ПолучатьБитыеСсылки     - Булево         - Истина - если объект по ссылке не существует,
//                                              будет возвращена битая ссылка;
//                                              Ложь - будет возвращена пустая ссылка
//  СписокСвойств      - Строка, Массив из Строка - Список допустимых свойств
//                                                  (если пустой, то допустимы все свойства)
//  ИсключаяСвойства   - Строка, Массив из Строка - Список исключаемых свойств
//                                                  (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   ТаблицаЗначений    - Результат преобразования
//
Функция ТаблицаЗначенийИзСтруктуры(СтруктураЗначения,
                                   ПолучатьБитыеСсылки = Ложь,
                                   СписокСвойств = Неопределено,
                                   ИсключаяСвойства = Неопределено)

	ТипЗначения = ТипЗнч(СтруктураЗначения);

	Если ТипЗначения = Тип("Массив") Тогда
		Если СтруктураЗначения.Количество() = 0 Тогда
			Возврат Новый ТаблицаЗначений();
		КонецЕсли;
		Колонки = СтруктураЗначения[0];
		Строки = СтруктураЗначения;
	ИначеЕсли ТипЗначения = Тип("Структура") Тогда
		Если НЕ ЕстьТип(СтруктураЗначения) Тогда
			Возврат Неопределено;
		КонецЕсли;

		Если ПредставленияРавны(СтруктураЗначения.__Тип, "ТаблицаЗначений") Тогда
			Колонки = СтруктураЗначения.Колонки;
			Строки = СтруктураЗначения.Строки;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;

	ВремТаб = Новый ТаблицаЗначений();

	Для Каждого ТекЭлемент Из Колонки Цикл
		Если НЕ ИспользоватьСвойство(ТекЭлемент.Ключ, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		Если ТипЗнч(ТекЭлемент.Значение) = Тип("Структура") Тогда
			ВремТаб.Колонки.Добавить(ТекЭлемент.Ключ,
			                         ЗначениеИзСтруктуры(ТекЭлемент.Значение.ТипЗначения),
			                         ТекЭлемент.Значение.Заголовок,
			                         ТекЭлемент.Значение.Ширина);
		Иначе
			ВремТаб.Колонки.Добавить(ТекЭлемент.Ключ);
		КонецЕсли;
	КонецЦикла;

	Для Каждого ТекСтрока Из Строки Цикл
		НоваяСтрока = ВремТаб.Добавить();
		СтрокаЗначенийИзСтруктуры(НоваяСтрока, ТекСтрока, ПолучатьБитыеСсылки, ВремТаб.Колонки);
	КонецЦикла;

	Возврат ВремТаб;

КонецФункции // ТаблицаЗначенийИзСтруктуры()

// Функция рекурсивно преобразует строки дерева значений в массив структур с "простыми" типами
//
// Параметры:
//   СтрокиДерева    - КоллекцияСтрокДереваЗначений      - Строки для преобразования
//   СписокСвойств   - Массив из Строка                  - Список заполняемых полей строки
//
// Возвращаемое значение:
//   Массив из Структура                      - Результат преобразования
//     *<Имя колонки>     - Произвольный        - Значение поля строки дерева
//
Функция СтрокиДереваВСтруктуру(СтрокиДерева, СписокСвойств)

	ВремСтроки = Новый Массив();

	Для Каждого ТекСтрока Из СтрокиДерева Цикл
		ВремСтрока = СтрокаЗначенийВСтруктуру(ТекСтрока, СписокСвойств);
		ВремСтрока.Вставить("Строки", СтрокиДереваВСтруктуру(ТекСтрока.Строки, СписокСвойств));
		ВремСтроки.Добавить(ВремСТрока);
	КонецЦикла;

	Возврат ВремСтроки;

КонецФункции // СтрокиДереваВСтруктуру()

// Процедура рекурсивно заполняет строки дерева значений данными из массива структур с "простыми" типами значений
//
// Параметры:
//   СтрокиДерева        - КоллекцияСтрокДереваЗначений  - Строка для преобразования
//   СтруктураСтрок      - Массив из Структура             - Значение для преобразования
//     *<Имя колонки>      - Произвольный                  - Значение поля строки дерева
//   ПолучатьБитыеСсылки   - Булево                        - Истина - если объект по ссылке не существует,
//                                                           будет возвращена битая ссылка;
//                                                           Ложь - будет возвращена пустая ссылка
//   СписокСвойств       - Массив из Строка              - Список заполняемых полей строк
//
Процедура СтрокиДереваИзСтруктуры(СтрокиДерева,
                                  СтруктураСтрок,
                                  ПолучатьБитыеСсылки = Ложь,
                                  СписокСвойств = Неопределено)

	Для Каждого ТекСтрока Из СтруктураСтрок Цикл
		НоваяСтрока = СтрокиДерева.Добавить();
		СтрокаЗначенийИзСтруктуры(НоваяСтрока, ТекСтрока, ПолучатьБитыеСсылки, СписокСвойств);
		СтрокиДереваИзСтруктуры(НоваяСтрока.Строки, ТекСтрока.Строки, ПолучатьБитыеСсылки, СписокСвойств);
	КонецЦикла;

КонецПроцедуры // СтрокиДереваИзСтруктуры()

// Функция рекурсивно преобразует дерево значений в структуру с "простыми" типами
//
// Параметры:
//        Значение        - ДеревоЗначений        - Значение для преобразования
//
// Возвращаемое значение:
//   Структура                                 - результат преобразования
//     *__Тип             - Строка               - тип значения (ДеревоЗначений)
//     *Колонки           - Структура            - описания колонок дерева
//       **<Имя колонки>    - Структура            - описание колонки дерева
//           ***Заголовок   - Строка                 - заголовок колонки
//           ***ТипЗначения - Структура              - описание типа колонки
//           ***Ширина      - Строка                 - ширина колонки по умолчанию
//     *Строки            - Массив из Структура  - строки дерева значений
//       **<Имя колонки>    - Произвольный         - значение поля дерева значений
//
Функция ДеревоЗначенийВСтруктуру(Значение, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено)

	Если НЕ ТипЗнч(Значение) = Тип("ДеревоЗначений") Тогда
		Возврат Неопределено;
	КонецЕсли;

	ВремДерево = Новый Структура();
	ВремДерево.Вставить("__Тип"  , "ДеревоЗначений");
	ВремДерево.Вставить("Колонки", Новый Структура());
	ВремДерево.Вставить("Строки" , Новый Массив());

	Для Каждого ТекКолонка Из Значение.Колонки Цикл
		Если НЕ ИспользоватьСвойство(ТекКолонка.Имя, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		Если ПредставленияРавны(ТекКолонка.Имя, "Родитель") Тогда
			ПоказатьСообщение("Имя колонки ""Родитель"" совпадает с именем свойства строки дерева значений,
                              |колонка не может быть сохранена!");
			Продолжить;
		КонецЕсли;

		ОписаниеКолонки = Новый Структура();
		ОписаниеКолонки.Вставить("Заголовок"  , ТекКолонка.Заголовок);
		ОписаниеКолонки.Вставить("ТипЗначения", ЗначениеВСтруктуру(ТекКолонка.ТипЗначения));
		ОписаниеКолонки.Вставить("Ширина"     , ТекКолонка.Ширина);

		ВремДерево.Колонки.Вставить(ТекКолонка.Имя, ОписаниеКолонки);
	КонецЦикла;

	МассивКолонок = Новый Массив();
	Для Каждого ТекКолонка Из Значение.Колонки Цикл
		Если НЕ ИспользоватьСвойство(ТекКолонка.Имя, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		МассивКолонок.Добавить(ТекКолонка.Имя);
	КонецЦикла;

	ВремДерево.Строки = СтрокиДереваВСтруктуру(Значение.Строки, ВремДерево.Колонки);

	Возврат ВремДерево;

КонецФункции // ДеревоЗначенийВСтруктуру()

// Функция рекурсивно преобразует структуру с "простыми" типами значений в дерево значений 1С
//
// Параметры:
//   СтруктураЗначения    - Структура            - значение для преобразования
//     *__Тип               - Строка               - тип значения (ДеревоЗначений)
//     *Колонки             - Структура            - описания колонок дерева
//       **<Имя колонки>      - Структура            - описание колонки дерева
//           ***Заголовок     - Строка                 - заголовок колонки
//           ***ТипЗначения   - Структура              - описание типа колонки
//           ***Ширина        - Строка                 - ширина колонки по умолчанию
//     *Строки              - Массив из Структура  - строки дерева значений
//       **<Имя колонки>      - Произвольный         - значение поля дерева значений
//   ПолучатьБитыеСсылки  - Булево               - Истина - если объект по ссылке не существует,
//                                                 будет возвращена битая ссылка;
//                                                 Ложь - будет возвращена пустая ссылка
//  СписокСвойств         - Строка, Массив из Строка - список допустимых свойств
//                                                     (если пустой, то допустимы все свойства)
//  ИсключаяСвойства      - Строка, Массив из Строка - список исключаемых свойств
//                                                     (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   ДеревоЗначений            - Результат преобразования
//
Функция ДеревоЗначенийИзСтруктуры(СтруктураЗначения,
                                  ПолучатьБитыеСсылки = Ложь,
                                  СписокСвойств = Неопределено,
                                  ИсключаяСвойства = Неопределено)

	Если ТипЗнч(СтруктураЗначения) = Тип("Структура") Тогда
		Если НЕ ЕстьТип(СтруктураЗначения) Тогда
			Колонки = СтруктураЗначения.Строки[0];
			Строки = СтруктураЗначения.Строки;
		ИначеЕсли ПредставленияРавны(СтруктураЗначения.__Тип, "ДеревоЗначений") Тогда
			Колонки = СтруктураЗначения.Колонки;
			Строки = СтруктураЗначения.Строки;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;

	Если НЕ ТипЗнч(Строки) = Тип("Массив") Тогда
		Возврат Неопределено;
	КонецЕсли;

	Если НЕ СтруктураЗначения.Свойство("Колонки") И Строки.Количество() = 0 Тогда
		Возврат Новый ДеревоЗначений();
	КонецЕсли;

	ВремДерево = Новый ДеревоЗначений();

	Для Каждого ТекЭлемент Из Колонки Цикл
		Если НЕ ИспользоватьСвойство(ТекЭлемент.Ключ, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		Если ПредставленияРавны(ТекЭлемент.Ключ, "Родитель") Тогда
			ПоказатьСообщение("Имя колонки ""Родитель"" совпадает с именем свойства строки дерева значений,
                              |колонка не может быть сохранена!");
			Продолжить;
		КонецЕсли;
		Если ТипЗнч(ТекЭлемент.Значение) = Тип("Структура") Тогда
			ВремДерево.Колонки.Добавить(ТекЭлемент.Ключ,
			                         ЗначениеИзСтруктуры(ТекЭлемент.Значение.ТипЗначения),
			                         ТекЭлемент.Значение.Заголовок,
			                         ТекЭлемент.Значение.Ширина);
		Иначе
			ВремДерево.Колонки.Добавить(ТекЭлемент.Ключ);
		КонецЕсли;
	КонецЦикла;

	СтрокиДереваИзСтруктуры(ВремДерево.Строки, Строки, ПолучатьБитыеСсылки, ВремДерево.Колонки);

	Возврат ВремДерево;

КонецФункции // ДеревоЗначенийИзСтруктуры()

#КонецОбласти // ПреобразованияКоллекций

#Область ПреобразованияСКДПроцедурыПреобразованияОбъектов

// Функция - заполняет и возвращает структуру описания объекта СКД
// ВариантНастроекКомпоновкиДанных
// 
// Параметры:
//     Объект             - ВариантНастроекКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ВариантНастроекСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ВариантНастроекКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ВариантНастроекКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Имя"          , Объект.Имя);
	СтруктураОбъекта.Вставить("Настройки"    , ЗначениеСКДВСтруктуру(Объект.Настройки));
	СтруктураОбъекта.Вставить("Представление", Объект.Представление);

	Возврат СтруктураОбъекта;

КонецФункции // ВариантНастроекСКДВСтруктуру()

// Процедура - заполняет объект СКД ВариантНастроекКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ВариантНастроекКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                       - данные для заполнения объекта
//
Процедура ВариантНастроекСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ВариантНастроекКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Настройки", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Представление");

КонецПроцедуры // ВариантНастроекСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ВложеннаяСхемаКомпоновкиДанных
// 
// Параметры:
//     Объект             - ВложеннаяСхемаКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ВложеннаяСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ВложеннаяСхемаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ВложеннаяСхемаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Заголовок", Объект.Заголовок);
	СтруктураОбъекта.Вставить("Имя"      , Объект.Имя);
	СтруктураОбъекта.Вставить("Настройки", ЗначениеСКДВСтруктуру(Объект.Настройки));
	СтруктураОбъекта.Вставить("Схема"    , ЗначениеСКДВСтруктуру(Объект.Схема));

	Возврат СтруктураОбъекта;

КонецФункции // ВложеннаяСКДВСтруктуру()

// Процедура - заполняет объект СКД ВложеннаяСхемаКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ВложеннаяСхемаКомпоновкиДанных  - заполняемый объект
//     СтруктураОбъекта   - Структура                       - данные для заполнения объекта
//
Процедура ВложеннаяСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ВложеннаяСхемаКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Заголовок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Настройки", Истина);

	Если НЕ ТипЗнч(Объект.Схема) = Тип("СхемаКомпоновкиДанных") Тогда
		// @skip-error - в СП написано, что поле имеет свойство "Только чтение",
		// но при добавлении вложенной схемы поле содержит неопределено и присваивание допускается
		Объект.Схема = Новый СхемаКомпоновкиДанных();
	КонецЕсли;
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Схема", Истина);

КонецПроцедуры // ВложеннаяСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ВычисляемоеПолеСхемыКомпоновкиДанных
// 
// Параметры:
//     Объект             - ВычисляемоеПолеСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ВычисляемоеПолеСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ВычисляемоеПолеСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ВычисляемоеПолеСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Выражение"               , Объект.Выражение);
	СтруктураОбъекта.Вставить("ВыражениеПредставления"  , Объект.ВыражениеПредставления);
	СтруктураОбъекта.Вставить("ВыраженияУпорядочивания" , КоллекцияСКДВМассив(Объект.ВыраженияУпорядочивания));
	СтруктураОбъекта.Вставить("Заголовок"               , Объект.Заголовок);
	СтруктураОбъекта.Вставить("ОграничениеИспользования", ЗначениеСКДВСтруктуру(Объект.ОграничениеИспользования));
	СтруктураОбъекта.Вставить("Оформление"              , ЗначениеСКДВСтруктуру(Объект.Оформление));
	СтруктураОбъекта.Вставить("ПараметрыРедактирования" , ЗначениеСКДВСтруктуру(Объект.ПараметрыРедактирования));
	СтруктураОбъекта.Вставить("ПутьКДанным"             , Объект.ПутьКДанным);
	СтруктураОбъекта.Вставить("ТипЗначения"             , ЗначениеВСтруктуру(Объект.ТипЗначения));

	Возврат СтруктураОбъекта;

КонецФункции // ВычисляемоеПолеСКДВСтруктуру()

// Процедура - заполняет объект СКД ВычисляемоеПолеСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ВычисляемоеПолеСхемыКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                            - данные для заполнения объекта
//
Процедура ВычисляемоеПолеСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ВычисляемоеПолеСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Выражение");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ВыражениеПредставления");

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "ВыраженияУпорядочивания");

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Заголовок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ОграничениеИспользования", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Оформление", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПараметрыРедактирования", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПутьКДанным");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ОграничениеИспользования", Истина);

	Если СтруктураОбъекта.Свойство("ТипЗначения") Тогда
		Объект.ТипЗначения = ЗначениеИзСтруктуры(СтруктураОбъекта.ТипЗначения);
	КонецЕсли;

КонецПроцедуры // ВычисляемоеПолеСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ИсточникДанныхСхемыКомпоновкиДанных
// 
// Параметры:
//     Объект             - ИсточникДанныхСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ИсточникДанныхСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ИсточникДанныхСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ИсточникДанныхСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Имя"               , Объект.Имя);
	СтруктураОбъекта.Вставить("СтрокаСоединения"  , Объект.СтрокаСоединения);
	СтруктураОбъекта.Вставить("ТипИсточникаДанных", Объект.ТипИсточникаДанных);

	Возврат СтруктураОбъекта;

КонецФункции // ИсточникДанныхСКДВСтруктуру()

// Процедура - заполняет объект СКД ИсточникДанныхСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ИсточникДанныхСхемыКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                           - данные для заполнения объекта
//
Процедура ИсточникДанныхСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ИсточникДанныхСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "СтрокаСоединения");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ТипИсточникаДанных");

КонецПроцедуры // ИсточникДанныхСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ОписаниеМакетаСхемыКомпоновкиДанных
// 
// Параметры:
//     Объект             - ОписаниеМакетаСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ОписаниеМакетаСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ОписаниеМакетаСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ОписаниеМакетаСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Имя"    , Объект.Имя);

	Если ТипЗнч(Объект.Макет) = Тип("МакетОбластиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("Макет" , КоллекцияСКДВМассив(Объект.Макет));
	КонецЕсли;

	СтруктураОбъекта.Вставить("Параметры" , КоллекцияСКДВМассив(Объект.Параметры));

	Возврат СтруктураОбъекта;

КонецФункции // ОписаниеМакетаСКДВСтруктуру()

// Процедура - заполняет объект СКД ОписаниеМакетаСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ОписаниеМакетаСхемыКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                           - данные для заполнения объекта
//
Процедура ОписаниеМакетаСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ОписаниеМакетаСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");

	Если СтруктураОбъекта.Свойство("Макет") Тогда
		Для Каждого ТекЭлемент Из СтруктураОбъекта.Макет Цикл
			Если НЕ ТипЗнч(Объект.Макет) = Тип("МакетОбластиКомпоновкиДанных") Тогда
				Объект.Макет = Новый МакетОбластиКомпоновкиДанных();
			КонецЕсли;
			НовыйЭлемент = Объект.Макет.Добавить(Тип(ТекЭлемент.__Тип));
			ЗначениеСКДИзСтруктуры(НовыйЭлемент, ТекЭлемент);
		КонецЦикла;
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Параметры", Истина);

КонецПроцедуры // ОписаниеМакетаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// МакетГруппировкиСхемыКомпоновкиДанных
// 
// Параметры:
//     Объект             - МакетГруппировкиСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция МакетГруппировкиСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("МакетГруппировкиСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "МакетГруппировкиСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ИмяГруппировки" , Объект.ИмяГруппировки);
	СтруктураОбъекта.Вставить("Макет"          , Объект.Макет);
	СтруктураОбъекта.Вставить("ПоляГруппировки", КоллекцияСКДВМассив(Объект.ПоляГруппировки));
	СтруктураОбъекта.Вставить("ТипМакета"      , ПеречислениеСКДВСтроку(Объект.ТипМакета));

	Возврат СтруктураОбъекта;

КонецФункции // МакетГруппировкиСКДВСтруктуру()

// Процедура - заполняет объект СКД МакетГруппировкиСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - МакетГруппировкиСхемыКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                             - данные для заполнения объекта
//
Процедура МакетГруппировкиСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("МакетГруппировкиСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИмяГруппировки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Макет");

	Если СтруктураОбъекта.Свойство("ПоляГруппировки") Тогда
		Для Каждого ТекЭлемент Из СтруктураОбъекта.ПоляГруппировки Цикл
			Объект.ПоляГруппировки.Добавить(Новый ПолеКомпоновкиДанных(ТекЭлемент.Имя));
		КонецЦикла;
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ТипМакета") Тогда
		Объект.ТипМакета = ТипМакетаОбластиКомпоновкиДанных[СтруктураОбъекта.ТипМакета];
	КонецЕсли;

КонецПроцедуры // МакетГруппировкиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// МакетПоляСхемыКомпоновкиДанных
// 
// Параметры:
//     Объект             - МакетПоляСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция МакетПоляСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("МакетПоляСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "МакетПоляСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Макет", Объект.Макет);
	СтруктураОбъекта.Вставить("Поле" , Объект.Поле);

	Возврат СтруктураОбъекта;

КонецФункции // МакетПоляСКДВСтруктуру()

// Процедура - заполняет объект СКД МакетПоляСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - МакетПоляСхемыКомпоновкиДанных  - заполняемый объект
//     СтруктураОбъекта   - Структура                       - данные для заполнения объекта
//
Процедура МакетПоляСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("МакетПоляСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Макет");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Поле");

КонецПроцедуры // МакетПоляСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// МакетПолейИтогаСхемыКомпоновкиДанных
// 
// Параметры:
//     Объект             - МакетПолейИтогаСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция МакетПолейИтогаСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("МакетПолейИтогаСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "МакетПолейИтогаСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ИмяГруппировки1" , Объект.ИмяГруппировки1);
	СтруктураОбъекта.Вставить("ИмяГруппировки2" , Объект.ИмяГруппировки2);
	СтруктураОбъекта.Вставить("Макет"           , Объект.Макет);
	СтруктураОбъекта.Вставить("ПоляГруппировки1", КоллекцияСКДВМассив(Объект.ПоляГруппировки1));
	СтруктураОбъекта.Вставить("ПоляГруппировки2", КоллекцияСКДВМассив(Объект.ПоляГруппировки2));
	СтруктураОбъекта.Вставить("ТипМакета1"      , ПеречислениеСКДВСтроку(Объект.ТипМакета1));
	СтруктураОбъекта.Вставить("ТипМакета2"      , ПеречислениеСКДВСтроку(Объект.ТипМакета2));

	Возврат СтруктураОбъекта;

КонецФункции // МакетПолейИтогаСКДВСтруктуру()

// Процедура - заполняет объект СКД МакетПолейИтогаСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - МакетПолейИтогаСхемыКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                            - данные для заполнения объекта
//
Процедура МакетПолейИтогаСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("МакетПолейИтогаСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИмяГруппировки1");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИмяГруппировки2");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Макет");

	Если СтруктураОбъекта.Свойство("ПоляГруппировки1") Тогда
		Для Каждого ТекЭлемент Из СтруктураОбъекта.ПоляГруппировки1 Цикл
			Объект.ПоляГруппировки1.Добавить(Новый ПолеКомпоновкиДанных(ТекЭлемент.Имя));
		КонецЦикла;
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ПоляГруппировки2") Тогда
		Для Каждого ТекЭлемент Из СтруктураОбъекта.ПоляГруппировки2 Цикл
			Объект.ПоляГруппировки2.Добавить(Новый ПолеКомпоновкиДанных(ТекЭлемент.Имя));
		КонецЦикла;
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ТипМакета1") Тогда
		Объект.ТипМакета1 = ТипМакетаОбластиКомпоновкиДанных[СтруктураОбъекта.ТипМакета1];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ТипМакета2") Тогда
		Объект.ТипМакета2 = ТипМакетаОбластиКомпоновкиДанных[СтруктураОбъекта.ТипМакета2];
	КонецЕсли;

КонецПроцедуры // МакетПолейИтогаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// НаборДанныхЗапросСхемыКомпоновкиДанных
// 
// Параметры:
//     Объект             - НаборДанныхЗапросСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция НаборДанныхЗапросСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("НаборДанныхЗапросСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "НаборДанныхЗапросСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("АвтозаполнениеДоступныхПолей", Объект.АвтозаполнениеДоступныхПолей);
	СтруктураОбъекта.Вставить("Запрос"                      , Объект.Запрос);
	СтруктураОбъекта.Вставить("Имя"                         , Объект.Имя);
	СтруктураОбъекта.Вставить("ИсточникДанных"              , Объект.ИсточникДанных);
	СтруктураОбъекта.Вставить("Поля"                        , КоллекцияСКДВМассив(Объект.Поля));

	Возврат СтруктураОбъекта;

КонецФункции // НаборДанныхЗапросСКДВСтруктуру()

// Процедура - заполняет объект СКД НаборДанныхЗапросСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - НаборДанныхЗапросСхемыКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                              - данные для заполнения объекта
//
Процедура НаборДанныхЗапросСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("НаборДанныхЗапросСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "АвтозаполнениеДоступныхПолей");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Запрос");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИсточникДанных");

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Поля", Истина);

КонецПроцедуры // НаборДанныхЗапросСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// НаборДанныхОбъектСхемыКомпоновкиДанных
// 
// Параметры:
//     Объект             - НаборДанныхОбъектСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция НаборДанныхОбъектСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("НаборДанныхОбъектСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "НаборДанныхОбъектСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Имя"           , Объект.Имя);
	СтруктураОбъекта.Вставить("ИмяОбъекта"    , Объект.ИмяОбъекта);
	СтруктураОбъекта.Вставить("ИсточникДанных", Объект.ИсточникДанных);
	СтруктураОбъекта.Вставить("Поля"          , КоллекцияСКДВМассив(Объект.Поля));

	Возврат СтруктураОбъекта;

КонецФункции // НаборДанныхОбъектСКДВСтруктуру()

// Процедура - заполняет объект СКД НаборДанныхОбъектСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - НаборДанныхОбъектСхемыКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                              - данные для заполнения объекта
//
Процедура НаборДанныхОбъектСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("НаборДанныхОбъектСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИмяОбъекта");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИсточникДанных");

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Поля", Истина);

КонецПроцедуры // НаборДанныхОбъектСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// НаборДанныхОбъединениеСхемыКомпоновкиДанных
// 
// Параметры:
//     Объект             - НаборДанныхОбъединениеСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция НаборДанныхОбъединениеСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("НаборДанныхОбъединениеСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "НаборДанныхОбъединениеСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"     , "НаборДанныхОбъединениеСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Имя"     , Объект.Имя);
	СтруктураОбъекта.Вставить("Поля"    , КоллекцияСКДВМассив(Объект.Поля));
	СтруктураОбъекта.Вставить("Элементы", КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;

КонецФункции // НаборДанныхОбъединениеСКДВСтруктуру()

// Процедура - заполняет объект СКД НаборДанныхОбъединениеСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - НаборДанныхОбъединениеСхемыКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                                   - данные для заполнения объекта
//
Процедура НаборДанныхОбъединениеСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("НаборДанныхОбъединениеСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Поля", Истина);
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы", Истина);

КонецПроцедуры // НаборДанныхОбъединениеСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПараметрСхемыКомпоновкиДанных
// 
// Параметры:
//     Объект             - ПараметрСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ПараметрСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ПараметрСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПараметрСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ВключатьВДоступныеПоля"        , Объект.ВключатьВДоступныеПоля);
	СтруктураОбъекта.Вставить("Выражение"                     , Объект.Выражение);
	СтруктураОбъекта.Вставить("ДоступенСписокЗначений"        , Объект.ДоступенСписокЗначений);
	СтруктураОбъекта.Вставить("Заголовок"                     , Объект.Заголовок);
	СтруктураОбъекта.Вставить("ЗапрещатьНезаполненныеЗначения", Объект.ЗапрещатьНезаполненныеЗначения);
	СтруктураОбъекта.Вставить("Значение"                      , ЗначениеВСтруктуру(Объект.Значение));
	СтруктураОбъекта.Вставить("Имя"                           , Объект.Имя);

	СтруктураОбъекта.Вставить("Использование",
	                          ПеречислениеСКДВСтроку(Объект.Использование));

	СтруктураОбъекта.Вставить("ОграничениеИспользования"      , Объект.ОграничениеИспользования);
	СтруктураОбъекта.Вставить("ПараметрФункциональныхОпций"   , Объект.ПараметрФункциональныхОпций);

	СтруктураОбъекта.Вставить("ПараметрыРедактирования",
	                          ЗначениеСКДВСтруктуру(Объект.ПараметрыРедактирования));
	                          
	СтруктураОбъекта.Вставить("ТипЗначения"                   , ЗначениеВСтруктуру(Объект.ТипЗначения));

	Возврат СтруктураОбъекта;

КонецФункции // ПараметрСКДВСтруктуру()

// Процедура - заполняет объект СКД ПараметрСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ПараметрСхемыКомпоновкиДанных   - заполняемый объект
//     СтруктураОбъекта   - Структура                       - данные для заполнения объекта
//
Процедура ПараметрСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ПараметрСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ВключатьВДоступныеПоля");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Выражение");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ДоступенСписокЗначений");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Заголовок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ЗапрещатьНезаполненныеЗначения");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ОграничениеИспользования");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПараметрФункциональныхОпций");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПараметрыРедактирования", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ЗапрещатьНезаполненныеЗначения");

	Если СтруктураОбъекта.Свойство("Значение") Тогда
		Объект.Значение = ЗначениеИзСтруктуры(СтруктураОбъекта.Значение);
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("Использование") Тогда
		Объект.Использование = ИспользованиеПараметраКомпоновкиДанных[СтруктураОбъекта.Использование];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ТипЗначения") Тогда
		Объект.ТипЗначения = ЗначениеИзСтруктуры(СтруктураОбъекта.ТипЗначения);
	КонецЕсли;

КонецПроцедуры // ПараметрСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПолеИтогаСхемыКомпоновкиДанных
// 
// Параметры:
//     Объект             - ПолеИтогаСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ПолеИтогаСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ПолеИтогаСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПолеИтогаСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Выражение"  , Объект.Выражение);
	СтруктураОбъекта.Вставить("ПутьКДанным", Объект.ПутьКДанным);

	МассивЭлементов = Новый Массив();
	Для Каждого ТекЭлемент Из Объект.Группировки Цикл
		// TODO: Проверить тип элемента массива группировок (вроде - Строка)
		МассивЭлементов.Добавить(СокрЛП(ТекЭлемент));
	КонецЦикла;
	СтруктураОбъекта.Вставить("Группировки", МассивЭлементов);

	Возврат СтруктураОбъекта;

КонецФункции // ПолеИтогаСКДВСтруктуру()

// Процедура - заполняет объект СКД ПолеИтогаСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ПолеИтогаСхемыКомпоновкиДанных  - заполняемый объект
//     СтруктураОбъекта   - Структура                       - данные для заполнения объекта
//
Процедура ПолеИтогаСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ПолеИтогаСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Выражение");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПутьКДанным");

	Если СтруктураОбъекта.Свойство("Группировки") Тогда
		Для Каждого ТекЭлемент Из СтруктураОбъекта.Группировки Цикл
			Объект.Группировки.Добавить(ТекЭлемент);
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры // ПолеИтогаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// СвязьНаборовДанныхСхемыКомпоновкиДанных
// 
// Параметры:
//     Объект             - СвязьНаборовДанныхСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция СвязьНаборовДанныхСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("СвязьНаборовДанныхСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "СвязьНаборовДанныхСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ВыражениеИсточник"       , Объект.ВыражениеИсточник);
	СтруктураОбъекта.Вставить("ВыражениеПриемник"       , Объект.ВыражениеПриемник);
	СтруктураОбъекта.Вставить("НаборДанныхИсточник"     , Объект.НаборДанныхИсточник);
	СтруктураОбъекта.Вставить("НаборДанныхПриемник"     , Объект.НаборДанныхПриемник);
	СтруктураОбъекта.Вставить("НачальноеВыражение"      , Объект.НачальноеВыражение);
	СтруктураОбъекта.Вставить("Обязательная"            , Объект.Обязательная);
	СтруктураОбъекта.Вставить("Параметр"                , Объект.Параметр);
	СтруктураОбъекта.Вставить("РазрешенСписокПараметров", Объект.РазрешенСписокПараметров);
	СтруктураОбъекта.Вставить("УсловиеСвязи"            , Объект.УсловиеСвязи);

	Возврат СтруктураОбъекта;

КонецФункции // СвязьНаборовДанныхСКДВСтруктуру()

// Процедура - заполняет объект СКД СвязьНаборовДанныхСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - СвязьНаборовДанныхСхемыКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                               - данные для заполнения объекта
//
Процедура СвязьНаборовДанныхСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("СвязьНаборовДанныхСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ВыражениеИсточник");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ВыражениеПриемник");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "НаборДанныхИсточник");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "НаборДанныхПриемник");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "НачальноеВыражение");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Обязательная");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Параметр");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "РазрешенСписокПараметров");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "УсловиеСвязи");

КонецПроцедуры // СвязьНаборовДанныхСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ВыражениеУпорядочиванияКомпоновкиДанных
// 
// Параметры:
//     Объект             - ВыражениеУпорядочиванияКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ВыражениеУпорядочиванияСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ВыражениеУпорядочиванияКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ВыражениеУпорядочиванияКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Автоупорядочивание", Объект.Автоупорядочивание);
	СтруктураОбъекта.Вставить("Выражение"         , Объект.Выражение);
	СтруктураОбъекта.Вставить("ТипУпорядочивания",
	                          ПеречислениеСКДВСтроку(Объект.ТипУпорядочивания));

	Возврат СтруктураОбъекта;

КонецФункции // ВыражениеУпорядочиванияСКДВСтруктуру()

// Процедура - заполняет объект СКД ВыражениеУпорядочиванияКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ВыражениеУпорядочиванияКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                               - данные для заполнения объекта
//
Процедура ВыражениеУпорядочиванияСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ВыражениеУпорядочиванияКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Автоупорядочивание");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Выражение");

	Если СтруктураОбъекта.Свойство("ТипУпорядочивания") Тогда
		Объект.ТипУпорядочивания = НаправлениеСортировкиКомпоновкиДанных[СтруктураОбъекта.ТипУпорядочивания];
	КонецЕсли;

КонецПроцедуры // ВыражениеУпорядочиванияСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ОграничениеИспользованияПоляСхемыКомпоновкиДанных
// 
// Параметры:
//     Объект             - ОграничениеИспользованияПоляСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ОграничениеИспользованияПоляСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ОграничениеИспользованияПоляСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ОграничениеИспользованияПоляСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Группировка", Объект.Группировка);
	СтруктураОбъекта.Вставить("Поле"       , Объект.Поле);
	СтруктураОбъекта.Вставить("Порядок"    , Объект.Порядок);
	СтруктураОбъекта.Вставить("Условие"    , Объект.Условие);

	Возврат СтруктураОбъекта;

КонецФункции // ОграничениеИспользованияПоляСКДВСтруктуру()

// Процедура - заполняет объект СКД ОграничениеИспользованияПоляСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ОграничениеИспользованияПоляСхемыКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                                         - данные для заполнения объекта
//
Процедура ОграничениеИспользованияПоляСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ОграничениеИспользованияПоляСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Группировка");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Поле");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Порядок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Условие");

КонецПроцедуры // ОграничениеИспользованияПоляСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ОформлениеКомпоновкиДанных
// 
// Параметры:
//     Объект             - ОформлениеКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ОформлениеСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ОформлениеКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ОформлениеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Элементы", КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;

КонецФункции // ОформлениеСКДВСтруктуру()

// Процедура - заполняет объект СКД ОформлениеКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ОформлениеКомпоновкиДанных   - заполняемый объект
//     СтруктураОбъекта   - Структура                    - данные для заполнения объекта
//
Процедура ОформлениеСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ОформлениеКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	ЗначенияПараметровОбъектаСКДИзСтруктуры(Объект, Объект, СтруктураОбъекта);

КонецПроцедуры // ОформлениеСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ЗначениеПараметраНастроекКомпоновкиДанных
// 
// Параметры:
//     Объект             - ЗначениеПараметраНастроекКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ЗначениеПараметраНастроекСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ЗначениеПараметраНастроекКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ЗначениеПараметраНастроекКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"     , "ЗначениеПараметраНастроекКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Значение"     , ЗначениеВСтруктуру(Объект.Значение));
	СтруктураОбъекта.Вставить("Использование", Объект.Использование);
	СтруктураОбъекта.Вставить("Параметр"     , СокрЛП(Объект.Параметр));

	СтруктураОбъекта.Вставить("ЗначенияВложенныхПараметров",
	                          КоллекцияСКДВМассив(Объект.ЗначенияВложенныхПараметров));
	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));

	// TODO: Проверить как работает родитель
	Возврат СтруктураОбъекта;

КонецФункции // ЗначениеПараметраНастроекСКДВСтруктуру()

// Процедура - заполняет объект СКД ЗначениеПараметраНастроекКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ЗначениеПараметраНастроекКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                                 - данные для заполнения объекта
//
Процедура ЗначениеПараметраНастроекСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ЗначениеПараметраНастроекКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("Значение") Тогда
		Объект.Значение = ЗначениеИзСтруктуры(СтруктураОбъекта.Значение);
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "ЗначенияВложенныхПараметров");

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");

	Если СтруктураОбъекта.Свойство("Параметр") Тогда
		Объект.Параметр = Новый ПараметрКомпоновкиДанных(СтруктураОбъекта.Параметр);
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения =
			РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

КонецПроцедуры // ЗначениеПараметраНастроекСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ЗначениеПараметраКомпоновкиДанных
// 
// Параметры:
//     Объект             - ЗначениеПараметраКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ЗначениеПараметраСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ЗначениеПараметраКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ЗначениеПараметраКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"     , "ЗначениеПараметраКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Значение"     , ЗначениеВСтруктуру(Объект.Значение));
	СтруктураОбъекта.Вставить("Использование", Объект.Использование);
	СтруктураОбъекта.Вставить("Параметр"     , СокрЛП(Объект.Параметр));

	СтруктураОбъекта.Вставить("ЗначенияВложенныхПараметров",
	                          КоллекцияСКДВМассив(Объект.ЗначенияВложенныхПараметров));

	// TODO: Проверить как работает родитель
	Возврат СтруктураОбъекта;

КонецФункции // ЗначениеПараметраСКДВСтруктуру()

// Процедура - заполняет объект СКД ЗначениеПараметраКомпоновкиДанных из структуры описания объекта
// 
// Параметры:
//     Объект             - ЗначениеПараметраКомпоновкиДанных  - заполняемый объект
//     СтруктураОбъекта   - Структура                          - данные для заполнения объекта
//
Процедура ЗначениеПараметраСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ЗначениеПараметраКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("Значение") Тогда
		ВремЗначение = ЗначениеИзСтруктуры(СтруктураОбъекта.Значение);
		// Обработка случая пустого значения несериализуемого типа
		Если НЕ ВремЗначение = Неопределено ИЛИ ТипЗнч(Объект.Значение) = Тип("Неопределено") Тогда
			Объект.Значение = ВремЗначение;
		КонецЕсли;
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "ЗначенияВложенныхПараметров");

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");

	Если СтруктураОбъекта.Свойство("Параметр") Тогда
		Объект.Параметр = Новый ПараметрКомпоновкиДанных(СтруктураОбъекта.Параметр);
	КонецЕсли;

КонецПроцедуры // ЗначениеПараметраСКДИзСтруктуры()

// Процедура - заполняет коллекцию объектов СКД ЗначениеПараметраНастроекКомпоновкиДанных,
// ЗначениеПараметраКомпоновкиДанных из структуры описания объекта
// 
// Параметры:
//     ОбъектВладелец           - ОбъектСКД        - объект верхнего уровня, содержащий заполняемые коллекции,
//                                                для проверки доступных параметров
//     Объект                   - ОбъектСКД        - объект, содержащий заполняемую коллекцию
//     СтруктураОбъекта         - Структура        - данные для заполнения коллекции
//     ИмяКоллекцииПараметров   - Строка           - имя заполняемой коллекции
//
Процедура ЗначенияПараметровОбъектаСКДИзСтруктуры(ОбъектВладелец,
                                                  Объект,
                                                  СтруктураОбъекта,
                                                  ИмяКоллекцииПараметров = "Элементы")

	Если НЕ СтруктураОбъекта.Свойство(ИмяКоллекцииПараметров) Тогда
		Возврат;
	КонецЕсли;

	Для Каждого ТекЭлемент Из СтруктураОбъекта[ИмяКоллекцииПараметров] Цикл
		Если ОбъектВладелец.ДоступныеПараметры = Неопределено Тогда
			НовыйЭлемент = Объект[ИмяКоллекцииПараметров].Добавить();
			ЗначениеСКДИзСтруктуры(НовыйЭлемент, ТекЭлемент);
		Иначе	
			ТекПараметр = ОбъектВладелец.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных(ТекЭлемент.Параметр));
			Если ТекПараметр = Неопределено Тогда
				// Обработка десериализации СКД из новой версии платформы в старой версии
				Продолжить;
			КонецЕсли;
			ВремЗначение = ЗначениеИзСтруктуры(ТекЭлемент.Значение);
			// Обработка случая пустого значения несериализуемого типа
			Если НЕ ВремЗначение = Неопределено ИЛИ ТипЗнч(ТекПараметр.Значение) = Тип("Неопределено") Тогда
				ТекПараметр.Значение = ВремЗначение;
			КонецЕсли;
			ЗначенияПараметровОбъектаСКДИзСтруктуры(ОбъектВладелец, ТекПараметр, ТекЭлемент, "ЗначенияВложенныхПараметров");
			ТекПараметр.Использование = ТекЭлемент.Использование;
			Если ТипЗнч(ТекПараметр) = Тип("ЗначениеПараметраНастроекКомпоновкиДанных") Тогда
				ТекПараметр.ИдентификаторПользовательскойНастройки = ТекЭлемент.ИдентификаторПользовательскойНастройки;
				ТекПараметр.ПредставлениеПользовательскойНастройки = ТекЭлемент.ПредставлениеПользовательскойНастройки;
				ТекПараметр.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[ТекЭлемент.РежимОтображения];
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры // ЗначенияПараметровОбъектаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПараметрыРедактированияКомпоновкиДанных
// 
// Параметры:
//     Объект             - ПараметрыРедактированияКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ПараметрыРедактированияСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ПараметрыРедактированияКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПараметрыРедактированияКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Элементы", КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;

КонецФункции // ПараметрыРедактированияСКДВСтруктуру()

// Процедура - заполняет объект СКД ПараметрыРедактированияКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ПараметрыРедактированияКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                               - данные для заполнения объекта
//
Процедура ПараметрыРедактированияСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ПараметрыРедактированияКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	ЗначенияПараметровОбъектаСКДИзСтруктуры(Объект, Объект, СтруктураОбъекта);

КонецПроцедуры // ПараметрыРедактированияСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// СтрокаТаблицыОбластиКомпоновкиДанных
// 
// Параметры:
//     Объект             - СтрокаТаблицыОбластиКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция СтрокаТаблицыОбластиСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("СтрокаТаблицыОбластиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "СтрокаТаблицыОбластиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ИдентификаторТаблицы", Объект.ИдентификаторТаблицы);
	СтруктураОбъекта.Вставить("Ячейки"              , КоллекцияСКДВМассив(Объект.Ячейки));

	Возврат СтруктураОбъекта;

КонецФункции // СтрокаТаблицыОбластиСКДВСтруктуру()

// Процедура - заполняет объект СКД СтрокаТаблицыОбластиКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - СтрокаТаблицыОбластиКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                            - данные для заполнения объекта
//
Процедура СтрокаТаблицыОбластиСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("СтрокаТаблицыОбластиКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторТаблицы");

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Ячейки");

КонецПроцедуры // СтрокаТаблицыОбластиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ЯчейкаТаблицыОбластиКомпоновкиДанных
// 
// Параметры:
//     Объект             - ЯчейкаТаблицыОбластиКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ЯчейкаТаблицыОбластиСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ЯчейкаТаблицыОбластиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ЯчейкаТаблицыОбластиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Оформление", ЗначениеСКДВСтруктуру(Объект.Оформление));
	СтруктураОбъекта.Вставить("Элементы"  , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;

КонецФункции // ЯчейкаТаблицыОбластиСКДВСтруктуру()

// Процедура - заполняет объект СКД ЯчейкаТаблицыОбластиКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ЯчейкаТаблицыОбластиКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                            - данные для заполнения объекта
//
Процедура ЯчейкаТаблицыОбластиСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ЯчейкаТаблицыОбластиКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Оформление", Истина);

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы", Истина);

КонецПроцедуры // ЯчейкаТаблицыОбластиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ОформлениеЯчейкиТаблицыОбластиКомпоновкиДанных
// 
// Параметры:
//     Объект             - ОформлениеЯчейкиТаблицыОбластиКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ОформлениеЯчейкиТаблицыОбластиСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ОформлениеЯчейкиТаблицыОбластиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ОформлениеЯчейкиТаблицыОбластиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Элементы"  , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;

КонецФункции // ОформлениеЯчейкиТаблицыОбластиСКДВСтруктуру()

// Процедура - заполняет объект СКД ОформлениеЯчейкиТаблицыОбластиКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ОформлениеЯчейкиТаблицыОбластиКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                                      - данные для заполнения объекта
//
Процедура ОформлениеЯчейкиТаблицыОбластиСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ОформлениеЯчейкиТаблицыОбластиКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	ЗначенияПараметровОбъектаСКДИзСтруктуры(Объект, Объект, СтруктураОбъекта);

КонецПроцедуры // ОформлениеЯчейкиТаблицыОбластиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ОформлениеПоляОбластиКомпоновкиДанных
// 
// Параметры:
//     Объект             - ОформлениеПоляОбластиКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ОформлениеПоляОбластиСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ОформлениеПоляОбластиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ОформлениеПоляОбластиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Элементы"  , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;

КонецФункции // ОформлениеПоляОбластиСКДВСтруктуру()

// Процедура - заполняет объект СКД ОформлениеПоляОбластиКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ОформлениеПоляОбластиКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                             - данные для заполнения объекта
//
Процедура ОформлениеПоляОбластиСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ОформлениеПоляОбластиКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	ЗначенияПараметровОбъектаСКДИзСтруктуры(Объект, Объект, СтруктураОбъекта);

КонецПроцедуры // ОформлениеПоляОбластиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПараметрОбластиВыражениеКомпоновкиДанных
// 
// Параметры:
//     Объект             - ПараметрОбластиВыражениеКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ПараметрОбластиВыражениеСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ПараметрОбластиВыражениеКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПараметрОбластиВыражениеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"      , "ПараметрОбластиВыражениеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Имя"      , Объект.Имя);
	СтруктураОбъекта.Вставить("Выражение", Объект.Выражение);

	Возврат СтруктураОбъекта;

КонецФункции // ПараметрОбластиВыражениеСКДВСтруктуру()

// Процедура - заполняет объект СКД ПараметрОбластиВыражениеКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ПараметрОбластиВыражениеКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                                - данные для заполнения объекта
//
Процедура ПараметрОбластиВыражениеСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ПараметрОбластиВыражениеКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Выражение");

КонецПроцедуры // ПараметрОбластиВыражениеСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПараметрОбластиРасшифровкаКомпоновкиДанных
// 
// Параметры:
//     Объект             - ПараметрОбластиРасшифровкаКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ПараметрОбластиРасшифровкаСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ПараметрОбластиРасшифровкаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПараметрОбластиРасшифровкаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Имя"           , Объект.Имя);
	СтруктураОбъекта.Вставить("ВыраженияПолей", КоллекцияСКДВМассив(Объект.ВыраженияПолей));

	СтруктураОбъекта.Вставить("ОсновноеДействие",
	                          ПеречислениеСКДВСтроку(Объект.ОсновноеДействие));

	Возврат СтруктураОбъекта;

КонецФункции // ПараметрОбластиРасшифровкаСКДВСтруктуру()

// Процедура - заполняет объект СКД ПараметрОбластиРасшифровкаКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ПараметрОбластиРасшифровкаКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                                  - данные для заполнения объекта
//
Процедура ПараметрОбластиРасшифровкаСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ПараметрОбластиРасшифровкаКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "ВыраженияПолей");

	Если СтруктураОбъекта.Свойство("ОсновноеДействие") Тогда
		Объект.ОсновноеДействие = ДействиеОбработкиРасшифровкиКомпоновкиДанных[СтруктураОбъекта.ОсновноеДействие];
	КонецЕсли;

КонецПроцедуры // ПараметрОбластиРасшифровкаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ВыражениеПоляПараметраОбластиРасшифровкаКомпоновкиДанных
// 
// Параметры:
//     Объект             - ВыражениеПоляПараметраОбластиРасшифровкаКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ВыражениеПоляПараметраРасшифровкиСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ВыражениеПоляПараметраОбластиРасшифровкаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ВыражениеПоляПараметраОбластиРасшифровкаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Выражение", Объект.Выражение);
	СтруктураОбъекта.Вставить("Поле"     , Объект.Поле);

	Возврат СтруктураОбъекта;

КонецФункции // ВыражениеПоляПараметраРасшифровкиСКДВСтруктуру()

// Процедура - заполняет объект СКД ВыражениеПоляПараметраОбластиРасшифровкаКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ВыражениеПоляПараметраОбластиРасшифровкаКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                                                - данные для заполнения объекта
//
Процедура ВыражениеПоляПараметраРасшифровкиСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ВыражениеПоляПараметраОбластиРасшифровкаКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Выражение");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Поле");

КонецПроцедуры // ВыражениеПоляПараметраРасшифровкиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПолеОбластиКомпоновкиДанных
// 
// Параметры:
//     Объект             - ПолеОбластиКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ПолеОбластиСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ПолеОбластиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПолеОбластиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"       , "ПолеОбластиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Значение"  , ЗначениеВСтруктуру(Объект.Значение));
	СтруктураОбъекта.Вставить("Оформление", ЗначениеСКДВСтруктуру(Объект.Оформление));

	Возврат СтруктураОбъекта;

КонецФункции // ПолеОбластиСКДВСтруктуру()

// Процедура - заполняет объект СКД ПолеОбластиКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ПолеОбластиКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                   - данные для заполнения объекта
//
Процедура ПолеОбластиСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ПолеОбластиКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("Значение") Тогда
		Объект.Значение = ЗначениеИзСтруктуры(СтруктураОбъекта.Значение);
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Оформление", Истина);

КонецПроцедуры // ПолеОбластиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПолеНабораДанныхСхемыКомпоновкиДанных
// 
// Параметры:
//     Объект             - ПолеНабораДанныхСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ПолеНабораДанныхПолеСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ПолеНабораДанныхСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПолеНабораДанныхСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"      , "ПолеНабораДанныхСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ВыражениеПредставления"     , Объект.ВыражениеПредставления);
	СтруктураОбъекта.Вставить("ВыраженияУпорядочивания"    , КоллекцияСКДВМассив(Объект.ВыраженияУпорядочивания));
	СтруктураОбъекта.Вставить("Заголовок"                  , Объект.Заголовок);
	СтруктураОбъекта.Вставить("НаборДанныхПроверкиИерархии", Объект.НаборДанныхПроверкиИерархии);

	СтруктураОбъекта.Вставить("ОграничениеИспользования",
	                          ЗначениеСКДВСтруктуру(Объект.ОграничениеИспользования));
	СтруктураОбъекта.Вставить("ОграничениеИспользованияРеквизитов",
	                          ЗначениеСКДВСтруктуру(Объект.ОграничениеИспользованияРеквизитов));
	                          
	СтруктураОбъекта.Вставить("Оформление", ЗначениеСКДВСтруктуру(Объект.Оформление));
	СтруктураОбъекта.Вставить("ПараметрНабораДанныхПроверкиИерархии", Объект.ПараметрНабораДанныхПроверкиИерархии);

	СтруктураОбъекта.Вставить("ПараметрыРедактирования",
	                          ЗначениеСКДВСтруктуру(Объект.ПараметрыРедактирования));
	                          
	СтруктураОбъекта.Вставить("Поле"       , Объект.Поле);
	СтруктураОбъекта.Вставить("ПутьКДанным", Объект.ПутьКДанным);
	СтруктураОбъекта.Вставить("Роль"       , ЗначениеСКДВСтруктуру(Объект.Роль));
	СтруктураОбъекта.Вставить("ТипЗначения", ЗначениеВСтруктуру(Объект.ТипЗначения));
	 
	Возврат СтруктураОбъекта;

КонецФункции // ПолеНабораДанныхПолеСКДВСтруктуру()

// Процедура - заполняет объект СКД ПолеНабораДанныхСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ПолеНабораДанныхСхемыКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                             - данные для заполнения объекта
//
Процедура ПолеНабораДанныхПолеСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ПолеНабораДанныхСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ВыражениеПредставления");

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "ВыраженияУпорядочивания");

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Заголовок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "НаборДанныхПроверкиИерархии");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ОграничениеИспользования", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ОграничениеИспользованияРеквизитов", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Оформление", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПараметрНабораДанныхПроверкиИерархии");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПараметрыРедактирования", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Поле");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПутьКДанным");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Роль", Истина);

	Если СтруктураОбъекта.Свойство("ТипЗначения") Тогда
		Объект.ТипЗначения = ЗначениеИзСтруктуры(СтруктураОбъекта.ТипЗначения);
	КонецЕсли;

КонецПроцедуры // ПолеНабораДанныхПолеСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПапкаПолейНабораДанныхСхемыКомпоновкиДанных
// 
// Параметры:
//     Объект             - ПапкаПолейНабораДанныхСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ПолеНабораДанныхПапкаСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ПапкаПолейНабораДанныхСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПапкаПолейНабораДанныхСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"      , "ПапкаПолейНабораДанныхСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Заголовок", Объект.Заголовок);

	СтруктураОбъекта.Вставить("ОграничениеИспользования",
	                          ЗначениеСКДВСтруктуру(Объект.ОграничениеИспользования));

	СтруктураОбъекта.Вставить("ПутьКДанным", Объект.ПутьКДанным);

	Возврат СтруктураОбъекта;

КонецФункции // ПолеНабораДанныхПапкаСКДВСтруктуру()

// Процедура - заполняет объект СКД ПапкаПолейНабораДанныхСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ПапкаПолейНабораДанныхСхемыКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                                   - данные для заполнения объекта
//
Процедура ПолеНабораДанныхПапкаСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ПапкаПолейНабораДанныхСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Заголовок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ОграничениеИспользования", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПутьКДанным");

КонецПроцедуры // ПолеНабораДанныхПапкаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ВложенныйНаборДанныхСхемыКомпоновкиДанных
// 
// Параметры:
//     Объект             - ВложенныйНаборДанныхСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ПолеНабораДанныхВложенныйНаборСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ВложенныйНаборДанныхСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ВложенныйНаборДанныхСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"        , "ВложенныйНаборДанныхСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Заголовок"  , Объект.Заголовок);
	СтруктураОбъекта.Вставить("Поле"       , Объект.Поле);
	СтруктураОбъекта.Вставить("ПутьКДанным", Объект.ПутьКДанным);

	Возврат СтруктураОбъекта;

КонецФункции // ПолеНабораДанныхВложенныйНаборСКДВСтруктуру()

// Процедура - заполняет объект СКД ВложенныйНаборДанныхСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ВложенныйНаборДанныхСхемыКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                                 - данные для заполнения объекта
//
Процедура ПолеНабораДанныхВложенныйНаборСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ВложенныйНаборДанныхСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Заголовок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Поле");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПутьКДанным");

КонецПроцедуры // ПолеНабораДанныхВложенныйНаборСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ВыбранныеПоляКомпоновкиДанных
// 
// Параметры:
//     Объект             - ВыбранныеПоляКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ВыбранныеПоляСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ВыбранныеПоляКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ВыбранныеПоляКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));
	                          
	СтруктураОбъекта.Вставить("Элементы"    , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;

КонецФункции // ВыбранныеПоляСКДВСтруктуру()

// Процедура - заполняет объект СКД ВыбранныеПоляКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ВыбранныеПоляКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                     - данные для заполнения объекта
//
Процедура ВыбранныеПоляСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ВыбранныеПоляКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения =
			РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы", Истина);

КонецПроцедуры // ВыбранныеПоляСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ГруппаВыбранныхПолейКомпоновкиДанных
// 
// Параметры:
//     Объект             - ГруппаВыбранныхПолейКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ГруппаВыбранныхПолейСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ГруппаВыбранныхПолейКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ГруппаВыбранныхПолейКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"             , "ГруппаВыбранныхПолейКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Заголовок"       , Объект.Заголовок);
	СтруктураОбъекта.Вставить("Использование"   , Объект.Использование);
	СтруктураОбъекта.Вставить("Поле"            , ЗначениеСКДВСтруктуру(Объект.Поле));
	СтруктураОбъекта.Вставить("Расположение"    , ПеречислениеСКДВСтроку(Объект.Расположение));
	СтруктураОбъекта.Вставить("Элементы"        , КоллекцияСКДВМассив(Объект.Элементы));
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));
	// TODO: проверить родителя

	Возврат СтруктураОбъекта;

КонецФункции // ГруппаВыбранныхПолейСКДВСтруктуру()

// Процедура - заполняет объект СКД ГруппаВыбранныхПолейКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ГруппаВыбранныхПолейКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                            - данные для заполнения объекта
//
Процедура ГруппаВыбранныхПолейСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ГруппаВыбранныхПолейКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Заголовок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");

	Если СтруктураОбъекта.Свойство("Поле") Тогда
		Объект.Поле = Новый ПолеКомпоновкиДанных(СтруктураОбъекта.Поле.Имя);
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("Расположение") Тогда
		Объект.Расположение = РасположениеПоляКомпоновкиДанных[СтруктураОбъекта.Расположение];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения =
			РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;
	// TODO: проверить родителя

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы", Истина);

КонецПроцедуры // ГруппаВыбранныхПолейСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// АвтоВыбранноеПолеКомпоновкиДанных
// 
// Параметры:
//     Объект             - АвтоВыбранноеПолеКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция АвтоВыбранноеПолеСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "АвтоВыбранноеПолеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"          , "АвтоВыбранноеПолеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Использование", Объект.Использование);
	// TODO: проверить родителя

	Возврат СтруктураОбъекта;

КонецФункции // ВыбранноеПолеСКДВСтруктуру()

// Процедура - заполняет объект СКД АвтоВыбранноеПолеКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - АвтоВыбранноеПолеКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                         - данные для заполнения объекта
//
Процедура АвтоВыбранноеПолеСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	// TODO: проверить родителя

КонецПроцедуры // АвтоВыбранноеПолеСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ВыбранноеПолеКомпоновкиДанных
// 
// Параметры:
//     Объект             - ВыбранноеПолеКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ВыбранноеПолеСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ВыбранноеПолеКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ВыбранноеПолеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"             , "ВыбранноеПолеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Заголовок"       , Объект.Заголовок);
	СтруктураОбъекта.Вставить("Использование"   , Объект.Использование);
	СтруктураОбъекта.Вставить("Поле"            , ЗначениеСКДВСтруктуру(Объект.Поле));
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));
	// TODO: проверить родителя

	Возврат СтруктураОбъекта;

КонецФункции // ВыбранноеПолеСКДВСтруктуру()

// Процедура - заполняет объект СКД ВыбранноеПолеКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ВыбранноеПолеКомпоновкиДанных         - заполняемый объект
//     СтруктураОбъекта   - Структура                             - данные для заполнения объекта
//
Процедура ВыбранноеПолеСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ВыбранноеПолеКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Заголовок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");

	Если СтруктураОбъекта.Свойство("Поле") Тогда
		Объект.Поле = Новый ПолеКомпоновкиДанных(СтруктураОбъекта.Поле.Имя);
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения =
			РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;
	// TODO: проверить родителя

КонецПроцедуры // ВыбранноеПолеСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// РольПоляНабораДанныхКомпоновкиДанных
// 
// Параметры:
//     Объект             - РольПоляНабораДанныхКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция РольПоляНабораДанныхСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("РольПоляНабораДанныхКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "РольПоляНабораДанныхКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ВыражениеВидаСчета"      , Объект.ВыражениеВидаСчета);
	СтруктураОбъекта.Вставить("ГруппаОстатка"           , Объект.ГруппаОстатка);
	СтруктураОбъекта.Вставить("ИгнорироватьЗначенияNULL", Объект.ИгнорироватьЗначенияNULL);
	СтруктураОбъекта.Вставить("Измерение"               , Объект.Измерение);
	СтруктураОбъекта.Вставить("НомерПериода"            , Объект.НомерПериода);
	СтруктураОбъекта.Вставить("Обязательное"            , Объект.Обязательное);
	СтруктураОбъекта.Вставить("Остаток"                 , Объект.Остаток);
	СтруктураОбъекта.Вставить("ПолеСчета"               , Объект.ПолеСчета);
	СтруктураОбъекта.Вставить("РеквизитИзмерения"       , Объект.РеквизитИзмерения);
	СтруктураОбъекта.Вставить("РодительскоеИзмерение"   , Объект.РодительскоеИзмерение);
	СтруктураОбъекта.Вставить("Счет"                    , Объект.Счет);
	СтруктураОбъекта.Вставить("ТипБухгалтерскогоОстатка",
	                          ПеречислениеСКДВСтроку(Объект.ТипБухгалтерскогоОстатка));
	СтруктураОбъекта.Вставить("ТипОстатка"    , ПеречислениеСКДВСтроку(Объект.ТипОстатка));
	СтруктураОбъекта.Вставить("ТипПериода"    , ПеречислениеСКДВСтроку(Объект.ТипПериода));

	Возврат СтруктураОбъекта;

КонецФункции // РольПоляНабораДанныхСКДВСтруктуру()

// Процедура - заполняет объект СКД РольПоляНабораДанныхКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - РольПоляНабораДанныхКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                            - данные для заполнения объекта
//
Процедура РольПоляНабораДанныхСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("РольПоляНабораДанныхКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ВыражениеВидаСчета");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ГруппаОстатка");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИгнорироватьЗначенияNULL");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Измерение");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "НомерПериода");
	//@skip-error - в СП свойство указано как "Только чтение", но на самом деле свойство записывается
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Обязательное");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Остаток");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПолеСчета");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "РеквизитИзмерения");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "РодительскоеИзмерение");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Счет");

	Если СтруктураОбъекта.Свойство("ТипБухгалтерскогоОстатка") Тогда
		Объект.ТипБухгалтерскогоОстатка =
			ТипБухгалтерскогоОстаткаКомпоновкиДанных[СтруктураОбъекта.ТипБухгалтерскогоОстатка];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ТипОстатка") Тогда
		Объект.ТипОстатка = ТипОстаткаКомпоновкиДанных[СтруктураОбъекта.ТипОстатка];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ТипПериода") Тогда
		Объект.ТипПериода = ТипПериодаКомпоновкиДанных[СтруктураОбъекта.ТипПериода];
	КонецЕсли;

КонецПроцедуры // РольПоляНабораДанныхСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ГруппаЭлементовОтбораКомпоновкиДанных
// 
// Параметры:
//     Объект             - ГруппаЭлементовОтбораКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ГруппаЭлементовОтбораСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ГруппаЭлементовОтбораКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("Использование"   , Объект.Использование);
	СтруктураОбъекта.Вставить("Представление"   , Объект.Представление);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);
	СтруктураОбъекта.Вставить("Применение",
	                          ПеречислениеСКДВСтроку(Объект.Применение));
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));
	// TODO: проверить родителя
	СтруктураОбъекта.Вставить("ТипГруппы",
	                          ПеречислениеСКДВСтроку(Объект.ТипГруппы));

	СтруктураОбъекта.Вставить("Элементы"    , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;

КонецФункции // ГруппаЭлементовОтбораСКДВСтруктуру()

// Процедура - заполняет объект СКД ГруппаЭлементовОтбораКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ГруппаЭлементовОтбораКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                             - данные для заполнения объекта
//
Процедура ГруппаЭлементовОтбораСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Представление");

	Если СтруктураОбъекта.Свойство("Применение") Тогда
		Объект.Применение = ТипПримененияОтбораКомпоновкиДанных[СтруктураОбъекта.Применение];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ТипГруппы") Тогда
		Объект.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных[СтруктураОбъекта.ТипГруппы];
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы", Истина);

КонецПроцедуры // ГруппаЭлементовОтбораСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ЭлементОтбораКомпоновкиДанных
// 
// Параметры:
//     Объект             - ЭлементОтбораКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ЭлементОтбораСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ЭлементОтбораКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("Использование"   , Объект.Использование);
	СтруктураОбъекта.Вставить("ЛевоеЗначение"   , ЗначениеСКДВСтруктуру(Объект.ЛевоеЗначение));
	СтруктураОбъекта.Вставить("ПравоеЗначение"  , ЗначениеВСтруктуру(Объект.ПравоеЗначение));
	СтруктураОбъекта.Вставить("ВидСравнения"    , ПеречислениеСКДВСтроку(Объект.ВидСравнения));
	СтруктураОбъекта.Вставить("Представление"   , Объект.Представление);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);
	СтруктураОбъекта.Вставить("Применение",
	                          ПеречислениеСКДВСтроку(Объект.Применение));
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));
	// TODO: проверить родителя

	Возврат СтруктураОбъекта;

КонецФункции // ЭлементОтбораСКДВСтруктуру()

// Процедура - заполняет объект СКД ЭлементОтбораКомпоновкиДанных из структуры описания объекта
// 
// Параметры:
//     Объект             - ЭлементОтбораКомпоновкиДанных   - заполняемый объект
//     СтруктураОбъекта   - Структура                       - данные для заполнения объекта
//
Процедура ЭлементОтбораСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Представление");

	Если СтруктураОбъекта.Свойство("ЛевоеЗначение") Тогда
		Объект.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(СтруктураОбъекта.ЛевоеЗначение.Имя);
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ПравоеЗначение") Тогда
		Объект.ПравоеЗначение = ЗначениеИзСтруктуры(СтруктураОбъекта.ПравоеЗначение);
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ВидСравнения") Тогда
		Объект.ВидСравнения = ВидСравненияКомпоновкиДанных[СтруктураОбъекта.ВидСравнения];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("Применение") Тогда
		Объект.Применение = ТипПримененияОтбораКомпоновкиДанных[СтруктураОбъекта.Применение];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

КонецПроцедуры // ЭлементОтбораСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ОтборКомпоновкиДанных
// 
// Параметры:
//     Объект             - ОтборКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ОтборСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ОтборКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ОтборКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));

	СтруктураОбъекта.Вставить("Элементы"    , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;

КонецФункции // ОтборСКДВСтруктуру()

// Процедура - заполняет объект СКД ОтборКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ОтборКомпоновкиДанных   - заполняемый объект
//     СтруктураОбъекта   - Структура               - данные для заполнения объекта
//
Процедура ОтборСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ОтборКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы", Истина);

КонецПроцедуры // ОтборСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ЗначенияПараметровВыводаКомпоновкиДанных
// 
// Параметры:
//     Объект             - ЗначенияПараметровВыводаКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ЗначенияПараметровВыводаСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ЗначенияПараметровВыводаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ЗначенияПараметровВыводаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Элементы"    , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;

КонецФункции // ЗначенияПараметровВыводаСКДВСтруктуру()

// Процедура - заполняет объект СКД ЗначенияПараметровВыводаКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ЗначенияПараметровВыводаКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                                - данные для заполнения объекта
//
Процедура ЗначенияПараметровВыводаСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ЗначенияПараметровВыводаКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	ЗначенияПараметровОбъектаСКДИзСтруктуры(Объект, Объект, СтруктураОбъекта);

КонецПроцедуры // ЗначенияПараметровВыводаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ЗначенияПараметровДанныхКомпоновкиДанных
// 
// Параметры:
//     Объект             - ЗначенияПараметровДанныхКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ЗначенияПараметровДанныхСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ЗначенияПараметровДанныхКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ЗначенияПараметровДанныхКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Элементы"    , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;

КонецФункции // ЗначенияПараметровДанныхСКДВСтруктуру()

// Процедура - заполняет объект СКД ЗначенияПараметровДанныхКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ЗначенияПараметровДанныхКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                                - данные для заполнения объекта
//
Процедура ЗначенияПараметровДанныхСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ЗначенияПараметровДанныхКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	ЗначенияПараметровОбъектаСКДИзСтруктуры(Объект, Объект, СтруктураОбъекта);

КонецПроцедуры // ЗначенияПараметровДанныхСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПользовательскоеПолеВыражениеКомпоновкиДанных
// 
// Параметры:
//     Объект             - ПользовательскоеПолеВыражениеКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ПользовательскоеПолеВыражениеСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ПользовательскоеПолеВыражениеКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПользовательскоеПолеВыражениеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"          , "ПользовательскоеПолеВыражениеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Заголовок"    , Объект.Заголовок);
	СтруктураОбъекта.Вставить("Использование", Объект.Использование);
	СтруктураОбъекта.Вставить("ПутьКДанным"  , Объект.ПутьКДанным);

	СтруктураОбъекта.Вставить("ВыражениеДетальныхЗаписей", Объект.ПолучитьВыражениеДетальныхЗаписей());
	СтруктураОбъекта.Вставить("ВыражениеИтоговыхЗаписей" , Объект.ПолучитьВыражениеИтоговыхЗаписей());
	СтруктураОбъекта.Вставить("ПредставлениеВыраженияДетальныхЗаписей",
	                          Объект.ПолучитьПредставлениеВыраженияДетальныхЗаписей());
	СтруктураОбъекта.Вставить("ПредставлениеВыраженияИтоговыхЗаписей" ,
	                          Объект.ПолучитьПредставлениеВыраженияИтоговыхЗаписей());

	Возврат СтруктураОбъекта;

КонецФункции // ПользовательскоеПолеВыражениеСКДВСтруктуру()

// Процедура - заполняет объект СКД ПользовательскоеПолеВыражениеКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ПользовательскоеПолеВыражениеКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                                     - данные для заполнения объекта
//
Процедура ПользовательскоеПолеВыражениеСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ПользовательскоеПолеВыражениеКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Заголовок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");

	ВыражениеДетальныхЗаписей = "";
	Если СтруктураОбъекта.Свойство("ВыражениеДетальныхЗаписей") Тогда
		ВыражениеДетальныхЗаписей = СтруктураОбъекта.ВыражениеДетальныхЗаписей;
	КонецЕсли;

	ВыражениеИтоговыхЗаписей = "";
	Если СтруктураОбъекта.Свойство("ВыражениеИтоговыхЗаписей") Тогда
		ВыражениеИтоговыхЗаписей = СтруктураОбъекта.ВыражениеИтоговыхЗаписей;
	КонецЕсли;

	Объект.УстановитьВыражения(ВыражениеДетальныхЗаписей, ВыражениеИтоговыхЗаписей);

	ПредставлениеВыраженияДетальныхЗаписей = "";
	Если СтруктураОбъекта.Свойство("ПредставлениеВыраженияДетальныхЗаписей") Тогда
		ПредставлениеВыраженияДетальныхЗаписей = СтруктураОбъекта.ПредставлениеВыраженияДетальныхЗаписей;
	КонецЕсли;

	ПредставлениеВыраженияИтоговыхЗаписей = "";
	Если СтруктураОбъекта.Свойство("ПредставлениеВыраженияИтоговыхЗаписей") Тогда
		ПредставлениеВыраженияИтоговыхЗаписей = СтруктураОбъекта.ПредставлениеВыраженияИтоговыхЗаписей;
	КонецЕсли;

	Объект.УстановитьПредставлениеВыражений(ПредставлениеВыраженияДетальныхЗаписей,
	                                        ПредставлениеВыраженияИтоговыхЗаписей);

КонецПроцедуры // ПользовательскоеПолеВыражениеСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПользовательскоеПолеВыборКомпоновкиДанных
// 
// Параметры:
//     Объект             - ПользовательскоеПолеВыборКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ПользовательскоеПолеВыборСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ПользовательскоеПолеВыборКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПользовательскоеПолеВыборКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"          , "ПользовательскоеПолеВыборКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Заголовок"    , Объект.Заголовок);
	СтруктураОбъекта.Вставить("Использование", Объект.Использование);
	СтруктураОбъекта.Вставить("ПутьКДанным"  , Объект.ПутьКДанным);

	СтруктураОбъекта.Вставить("Варианты"     , ЗначениеСКДВСтруктуру(Объект.Варианты));

	Возврат СтруктураОбъекта;

КонецФункции // ПользовательскоеПолеВыборСКДВСтруктуру()

// Процедура - заполняет объект СКД ПользовательскоеПолеВыборКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ПользовательскоеПолеВыборКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                                 - данные для заполнения объекта
//
Процедура ПользовательскоеПолеВыборСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ПользовательскоеПолеВыборКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Заголовок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Варианты", Истина);

КонецПроцедуры // ПользовательскоеПолеВыборСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПользовательскиеПоляКомпоновкиДанных
// 
// Параметры:
//     Объект             - ПользовательскиеПоляКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ПользовательскиеПоляСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ПользовательскиеПоляКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПользовательскиеПоляКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Элементы"    , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;

КонецФункции // ПользовательскиеПоляСКДВСтруктуру()

// Процедура - заполняет объект СКД ПользовательскиеПоляКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ПользовательскиеПоляКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                            - данные для заполнения объекта
//
Процедура ПользовательскиеПоляСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ПользовательскиеПоляКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы", Истина);

КонецПроцедуры // ПользовательскиеПоляСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ВариантПользовательскогоПоляВыборКомпоновкиДанных
// 
// Параметры:
//     Объект             - ВариантПользовательскогоПоляВыборКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ВариантПользовательскогоПоляВыбораСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ВариантПользовательскогоПоляВыборКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ВариантПользовательскогоПоляВыборКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Значение"     , ЗначениеВСтруктуру(Объект.Значение));
	СтруктураОбъекта.Вставить("Использование", Объект.Использование);
	СтруктураОбъекта.Вставить("Представление", Объект.Представление);
	СтруктураОбъекта.Вставить("Отбор"        , ЗначениеСКДВСтруктуру(Объект.Отбор));

	Возврат СтруктураОбъекта;

КонецФункции // ВариантПользовательскогоПоляВыбораСКДВСтруктуру()

// Процедура - заполняет объект СКД ВариантПользовательскогоПоляВыборКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ВариантПользовательскогоПоляВыборКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                                         - данные для заполнения объекта
//
Процедура ВариантПользовательскогоПоляВыбораСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ВариантПользовательскогоПоляВыборКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");

	Если СтруктураОбъекта.Свойство("Значение") Тогда
		Объект.Значение = ЗначениеИзСтруктуры(СтруктураОбъекта.Значение);
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Представление");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Отбор", Истина);

КонецПроцедуры // ВариантПользовательскогоПоляВыбораСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ВариантыПользовательскогоПоляВыборКомпоновкиДанных
// 
// Параметры:
//     Объект             - ВариантыПользовательскогоПоляВыборКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ВариантыПользовательскогоПоляВыбораСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ВариантыПользовательскогоПоляВыборКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ВариантыПользовательскогоПоляВыборКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Элементы"    , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;

КонецФункции // ВариантыПользовательскогоПоляВыбораСКДВСтруктуру()

// Процедура - заполняет объект СКД ВариантыПользовательскогоПоляВыборКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ВариантыПользовательскогоПоляВыборКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                                          - данные для заполнения объекта
//
Процедура ВариантыПользовательскогоПоляВыбораСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ВариантыПользовательскогоПоляВыборКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы");

КонецПроцедуры // ВариантыПользовательскогоПоляВыбораСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// АвтоЭлементПорядкаКомпоновкиДанных
// 
// Параметры:
//     Объект             - АвтоЭлементПорядкаКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция АвтоЭлементПорядкаСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("АвтоЭлементПорядкаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "АвтоЭлементПорядкаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"   , "АвтоЭлементПорядкаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Использование"   , Объект.Использование);

	Возврат СтруктураОбъекта;

КонецФункции // АвтоЭлементПорядкаСКДВСтруктуру()

// Процедура - заполняет объект СКД АвтоЭлементПорядкаКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - АвтоЭлементПорядкаКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                          - данные для заполнения объекта
//
Процедура АвтоЭлементПорядкаСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("АвтоЭлементПорядкаКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");

КонецПроцедуры // АвтоЭлементПорядкаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ЭлементПорядкаКомпоновкиДанных
// 
// Параметры:
//     Объект             - ЭлементПорядкаКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ЭлементПорядкаСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ЭлементПорядкаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ЭлементПорядкаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"   , "ЭлементПорядкаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Использование"   , Объект.Использование);
	СтруктураОбъекта.Вставить("Поле"            , ЗначениеСКДВСтруктуру(Объект.Поле));
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));
	СтруктураОбъекта.Вставить("ТипУпорядочивания",
	                          ПеречислениеСКДВСтроку(Объект.ТипУпорядочивания));

	Возврат СтруктураОбъекта;

КонецФункции // ЭлементПорядкаСКДВСтруктуру()

// Процедура - заполняет объекты СКД ЭлементПорядкаКомпоновкиДанных из структуры описания объекта
// 
// Параметры:
//     Объект             - ЭлементПорядкаКомпоновкиДанных   - заполняемый объект
//     СтруктураОбъекта   - Структура                        - данные для заполнения объекта
//
Процедура ЭлементПорядкаСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ЭлементПорядкаКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");

	Если СтруктураОбъекта.Свойство("Поле") Тогда
		Объект.Поле = Новый ПолеКомпоновкиДанных(СтруктураОбъекта.Поле.Имя);
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ТипУпорядочивания") Тогда
		Объект.ТипУпорядочивания =  НаправлениеСортировкиКомпоновкиДанных[СтруктураОбъекта.ТипУпорядочивания];
	КонецЕсли;

КонецПроцедуры // ЭлементПорядкаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПорядокКомпоновкиДанных
// 
// Параметры:
//     Объект             - ПорядокКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ПорядокСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ПорядокКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПорядокКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));

	СтруктураОбъекта.Вставить("Элементы"    , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;

КонецФункции // ПорядокСКДВСтруктуру()

// Процедура - заполняет объект СКД ПорядокКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ПорядокКомпоновкиДанных   - заполняемый объект
//     СтруктураОбъекта   - Структура                 - данные для заполнения объекта
//
Процедура ПорядокСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ПорядокКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы", Истина);

КонецПроцедуры // ПорядокСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// НастройкиВложенногоОбъектаКомпоновкиДанных
// 
// Параметры:
//     Объект             - НастройкиВложенногоОбъектаКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция НастройкиВложенногоОбъектаСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "НастройкиВложенногоОбъектаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"                 , "НастройкиВложенногоОбъектаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Идентификатор"       , Объект.Идентификатор);
	СтруктураОбъекта.Вставить("ИдентификаторОбъекта", Объект.ИдентификаторОбъекта);
	СтруктураОбъекта.Вставить("Имя"                 , Объект.Имя);
	СтруктураОбъекта.Вставить("Использование"       , Объект.Использование);

	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));
	// TODO: проверить родителя
	СтруктураОбъекта.Вставить("Настройки", ЗначениеСКДВСтруктуру(Объект.Настройки));

	Возврат СтруктураОбъекта;

КонецФункции // НастройкиВложенногоОбъектаСКДВСтруктуру()

// Процедура - заполняет объект СКД НастройкиВложенногоОбъектаКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - НастройкиВложенногоОбъектаКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                                  - данные для заполнения объекта
//
Процедура НастройкиВложенногоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");

	Если СтруктураОбъекта.Свойство("ИдентификаторОбъекта") Тогда
		Объект.УстановитьИдентификатор(СтруктураОбъекта.ИдентификаторОбъекта);
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Настройки", Истина);

КонецПроцедуры // НастройкиВложенногоОбъектаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ГруппировкаКомпоновкиДанных
// 
// Параметры:
//     Объект             - ГруппировкаКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ГруппировкаСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	ТипЗначения = ТипЗнч(Объект);

	Если НЕ ТипЗначения = Тип("ГруппировкаКомпоновкиДанных")
		И НЕ ТипЗначения = Тип("ГруппировкаТаблицыКомпоновкиДанных") Тогда
		 СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ГруппировкаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"             , "ГруппировкаКомпоновкиДанных");

	Если ТипЗначения = Тип("ГруппировкаТаблицыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип"       , "ГруппировкаТаблицыКомпоновкиДанных");
		СтруктураОбъекта.Вставить("Тип"         , "ГруппировкаТаблицыКомпоновкиДанных");
	КонецЕсли;

	СтруктураОбъекта.Вставить("Идентификатор"   , Объект.Идентификатор);
	СтруктураОбъекта.Вставить("Имя"             , Объект.Имя);
	СтруктураОбъекта.Вставить("Использование"   , Объект.Использование);

	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);

	СтруктураОбъекта.Вставить("Выбор"             , ЗначениеСКДВСтруктуру(Объект.Выбор));
	СтруктураОбъекта.Вставить("Отбор"             , ЗначениеСКДВСтруктуру(Объект.Отбор));
	СтруктураОбъекта.Вставить("ПараметрыВывода"   , ЗначениеСКДВСтруктуру(Объект.ПараметрыВывода));
	СтруктураОбъекта.Вставить("ПоляГруппировки"   , ЗначениеСКДВСтруктуру(Объект.ПоляГруппировки));
	СтруктураОбъекта.Вставить("Порядок"           , ЗначениеСКДВСтруктуру(Объект.Порядок));
	СтруктураОбъекта.Вставить("УсловноеОформление", ЗначениеСКДВСтруктуру(Объект.УсловноеОформление));
	СтруктураОбъекта.Вставить("РежимОтображения"  , ПеречислениеСКДВСтроку(Объект.РежимОтображения));

	// TODO: проверить родителя
	СтруктураОбъекта.Вставить("Состояние",
	                          ПеречислениеСКДВСтроку(Объект.Состояние));
	                          
	СтруктураОбъекта.Вставить("Структура"    , КоллекцияСКДВМассив(Объект.Структура));

 	Возврат СтруктураОбъекта;

КонецФункции // ГруппировкаСКДВСтруктуру()

// Процедура - заполняет объект СКД ГруппировкаКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ГруппировкаКомпоновкиДанных   - заполняемый объект
//     СтруктураОбъекта   - Структура                     - данные для заполнения объекта
//
Процедура ГруппировкаСКДИзСтруктуры(Объект, СтруктураОбъекта)

	ТипЗначения = ТипЗнч(Объект);

	Если НЕ ТипЗначения = Тип("ГруппировкаКомпоновкиДанных")
		И НЕ ТипЗначения = Тип("ГруппировкаТаблицыКомпоновкиДанных") Тогда
		 Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Выбор", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Отбор", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПараметрыВывода", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПоляГруппировки", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Порядок", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "УсловноеОформление", Истина);

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("Состояние") Тогда
		Объект.Состояние = СостояниеЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.Состояние];
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Структура", Истина);

КонецПроцедуры // ГруппировкаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ТаблицаКомпоновкиДанных
// 
// Параметры:
//     Объект             - ТаблицаКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ТаблицаСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ТаблицаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ТаблицаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"             , "ТаблицаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Идентификатор"   , Объект.Идентификатор);
	СтруктураОбъекта.Вставить("Имя"             , Объект.Имя);
	СтруктураОбъекта.Вставить("Использование"   , Объект.Использование);

	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);

	СтруктураОбъекта.Вставить("Выбор"             , ЗначениеСКДВСтруктуру(Объект.Выбор));
	СтруктураОбъекта.Вставить("ПараметрыВывода"   , ЗначениеСКДВСтруктуру(Объект.ПараметрыВывода));
	СтруктураОбъекта.Вставить("УсловноеОформление", ЗначениеСКДВСтруктуру(Объект.УсловноеОформление));
	СтруктураОбъекта.Вставить("РежимОтображения"  , ПеречислениеСКДВСтроку(Объект.РежимОтображения));
	// TODO: проверить родителя
	                          
	СтруктураОбъекта.Вставить("Колонки", КоллекцияСКДВМассив(Объект.Колонки));
	СтруктураОбъекта.Вставить("Строки" , КоллекцияСКДВМассив(Объект.Строки));

	Возврат СтруктураОбъекта;

КонецФункции // ТаблицаСКДВСтруктуру()

// Процедура - заполняет объект СКД ТаблицаКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ТаблицаКомпоновкиДанных   - заполняемый объект
//     СтруктураОбъекта   - Структура                 - данные для заполнения объекта
//
Процедура ТаблицаСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ТаблицаКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Выбор", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПараметрыВывода", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "УсловноеОформление", Истина);

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Колонки");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Строки");

КонецПроцедуры // ТаблицаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ДиаграммаКомпоновкиДанных
// 
// Параметры:
//     Объект             - ДиаграммаКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ДиаграммаСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ДиаграммаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ДиаграммаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"             , "ДиаграммаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Идентификатор"   , Объект.Идентификатор);
	СтруктураОбъекта.Вставить("Имя"             , Объект.Имя);
	СтруктураОбъекта.Вставить("Использование"   , Объект.Использование);

	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);
	                          
	СтруктураОбъекта.Вставить("Выбор"             , ЗначениеСКДВСтруктуру(Объект.Выбор));
	СтруктураОбъекта.Вставить("ПараметрыВывода"   , ЗначениеСКДВСтруктуру(Объект.ПараметрыВывода));
	СтруктураОбъекта.Вставить("УсловноеОформление", ЗначениеСКДВСтруктуру(Объект.УсловноеОформление));
	СтруктураОбъекта.Вставить("РежимОтображения"  , ПеречислениеСКДВСтроку(Объект.РежимОтображения));

	// TODO: проверить родителя
	                          
	СтруктураОбъекта.Вставить("Серии" , КоллекцияСКДВМассив(Объект.Серии));
	СтруктураОбъекта.Вставить("Точки" , КоллекцияСКДВМассив(Объект.Точки));

	Возврат СтруктураОбъекта;

КонецФункции // ДиаграммаСКДВСтруктуру()

// Процедура - заполняет объект СКД ДиаграммаКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ДиаграммаКомпоновкиДанных   - заполняемый объект
//     СтруктураОбъекта   - Структура                   - данные для заполнения объекта
//
Процедура ДиаграммаСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ДиаграммаКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Выбор", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПараметрыВывода", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "УсловноеОформление", Истина);

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Серии");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Точки");

КонецПроцедуры // ДиаграммаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// АвтоПолеГруппировкиКомпоновкиДанных
// 
// Параметры:
//     Объект             - АвтоПолеГруппировкиКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция АвтоПолеГруппировкиСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("АвтоПолеГруппировкиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "АвтоПолеГруппировкиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"          , "АвтоПолеГруппировкиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Использование", Объект.Использование);

	Возврат СтруктураОбъекта;

КонецФункции // АвтоПолеГруппировкиСКДВСтруктуру()

// Процедура - заполняет объект СКД АвтоПолеГруппировкиКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - АвтоПолеГруппировкиКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                           - данные для заполнения объекта
//
Процедура АвтоПолеГруппировкиСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("АвтоПолеГруппировкиКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");

КонецПроцедуры // АвтоПолеГруппировкиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПолеГруппировкиКомпоновкиДанных
// 
// Параметры:
//     Объект             - ПолеГруппировкиКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ПолеГруппировкиСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ПолеГруппировкиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПолеГруппировкиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"           , "ПолеГруппировкиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Использование" , Объект.Использование);
	СтруктураОбъекта.Вставить("НачалоПериода" , ?(ТипЗнч(Объект.НачалоПериода) = Тип("ПолеКомпоновкиДанных"),
	                                              ЗначениеСКДВСтруктуру(Объект.НачалоПериода),
	                                              Объект.НачалоПериода));
	СтруктураОбъекта.Вставить("КонецПериода"  , ?(ТипЗнч(Объект.КонецПериода) = Тип("ПолеКомпоновкиДанных"),
	                                              ЗначениеСКДВСтруктуру(Объект.КонецПериода),
	                                              Объект.КонецПериода));
	СтруктураОбъекта.Вставить("Поле"          , ЗначениеСКДВСтруктуру(Объект.Поле));
	СтруктураОбъекта.Вставить("ТипГруппировки", ПеречислениеСКДВСтроку(Объект.ТипГруппировки));
	СтруктураОбъекта.Вставить("ТипДополнения" , ПеречислениеСКДВСтроку(Объект.ТипДополнения));

	Возврат СтруктураОбъекта;

КонецФункции // ПолеГруппировкиСКДВСтруктуру()

// Процедура - заполняет объекты СКД ПолеГруппировкиКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ПолеГруппировкиКомпоновкиДанных   - заполняемый объект
//     СтруктураОбъекта   - Структура                         - данные для заполнения объекта
//
Процедура ПолеГруппировкиСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ПолеГруппировкиКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");

	Если СтруктураОбъекта.Свойство("НачалоПериода") Тогда
		Если ТипЗнч(СтруктураОбъекта.НачалоПериода) = Тип("Строка") Тогда
			Объект.НачалоПериода = Новый ПолеКомпоновкиДанных(СтруктураОбъекта.НачалоПериода.Имя);
		ИначеЕсли ТипЗнч(СтруктураОбъекта.НачалоПериода) = Тип("Дата") Тогда
			Объект.НачалоПериода = СтруктураОбъекта.НачалоПериода;
		Иначе
			ПоказатьСообщение(СтрШаблонВнутр("Неизвестный тип поля ""НачалоПериода"": %1", СтруктураОбъекта.НачалоПериода));
		КонецЕсли;
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("КонецПериода") Тогда
		Если ТипЗнч(СтруктураОбъекта.КонецПериода) = Тип("Строка") Тогда
			Объект.КонецПериода = Новый ПолеКомпоновкиДанных(СтруктураОбъекта.КонецПериода.Имя);
		ИначеЕсли ТипЗнч(СтруктураОбъекта.КонецПериода) = Тип("Дата") Тогда
			Объект.КонецПериода = СтруктураОбъекта.КонецПериода;
		Иначе
			ПоказатьСообщение(СтрШаблонВнутр("Неизвестный тип поля ""КонецПериода"": %1", СтруктураОбъекта.НачалоПериода));
		КонецЕсли;
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("Поле") Тогда
		Объект.Поле = Новый ПолеКомпоновкиДанных(СтруктураОбъекта.Поле.Имя);
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ТипГруппировки") Тогда
		Объект.ТипГруппировки = ТипГруппировкиКомпоновкиДанных[СтруктураОбъекта.ТипГруппировки];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ТипДополнения") Тогда
		Объект.ТипДополнения = ТипДополненияПериодаКомпоновкиДанных[СтруктураОбъекта.ТипДополнения];
	КонецЕсли;

КонецПроцедуры // ПолеГруппировкиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПоляГруппировкиКомпоновкиДанных
// 
// Параметры:
//     Объект             - ПоляГруппировкиКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ПоляГруппировкиСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ПоляГруппировкиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПоляГруппировкиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Элементы" , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;

КонецФункции // ПоляГруппировкиСКДВСтруктуру()

// Процедура - заполняет объект СКД ПоляГруппировкиКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ПоляГруппировкиКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                       - данные для заполнения объекта
//
Процедура ПоляГруппировкиСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ПоляГруппировкиКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы", Истина);

КонецПроцедуры // ПоляГруппировкиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных, ЗначенияПараметровВыводаГруппировкиТаблицыКомпоновкиДанных,
// ЗначенияПараметровВыводаГруппировкиДиаграммыКомпоновкиДанных
// 
// Параметры:
//     Объект             - ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных,          - заполняемый объект
//                       ЗначенияПараметровВыводаГруппировкиТаблицыКомпоновкиДанных
//                       ЗначенияПараметровВыводаГруппировкиДиаграммыКомпоновкиДанных
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ЗначенияПараметровВыводаГруппировкиСКДВСтруктуру(Объект)

	ТипЗначения = ТипЗнч(Объект);

	СтруктураОбъекта = Новый Структура();

	Если ТипЗначения = Тип("ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных");
	ИначеЕсли ТипЗначения = Тип("ЗначенияПараметровВыводаГруппировкиТаблицыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "ЗначенияПараметровВыводаГруппировкиТаблицыКомпоновкиДанных");
	ИначеЕсли ТипЗначения = Тип("ЗначенияПараметровВыводаГруппировкиДиаграммыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "ЗначенияПараметровВыводаГруппировкиДиаграммыКомпоновкиДанных");
	Иначе
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("Элементы", КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;

КонецФункции // ЗначенияПараметровВыводаГруппировкиСКДВСтруктуру()

// Процедура - заполняет объекты СКД ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных,
// ЗначенияПараметровВыводаГруппировкиТаблицыКомпоновкиДанных,
// ЗначенияПараметровВыводаГруппировкиДиаграммыКомпоновкиДанных из структуры описания объекта
// 
// Параметры:
//     Объект             - ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных           - заполняемый объект
//                       ЗначенияПараметровВыводаГруппировкиТаблицыКомпоновкиДанных
//                       ЗначенияПараметровВыводаГруппировкиДиаграммыКомпоновкиДанных
//     СтруктураОбъекта   - Структура                                                     - данные для заполнения объекта
//
Процедура ЗначенияПараметровВыводаГруппировкиСКДИзСтруктуры(Объект, СтруктураОбъекта)

	ТипЗначения = ТипЗнч(Объект);

	Если НЕ (ТипЗначения = Тип("ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных")
	 ИЛИ ТипЗначения = Тип("ЗначенияПараметровВыводаГруппировкиТаблицыКомпоновкиДанных")
	 ИЛИ ТипЗначения = Тип("ЗначенияПараметровВыводаГруппировкиДиаграммыКомпоновкиДанных")) Тогда
		Возврат;
	КонецЕсли;

	ЗначенияПараметровОбъектаСКДИзСтруктуры(Объект, Объект, СтруктураОбъекта);

КонецПроцедуры // ЗначенияПараметровВыводаГруппировкиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ЭлементУсловногоОформленияКомпоновкиДанных
// 
// Параметры:
//     Объект             - ЭлементУсловногоОформленияКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ЭлементУсловногоОформленияСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ЭлементУсловногоОформленияКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ЭлементУсловногоОформленияКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Использование", Объект.Использование);

	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));

	СтруктураОбъекта.Вставить("ИспользоватьВГруппировке",
	                          ПеречислениеСКДВСтроку(Объект.ИспользоватьВГруппировке));
	СтруктураОбъекта.Вставить("ИспользоватьВЗаголовке",
	                          ПеречислениеСКДВСтроку(Объект.ИспользоватьВЗаголовке));
	СтруктураОбъекта.Вставить("ИспользоватьВЗаголовкеПолей",
	                          ПеречислениеСКДВСтроку(Объект.ИспользоватьВЗаголовкеПолей));
	СтруктураОбъекта.Вставить("ИспользоватьВИерархическойГруппировке",
	                          ПеречислениеСКДВСтроку(Объект.ИспользоватьВИерархическойГруппировке));
	СтруктураОбъекта.Вставить("ИспользоватьВОбщемИтоге",
	                          ПеречислениеСКДВСтроку(Объект.ИспользоватьВОбщемИтоге));
	СтруктураОбъекта.Вставить("ИспользоватьВОтборе",
	                          ПеречислениеСКДВСтроку(Объект.ИспользоватьВОтборе));
	СтруктураОбъекта.Вставить("ИспользоватьВПараметрах",
	                          ПеречислениеСКДВСтроку(Объект.ИспользоватьВПараметрах));

	СтруктураОбъекта.Вставить("Отбор"     , ЗначениеСКДВСтруктуру(Объект.Отбор));
	СтруктураОбъекта.Вставить("Оформление", ЗначениеСКДВСтруктуру(Объект.Оформление));
	СтруктураОбъекта.Вставить("Поля"      , ЗначениеСКДВСтруктуру(Объект.Поля));
 
	СтруктураОбъекта.Вставить("Представление", Объект.Представление);

	Возврат СтруктураОбъекта;

КонецФункции // ЭлементУсловногоОформленияСКДВСтруктуру()

// Процедура - заполняет объект СКД ЭлементУсловногоОформленияКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ЭлементУсловногоОформленияКомпоновкиДанных  - заполняемый объект
//     СтруктураОбъекта   - Структура                                   - данные для заполнения объекта
//
Процедура ЭлементУсловногоОформленияСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ЭлементУсловногоОформленияКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Представление");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Отбор", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Оформление", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Поля", Истина);

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ИспользоватьВГруппировке") Тогда
		Объект.ИспользоватьВГруппировке =
			ИспользованиеУсловногоОформленияКомпоновкиДанных[СтруктураОбъекта.ИспользоватьВГруппировке];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ИспользоватьВЗаголовке") Тогда
		Объект.ИспользоватьВЗаголовке =
			ИспользованиеУсловногоОформленияКомпоновкиДанных[СтруктураОбъекта.ИспользоватьВЗаголовке];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ИспользоватьВЗаголовкеПолей") Тогда
		Объект.ИспользоватьВЗаголовкеПолей =
			ИспользованиеУсловногоОформленияКомпоновкиДанных[СтруктураОбъекта.ИспользоватьВЗаголовкеПолей];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ИспользоватьВИерархическойГруппировке") Тогда
		Объект.ИспользоватьВИерархическойГруппировке =
			ИспользованиеУсловногоОформленияКомпоновкиДанных[СтруктураОбъекта.ИспользоватьВИерархическойГруппировке];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ИспользоватьВОбщемИтоге") Тогда
		Объект.ИспользоватьВОбщемИтоге =
			ИспользованиеУсловногоОформленияКомпоновкиДанных[СтруктураОбъекта.ИспользоватьВОбщемИтоге];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ИспользоватьВОтборе") Тогда
		Объект.ИспользоватьВОтборе =
			ИспользованиеУсловногоОформленияКомпоновкиДанных[СтруктураОбъекта.ИспользоватьВОтборе];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ИспользоватьВПараметрах") Тогда
		Объект.ИспользоватьВПараметрах =
			ИспользованиеУсловногоОформленияКомпоновкиДанных[СтруктураОбъекта.ИспользоватьВПараметрах];
	КонецЕсли;

КонецПроцедуры // ЭлементУсловногоОформленияСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// УсловноеОформлениеКомпоновкиДанных
// 
// Параметры:
//     Объект             - УсловноеОформлениеКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция УсловноеОформлениеСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("УсловноеОформлениеКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "УсловноеОформлениеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));

	СтруктураОбъекта.Вставить("Элементы", КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;

КонецФункции // УсловноеОформлениеСКДВСтруктуру()

// Процедура - заполняет объект СКД УсловноеОформлениеКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - УсловноеОформлениеКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                          - данные для заполнения объекта
//
Процедура УсловноеОформлениеСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("УсловноеОформлениеКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы");

КонецПроцедуры // УсловноеОформлениеСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ОформляемоеПолеКомпоновкиДанных
// 
// Параметры:
//     Объект             - ОформляемоеПолеКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ОформляемоеПолеСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ОформляемоеПолеКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ОформляемоеПолеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Использование", Объект.Использование);
	СтруктураОбъекта.Вставить("Поле"         , ЗначениеСКДВСтруктуру(Объект.Поле));

	Возврат СтруктураОбъекта;

КонецФункции // ОформляемоеПолеСКДВСтруктуру()

// Процедура - заполняет объект СКД ОформляемоеПолеКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ОформляемоеПолеКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                       - данные для заполнения объекта
//
Процедура ОформляемоеПолеСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ОформляемоеПолеКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");

	Если СтруктураОбъекта.Свойство("Поле") Тогда
		Объект.Поле = Новый ПолеКомпоновкиДанных(СтруктураОбъекта.Поле.Имя);
	КонецЕсли;

КонецПроцедуры // ОформляемоеПолеСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ОформляемыеПоляКомпоновкиДанных
// 
// Параметры:
//     Объект             - ОформляемыеПоляКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ОформляемыеПоляСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ОформляемыеПоляКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ОформляемыеПоляКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Элементы", КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;

КонецФункции // ОформляемыеПоляСКДВСтруктуру()

// Процедура - заполняет объект СКД ОформляемыеПоляКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ОформляемыеПоляКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                       - данные для заполнения объекта
//
Процедура ОформляемыеПоляСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ОформляемыеПоляКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы");

КонецПроцедуры // ОформляемыеПоляСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПолеКомпоновкиДанных
// 
// Параметры:
//     Объект             - ОформляемыеПоляКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ПолеСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("ПолеКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПолеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Имя", СокрЛП(Объект));

	Возврат СтруктураОбъекта;

КонецФункции // ПолеСКДВСтруктуру()

// Процедура - заполняет объект СКД ПолеКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
//     Объект             - ОформляемыеПоляКомпоновкиДанных - заполняемый объект
//     СтруктураОбъекта   - Структура                       - данные для заполнения объекта
//
Процедура ПолеСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если НЕ ТипЗнч(Объект) = Тип("ПолеКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	Объект = Новый ПолеКомпоновкиДанных(СтруктураОбъекта.Имя);

КонецПроцедуры // ПолеСКДИзСтруктуры()

#КонецОбласти // ПреобразованияСКДПроцедурыПреобразованияОбъектов

#Область ПреобразованияСКДСлужебныеПроцедурыИФункции

// Функция - заполняет и возвращает структуру описания объекта СКД
// 
// Параметры:
//     Объект             - <Объект СКД>     - преобразуемый объект
//
// Возвращаемое значение:
//     Структура          - структура описания объекта
//
Функция ЗначениеСКДВСтруктуру(Объект)

	ТипЗначения = ТипЗнч(Объект);
	
	Если ТипЗначения = Тип("СхемаКомпоновкиДанных") Тогда
		Возврат СКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("НастройкиКомпоновкиДанных") Тогда
		Возврат НастройкиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ВариантНастроекКомпоновкиДанных") Тогда
		Возврат ВариантНастроекСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ВложеннаяСхемаКомпоновкиДанных") Тогда
		Возврат ВложеннаяСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ВычисляемоеПолеСхемыКомпоновкиДанных") Тогда
		Возврат ВычисляемоеПолеСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ИсточникДанныхСхемыКомпоновкиДанных") Тогда
		Возврат ИсточникДанныхСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ОписаниеМакетаСхемыКомпоновкиДанных") Тогда
		Возврат ОписаниеМакетаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("МакетГруппировкиСхемыКомпоновкиДанных") Тогда
		Возврат МакетГруппировкиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("МакетПоляСхемыКомпоновкиДанных") Тогда
		Возврат МакетПоляСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("МакетПолейИтогаСхемыКомпоновкиДанных") Тогда
		Возврат МакетПолейИтогаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("НаборДанныхЗапросСхемыКомпоновкиДанных") Тогда
		Возврат НаборДанныхЗапросСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("НаборДанныхОбъектСхемыКомпоновкиДанных") Тогда
		Возврат НаборДанныхОбъектСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("НаборДанныхОбъединениеСхемыКомпоновкиДанных") Тогда
		Возврат НаборДанныхОбъединениеСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ПараметрСхемыКомпоновкиДанных") Тогда
		Возврат ПараметрСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ПолеИтогаСхемыКомпоновкиДанных") Тогда
		Возврат ПолеИтогаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("СвязьНаборовДанныхСхемыКомпоновкиДанных") Тогда
		Возврат СвязьНаборовДанныхСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ВыражениеУпорядочиванияКомпоновкиДанных") Тогда
		Возврат ВыражениеУпорядочиванияСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ОграничениеИспользованияПоляСхемыКомпоновкиДанных") Тогда
		Возврат ОграничениеИспользованияПоляСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ОформлениеКомпоновкиДанных") Тогда
		Возврат ОформлениеСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ЗначениеПараметраНастроекКомпоновкиДанных") Тогда
		Возврат ЗначениеПараметраНастроекСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ЗначениеПараметраКомпоновкиДанных") Тогда
		Возврат ЗначениеПараметраСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ПараметрыРедактированияКомпоновкиДанных") Тогда
		Возврат ПараметрыРедактированияСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("СтрокаТаблицыОбластиКомпоновкиДанных") Тогда
		Возврат СтрокаТаблицыОбластиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ЯчейкаТаблицыОбластиКомпоновкиДанных") Тогда
		Возврат ЯчейкаТаблицыОбластиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ОформлениеЯчейкиТаблицыОбластиКомпоновкиДанных") Тогда
		Возврат ОформлениеЯчейкиТаблицыОбластиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ОформлениеПоляОбластиКомпоновкиДанных") Тогда
		Возврат ОформлениеПоляОбластиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ПараметрОбластиВыражениеКомпоновкиДанных") Тогда
		Возврат ПараметрОбластиВыражениеСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ПараметрОбластиРасшифровкаКомпоновкиДанных") Тогда
		Возврат ПараметрОбластиРасшифровкаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ВыражениеПоляПараметраОбластиРасшифровкаКомпоновкиДанных") Тогда
		Возврат ВыражениеПоляПараметраРасшифровкиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ПолеОбластиКомпоновкиДанных") Тогда
		Возврат ПолеОбластиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ПолеНабораДанныхСхемыКомпоновкиДанных") Тогда
		Возврат ПолеНабораДанныхПолеСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ПапкаПолейНабораДанныхСхемыКомпоновкиДанных") Тогда
		Возврат ПолеНабораДанныхПапкаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ВложенныйНаборДанныхСхемыКомпоновкиДанных") Тогда
		Возврат ПолеНабораДанныхВложенныйНаборСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ВыбранныеПоляКомпоновкиДанных") Тогда
		Возврат ВыбранныеПоляСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ГруппаВыбранныхПолейКомпоновкиДанных") Тогда
		Возврат ГруппаВыбранныхПолейСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда
		Возврат АвтоВыбранноеПолеСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ВыбранноеПолеКомпоновкиДанных") Тогда
		Возврат ВыбранноеПолеСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("РольПоляНабораДанныхКомпоновкиДанных") Тогда
		Возврат РольПоляНабораДанныхСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		Возврат ГруппаЭлементовОтбораСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		Возврат ЭлементОтбораСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ОтборКомпоновкиДанных") Тогда
		Возврат ОтборСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ЗначенияПараметровВыводаКомпоновкиДанных") Тогда
		Возврат ЗначенияПараметровВыводаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ЗначенияПараметровДанныхКомпоновкиДанных") Тогда
		Возврат ЗначенияПараметровДанныхСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ПользовательскоеПолеВыражениеКомпоновкиДанных") Тогда
		Возврат ПользовательскоеПолеВыражениеСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ПользовательскоеПолеВыборКомпоновкиДанных") Тогда
		Возврат ПользовательскоеПолеВыборСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ПользовательскиеПоляКомпоновкиДанных") Тогда
		Возврат ПользовательскиеПоляСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ВариантПользовательскогоПоляВыборКомпоновкиДанных") Тогда
		Возврат ВариантПользовательскогоПоляВыбораСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ВариантыПользовательскогоПоляВыборКомпоновкиДанных") Тогда
		Возврат ВариантыПользовательскогоПоляВыбораСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("АвтоЭлементПорядкаКомпоновкиДанных") Тогда
		Возврат АвтоЭлементПорядкаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ЭлементПорядкаКомпоновкиДанных") Тогда
		Возврат ЭлементПорядкаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ПорядокКомпоновкиДанных") Тогда
		Возврат ПорядокСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
		Возврат НастройкиВложенногоОбъектаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ГруппировкаКомпоновкиДанных")
	      ИЛИ ТипЗначения = Тип("ГруппировкаТаблицыКомпоновкиДанных") Тогда
		Возврат ГруппировкаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ТаблицаКомпоновкиДанных") Тогда
		Возврат ТаблицаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ДиаграммаКомпоновкиДанных") Тогда
		Возврат ДиаграммаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("АвтоПолеГруппировкиКомпоновкиДанных") Тогда
		Возврат АвтоПолеГруппировкиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ПолеГруппировкиКомпоновкиДанных") Тогда
		Возврат ПолеГруппировкиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ПоляГруппировкиКомпоновкиДанных") Тогда
		Возврат ПоляГруппировкиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных")
	      ИЛИ ТипЗначения = Тип("ЗначенияПараметровВыводаГруппировкиТаблицыКомпоновкиДанных")
	      ИЛИ ТипЗначения = Тип("ЗначенияПараметровВыводаГруппировкиДиаграммыКомпоновкиДанных") Тогда
		Возврат ЗначенияПараметровВыводаГруппировкиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ЭлементУсловногоОформленияКомпоновкиДанных") Тогда
		Возврат ЭлементУсловногоОформленияСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("УсловноеОформлениеКомпоновкиДанных") Тогда
		Возврат УсловноеОформлениеСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ОформляемоеПолеКомпоновкиДанных") Тогда
		Возврат ОформляемоеПолеСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ОформляемыеПоляКомпоновкиДанных") Тогда
		Возврат ОформляемыеПоляСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗначения = Тип("ПолеКомпоновкиДанных") Тогда
		Возврат ПолеСКДВСтруктуру(Объект);
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ЗначениеСКДВСтруктуру()

// Процедура - заполняет объект СКД из структуры описания объекта
// 
// Параметры:
//     Объект             - <Объект СКД>          - заполняемый объект
//     СтруктураОбъекта   - Структура             - данные для заполнения объекта
//
Процедура ЗначениеСКДИзСтруктуры(Объект, СтруктураОбъекта)

	ТипЗначения = ТипЗнч(Объект);

	Если ТипЗначения = Тип("СхемаКомпоновкиДанных") Тогда
		СКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("НастройкиКомпоновкиДанных") Тогда
		НастройкиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ВариантНастроекКомпоновкиДанных") Тогда
		ВариантНастроекСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ВложеннаяСхемаКомпоновкиДанных") Тогда
		ВложеннаяСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ВычисляемоеПолеСхемыКомпоновкиДанных") Тогда
		ВычисляемоеПолеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ИсточникДанныхСхемыКомпоновкиДанных") Тогда
		ИсточникДанныхСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ОписаниеМакетаСхемыКомпоновкиДанных") Тогда
		ОписаниеМакетаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("МакетГруппировкиСхемыКомпоновкиДанных") Тогда
		МакетГруппировкиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("МакетПоляСхемыКомпоновкиДанных") Тогда
		МакетПоляСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("МакетПолейИтогаСхемыКомпоновкиДанных") Тогда
		МакетПолейИтогаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("НаборДанныхЗапросСхемыКомпоновкиДанных") Тогда
		НаборДанныхЗапросСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("НаборДанныхОбъектСхемыКомпоновкиДанных") Тогда
		НаборДанныхОбъектСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("НаборДанныхОбъединениеСхемыКомпоновкиДанных") Тогда
		НаборДанныхОбъединениеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ПараметрСхемыКомпоновкиДанных") Тогда
		ПараметрСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ПолеИтогаСхемыКомпоновкиДанных") Тогда
		ПолеИтогаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("СвязьНаборовДанныхСхемыКомпоновкиДанных") Тогда
		СвязьНаборовДанныхСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ВыражениеУпорядочиванияКомпоновкиДанных") Тогда
		ВыражениеУпорядочиванияСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ОграничениеИспользованияПоляСхемыКомпоновкиДанных") Тогда
		ОграничениеИспользованияПоляСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ОформлениеКомпоновкиДанных") Тогда
		ОформлениеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ЗначениеПараметраНастроекКомпоновкиДанных") Тогда
		ЗначениеПараметраНастроекСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ЗначениеПараметраКомпоновкиДанных") Тогда
		ЗначениеПараметраСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ПараметрыРедактированияКомпоновкиДанных") Тогда
		ПараметрыРедактированияСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("СтрокаТаблицыОбластиКомпоновкиДанных") Тогда
		СтрокаТаблицыОбластиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ЯчейкаТаблицыОбластиКомпоновкиДанных") Тогда
		ЯчейкаТаблицыОбластиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ОформлениеЯчейкиТаблицыОбластиКомпоновкиДанных") Тогда
		ОформлениеЯчейкиТаблицыОбластиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ОформлениеПоляОбластиКомпоновкиДанных") Тогда
		ОформлениеПоляОбластиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ПараметрОбластиВыражениеКомпоновкиДанных") Тогда
		ПараметрОбластиВыражениеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ПараметрОбластиРасшифровкаКомпоновкиДанных") Тогда
		ПараметрОбластиРасшифровкаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ВыражениеПоляПараметраОбластиРасшифровкаКомпоновкиДанных") Тогда
		ВыражениеПоляПараметраРасшифровкиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ПолеОбластиКомпоновкиДанных") Тогда
		ПолеОбластиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ПолеНабораДанныхСхемыКомпоновкиДанных") Тогда
		ПолеНабораДанныхПолеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ПапкаПолейНабораДанныхСхемыКомпоновкиДанных") Тогда
		ПолеНабораДанныхПапкаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ВложенныйНаборДанныхСхемыКомпоновкиДанных") Тогда
		ПолеНабораДанныхВложенныйНаборСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ВыбранныеПоляКомпоновкиДанных") Тогда
		ВыбранныеПоляСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ГруппаВыбранныхПолейКомпоновкиДанных") Тогда
		ГруппаВыбранныхПолейСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда
		АвтоВыбранноеПолеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ВыбранноеПолеКомпоновкиДанных") Тогда
		ВыбранноеПолеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("РольПоляНабораДанныхКомпоновкиДанных") Тогда
		РольПоляНабораДанныхСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		ГруппаЭлементовОтбораСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		ЭлементОтбораСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ОтборКомпоновкиДанных") Тогда
		ОтборСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ЗначенияПараметровВыводаКомпоновкиДанных") Тогда
		ЗначенияПараметровВыводаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ЗначенияПараметровДанныхКомпоновкиДанных") Тогда
		ЗначенияПараметровДанныхСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ПользовательскоеПолеВыражениеКомпоновкиДанных") Тогда
		ПользовательскоеПолеВыражениеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ПользовательскоеПолеВыборКомпоновкиДанных") Тогда
		ПользовательскоеПолеВыборСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ПользовательскиеПоляКомпоновкиДанных") Тогда
		ПользовательскиеПоляСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ВариантПользовательскогоПоляВыборКомпоновкиДанных") Тогда
		ВариантПользовательскогоПоляВыбораСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ВариантыПользовательскогоПоляВыборКомпоновкиДанных") Тогда
		ВариантыПользовательскогоПоляВыбораСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("АвтоЭлементПорядкаКомпоновкиДанных") Тогда
		АвтоЭлементПорядкаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ЭлементПорядкаКомпоновкиДанных") Тогда
		ЭлементПорядкаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ПорядокКомпоновкиДанных") Тогда
		ПорядокСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
		НастройкиВложенногоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ГруппировкаКомпоновкиДанных")
	      ИЛИ ТипЗначения = Тип("ГруппировкаТаблицыКомпоновкиДанных") Тогда
		ГруппировкаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ТаблицаКомпоновкиДанных") Тогда
		ТаблицаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ДиаграммаКомпоновкиДанных") Тогда
		ДиаграммаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("АвтоПолеГруппировкиКомпоновкиДанных") Тогда
		АвтоПолеГруппировкиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ПолеГруппировкиКомпоновкиДанных") Тогда
		ПолеГруппировкиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ПоляГруппировкиКомпоновкиДанных") Тогда
		ПоляГруппировкиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных")
	      ИЛИ ТипЗначения = Тип("ЗначенияПараметровВыводаГруппировкиТаблицыКомпоновкиДанных")
	      ИЛИ ТипЗначения = Тип("ЗначенияПараметровВыводаГруппировкиДиаграммыКомпоновкиДанных") Тогда
		ЗначенияПараметровВыводаГруппировкиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ЭлементУсловногоОформленияКомпоновкиДанных") Тогда
		ЭлементУсловногоОформленияСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("УсловноеОформлениеКомпоновкиДанных") Тогда
		УсловноеОформлениеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ОформляемоеПолеКомпоновкиДанных") Тогда
		ОформляемоеПолеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ОформляемыеПоляКомпоновкиДанных") Тогда
		ОформляемыеПоляСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗначения = Тип("ПолеКомпоновкиДанных") Тогда
		ПолеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	Иначе
		ПоказатьСообщение(СтрШаблонВнутр("Неизвестный тип объекта СКД: %1", Объект));
	КонецЕсли;

КонецПроцедуры // ЗначениеСКДИзСтруктуры()
 
// Функция - заполняет массив элементами по данным коллекции СКД
// 
// Параметры:
//     Коллекция          - <Коллекция СКД>     - заполняемый объект
//
// Возвращаемое значение:
//     Массив(Структура)     - массив элементов-описаний объектов
//
Функция КоллекцияСКДВМассив(Коллекция)

	МассивЭлементов = Новый Массив();
	Для Каждого ТекЭлемент Из Коллекция Цикл
		МассивЭлементов.Добавить(ЗначениеСКДВСтруктуру(ТекЭлемент));
	КонецЦикла;

	Возврат МассивЭлементов;

КонецФункции // КоллекцияСКДВМассив()

// Процедура - заполняет коллекцию СКД из массива описаний объектов
// 
// Параметры:
//     Коллекция              - <Коллекция СКД>       - заполняемая коллекция
//     МассивКоллекции        - Массив(Структура)     - данные для заполнения коллекции
//     УстановитьТипЭлемента  - Булево                - Истина - при добавлении элемента в коллекцию,
//                                                   будет указан тип элемента
//
Процедура КоллекцияСКДИзМассива(Коллекция, МассивКоллекции, УстановитьТипЭлемента = Ложь)

	Для Каждого ТекЭлемент Из МассивКоллекции Цикл
		Если УстановитьТипЭлемента
			И ТекЭлемент.__Тип <> "ГруппировкаТаблицыКомпоновкиДанных" Тогда
			 НовыйЭлемент = Коллекция.Добавить(Тип(ТекЭлемент.__Тип));
		Иначе
			НовыйЭлемент = Коллекция.Добавить();
		КонецЕсли;
		ЗначениеСКДИзСтруктуры(НовыйЭлемент, ТекЭлемент);
	КонецЦикла;

КонецПроцедуры // КоллекцияСКДИзМассива()

// Процедура - заполняет указанный элемент объекта СКД из структуры описания объекта
// 
// Параметры:
//     Объект                 - <Объект СКД>        - заполняемый объект
//     СтруктураОбъекта       - Структура           - данные для заполнения объекта
//     Свойство               - Строка              - имя заполняемого свойства
//     ЗначениеСКД            - Булево              - Истина - значение будет приобразовано в объект СКД
//
Процедура СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, Свойство, ЗначениеСКД = Ложь)

	Если СтруктураОбъекта.Свойство(Свойство) Тогда
		Если ЗначениеСКД Тогда
			ЗначениеСКДИзСтруктуры(Объект[Свойство], СтруктураОбъекта[Свойство]);
		Иначе
			Объект[Свойство] = СтруктураОбъекта[Свойство];
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры // СвойствоОбъектаСКДИзСтруктуры()

// Процедура - заполняет указанный элемент-коллекцию объекта СКД из структуры описания объекта
// 
// Параметры:
//     Объект                 - <Объект СКД>        - заполняемый объект
//     СтруктураОбъекта       - Структура           - данные для заполнения объекта
//     Свойство               - Строка              - имя заполняемого свойства-коллекции
//     УстановитьТипЭлемента  - Булево              - Истина - при добавлении элемента в коллекцию,
//                                                 будет указан тип элемента
//
Процедура СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, Свойство, УстановитьТипЭлемента = Ложь)

	Если СтруктураОбъекта.Свойство(Свойство) Тогда
		КоллекцияСКДИзМассива(Объект[Свойство], СтруктураОбъекта[Свойство], УстановитьТипЭлемента);
	КонецЕсли;

КонецПроцедуры // СвойствоОбъектаСКДИзМассива()

#КонецОбласти // ПреобразованияСКДСлужебныеПроцедурыИФункции

#Область ПреобразованияСКДФункцииПолученияЗначенийПеречислений

// Функция - возвращает строковое представление значения перечисления СКД
// ТипМакетаОбластиКомпоновкиДанных
// 
// Параметры:
//     Значение         - ТипМакетаОбластиКомпоновкиДанных - значение для получения строкового представления
// Возвращаемое значение:
//     Строка, Неопределено - строковое представление значения
//
Функция ТипМакетаОбластиКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ТипМакетаОбластиКомпоновкиДанных.Заголовок Тогда
		Возврат "Заголовок";
	ИначеЕсли Значение = ТипМакетаОбластиКомпоновкиДанных.ЗаголовокИерархии Тогда
		Возврат "ЗаголовокИерархии";
	ИначеЕсли Значение = ТипМакетаОбластиКомпоновкиДанных.ОбщийИтогЗаголовок Тогда
		Возврат "ОбщийИтогЗаголовок";
	ИначеЕсли Значение = ТипМакетаОбластиКомпоновкиДанных.ОбщийИтогПодвал Тогда
		Возврат "ОбщийИтогПодвал";
	ИначеЕсли Значение = ТипМакетаОбластиКомпоновкиДанных.Подвал Тогда
		Возврат "Подвал";
	ИначеЕсли Значение = ТипМакетаОбластиКомпоновкиДанных.ПодвалИерархии Тогда
		Возврат "ПодвалИерархии";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ТипМакетаОбластиКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ИспользованиеПараметраКомпоновкиДанных
// 
// Параметры:
//     Значение         - ИспользованиеПараметраКомпоновкиДанных - значение для получения строкового представления
// Возвращаемое значение:
//     Строка, Неопределено - строковое представление значения
//
Функция ИспользованиеПараметраКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ИспользованиеПараметраКомпоновкиДанных.Авто Тогда
		Возврат "Авто";
	ИначеЕсли Значение = ИспользованиеПараметраКомпоновкиДанных.Всегда Тогда
		Возврат "Всегда";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ИспользованиеПараметраКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// НаправлениеСортировкиКомпоновкиДанных
// 
// Параметры:
//     Значение         - НаправлениеСортировкиКомпоновкиДанных - значение для получения строкового представления
// Возвращаемое значение:
//     Строка, Неопределено - строковое представление значения
//
Функция НаправлениеСортировкиКомпоновкиДанныхВСтроку(Значение)

	Если Значение = НаправлениеСортировкиКомпоновкиДанных.Возр Тогда
		Возврат "Возр";
	ИначеЕсли Значение = НаправлениеСортировкиКомпоновкиДанных.Убыв Тогда
		Возврат "Убыв";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // НаправлениеСортировкиКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// РежимОтображенияЭлементаНастройкиКомпоновкиДанных
// 
// Параметры:
//     Значение         - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - значение для получения
//                                                                         строкового представления
// Возвращаемое значение:
//     Строка, Неопределено - строковое представление значения
//
Функция РежимОтображенияЭлементаНастройкиКомпоновкиДанныхВСтроку(Значение)

	Если Значение = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Авто Тогда
		Возврат "Авто";
	ИначеЕсли Значение = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.БыстрыйДоступ Тогда
		Возврат "БыстрыйДоступ";
	ИначеЕсли Значение = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный Тогда
		Возврат "Недоступный";
	ИначеЕсли Значение = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Обычный Тогда
		Возврат "Обычный";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // РежимОтображенияЭлементаНастройкиКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ТипПримененияОтбораКомпоновкиДанныхВСтроку
// 
// Параметры:
//     Значение         - ТипПримененияОтбораКомпоновкиДанныхВСтроку - значение для получения
//                                                                  строкового представления
// Возвращаемое значение:
//     Строка, Неопределено - строковое представление значения
//
Функция ТипПримененияОтбораКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ТипПримененияОтбораКомпоновкиДанных.Иерархия Тогда
		Возврат "Иерархия";
	ИначеЕсли Значение = ТипПримененияОтбораКомпоновкиДанных.ТолькоИерархия Тогда
		Возврат "ТолькоИерархия";
	ИначеЕсли Значение = ТипПримененияОтбораКомпоновкиДанных.Элементы Тогда
		Возврат "Элементы";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ТипПримененияОтбораКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ТипГруппыЭлементовОтбораКомпоновкиДанных
// 
// Параметры:
//     Значение         - ТипГруппыЭлементовОтбораКомпоновкиДанных - значение для получения
//                                                                строкового представления
// Возвращаемое значение:
//     Строка, Неопределено - строковое представление значения
//
Функция ТипГруппыЭлементовОтбораКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ Тогда
		Возврат "ГруппаИ";
	ИначеЕсли Значение = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли Тогда
		Возврат "ГруппаИли";
	ИначеЕсли Значение = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе Тогда
		Возврат "ГруппаНе";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ТипГруппыЭлементовОтбораКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ДействиеОбработкиРасшифровкиКомпоновкиДанных
// 
// Параметры:
//     Значение         - ДействиеОбработкиРасшифровкиКомпоновкиДанных - значение для получения
//                                                                    строкового представления
// Возвращаемое значение:
//     Строка, Неопределено - строковое представление значения
//
Функция ДействиеОбработкиРасшифровкиКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ДействиеОбработкиРасшифровкиКомпоновкиДанных.Нет Тогда
		Возврат "Нет";
	ИначеЕсли Значение = ДействиеОбработкиРасшифровкиКомпоновкиДанных.ОткрытьЗначение Тогда
		Возврат "ОткрытьЗначение";
	ИначеЕсли Значение = ДействиеОбработкиРасшифровкиКомпоновкиДанных.Отфильтровать Тогда
		Возврат "Отфильтровать";
	ИначеЕсли Значение = ДействиеОбработкиРасшифровкиКомпоновкиДанных.Оформить Тогда
		Возврат "Оформить";
	ИначеЕсли Значение = ДействиеОбработкиРасшифровкиКомпоновкиДанных.Расшифровать Тогда
		Возврат "Расшифровать";
	ИначеЕсли Значение = ДействиеОбработкиРасшифровкиКомпоновкиДанных.Сгруппировать Тогда
		Возврат "Сгруппировать";
	ИначеЕсли Значение = ДействиеОбработкиРасшифровкиКомпоновкиДанных.Упорядочить Тогда
		Возврат "Упорядочить";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ДействиеОбработкиРасшифровкиКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// РасположениеПоляКомпоновкиДанных
// 
// Параметры:
//     Значение         - РасположениеПоляКомпоновкиДанных - значение для получения
//                                                        строкового представления
// Возвращаемое значение:
//     Строка, Неопределено - строковое представление значения
//
Функция РасположениеПоляКомпоновкиДанныхВСтроку(Значение)

	Если Значение = РасположениеПоляКомпоновкиДанных.Авто Тогда
		Возврат "Авто";
	ИначеЕсли Значение = РасположениеПоляКомпоновкиДанных.Вертикально Тогда
		Возврат "Вертикально";
	ИначеЕсли Значение = РасположениеПоляКомпоновкиДанных.Вместе Тогда
		Возврат "Вместе";
	ИначеЕсли Значение = РасположениеПоляКомпоновкиДанных.Горизонтально Тогда
		Возврат "Горизонтально";
	ИначеЕсли Значение = РасположениеПоляКомпоновкиДанных.ОтдельнаяКолонка Тогда
		Возврат "ОтдельнаяКолонка";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // РасположениеПоляКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ТипБухгалтерскогоОстаткаКомпоновкиДанных
// 
// Параметры:
//     Значение         - ТипБухгалтерскогоОстаткаКомпоновкиДанных - значение для получения
//                                                                строкового представления
// Возвращаемое значение:
//     Строка, Неопределено - строковое представление значения
//
Функция ТипБухгалтерскогоОстаткаКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ТипБухгалтерскогоОстаткаКомпоновкиДанных.Дебет Тогда
		Возврат "Дебет";
	ИначеЕсли Значение = ТипБухгалтерскогоОстаткаКомпоновкиДанных.Кредит Тогда
		Возврат "Кредит";
	ИначеЕсли Значение = ТипБухгалтерскогоОстаткаКомпоновкиДанных.Нет Тогда
		Возврат "Нет";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ТипБухгалтерскогоОстаткаКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ТипОстаткаКомпоновкиДанных
// 
// Параметры:
//     Значение         - ТипОстаткаКомпоновкиДанных - значение для получения
//                                                  строкового представления
// Возвращаемое значение:
//     Строка, Неопределено - строковое представление значения
//
Функция ТипОстаткаКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ТипОстаткаКомпоновкиДанных.КонечныйОстаток Тогда
		Возврат "КонечныйОстаток";
	ИначеЕсли Значение = ТипОстаткаКомпоновкиДанных.НачальныйОстаток Тогда
		Возврат "НачальныйОстаток";
	ИначеЕсли Значение = ТипОстаткаКомпоновкиДанных.Нет Тогда
		Возврат "Нет";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ТипОстаткаКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ТипПериодаКомпоновкиДанных
// 
// Параметры:
//     Значение         - ТипПериодаКомпоновкиДанных - значение для получения
//                                                  строкового представления
// Возвращаемое значение:
//     Строка, Неопределено - строковое представление значения
//
Функция ТипПериодаКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ТипПериодаКомпоновкиДанных.Дополнительный Тогда
		Возврат "Дополнительный";
	ИначеЕсли Значение = ТипПериодаКомпоновкиДанных.Основной Тогда
		Возврат "Основной";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ТипПериодаКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// СостояниеЭлементаНастройкиКомпоновкиДанных
// 
// Параметры:
//     Значение         - СостояниеЭлементаНастройкиКомпоновкиДанных - значение для получения
//                                                                  строкового представления
// Возвращаемое значение:
//     Строка, Неопределено - строковое представление значения
//
Функция СостояниеЭлементаНастройкиКомпоновкиДанныхВСтроку(Значение)

	Если Значение = СостояниеЭлементаНастройкиКомпоновкиДанных.Включен Тогда
		Возврат "Включен";
	ИначеЕсли Значение = СостояниеЭлементаНастройкиКомпоновкиДанных.Отключен Тогда
		Возврат "Отключен";
	ИначеЕсли Значение = СостояниеЭлементаНастройкиКомпоновкиДанных.УдаленПользователем Тогда
		Возврат "УдаленПользователем";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // СостояниеЭлементаНастройкиКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ТипГруппировкиКомпоновкиДанных
// 
// Параметры:
//     Значение         - ТипГруппировкиКомпоновкиДанных - значение для получения
//                                                      строкового представления
// Возвращаемое значение:
//     Строка, Неопределено - строковое представление значения
//
Функция ТипГруппировкиКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ТипГруппировкиКомпоновкиДанных.Иерархия Тогда
		Возврат "Иерархия";
	ИначеЕсли Значение = ТипГруппировкиКомпоновкиДанных.ТолькоИерархия Тогда
		Возврат "ТолькоИерархия";
	ИначеЕсли Значение = ТипГруппировкиКомпоновкиДанных.Элементы Тогда
		Возврат "Элементы";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // СостояниеЭлементаНастройкиКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ТипДополненияПериодаКомпоновкиДанных
// 
// Параметры:
//     Значение         - ТипДополненияПериодаКомпоновкиДанных - значение для получения
//                                                            строкового представления
// Возвращаемое значение:
//     Строка, Неопределено - строковое представление значения
//
Функция ТипДополненияПериодаКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ТипДополненияПериодаКомпоновкиДанных.БезДополнения Тогда
		Возврат "БезДополнения";
	ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.Год Тогда
		Возврат "Год";
	ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.Декада Тогда
		Возврат "Декада";
	ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.День Тогда
		Возврат "День";
	ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.Квартал Тогда
		Возврат "Квартал";
	ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.Месяц Тогда
		Возврат "Месяц";
	ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.Минута Тогда
		Возврат "Минута";
	ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.Неделя Тогда
		Возврат "Неделя";
	ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.Полугодие Тогда
		Возврат "Полугодие";
	ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.Секунда Тогда
		Возврат "Секунда";
	ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.Час Тогда
		Возврат "Час";
	ИначеЕсли Совместимость8_3(12) Тогда
		Если Значение = ТипДополненияПериодаКомпоновкиДанных.ГодОтНачалаПериода Тогда
			Возврат "ГодОтНачалаПериода";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.ГодОтНачалаПериода445 Тогда
			Возврат "ГодОтНачалаПериода445";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.ДеньОтНачалаПериода Тогда
			Возврат "ДеньОтНачалаПериода";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.КварталОтНачалаПериода Тогда
			Возврат "КварталОтНачалаПериода";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.КварталОтНачалаПериода445 Тогда
			Возврат "КварталОтНачалаПериода445";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.МесяцОтНачалаПериода Тогда
			Возврат "МесяцОтНачалаПериода";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.МесяцОтНачалаПериода445 Тогда
			Возврат "МесяцОтНачалаПериода445";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.МинутаОтНачалаПериода Тогда
			Возврат "МинутаОтНачалаПериода";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.НеделяОтНачалаПериода Тогда
			Возврат "НеделяОтНачалаПериода";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.ПолугодиеОтНачалаПериода Тогда
			Возврат "ПолугодиеОтНачалаПериода";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.ПолугодиеОтНачалаПериода445 Тогда
			Возврат "ПолугодиеОтНачалаПериода445";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.ЧасОтНачалаПериода Тогда
			Возврат "ЧасОтНачалаПериода";
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ТипДополненияПериодаКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ИспользованиеУсловногоОформленияКомпоновкиДанных
// 
// Параметры:
//     Значение         - ИспользованиеУсловногоОформленияКомпоновкиДанных - значение для получения
//                                                                        строкового представления
// Возвращаемое значение:
//     Строка, Неопределено - строковое представление значения
//
Функция ИспользованиеУсловногоОформленияКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ИспользованиеУсловногоОформленияКомпоновкиДанных.Использовать Тогда
		Возврат "Использовать";
	ИначеЕсли Значение = ИспользованиеУсловногоОформленияКомпоновкиДанных.НеИспользовать Тогда
		Возврат "НеИспользовать";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // СостояниеЭлементаНастройкиКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ВидСравненияКомпоновкиДанных
// 
// Параметры:
//     Значение         - ВидСравненияКомпоновкиДанных     - значение для получения
//                                                        строкового представления
// Возвращаемое значение:
//     Строка, Неопределено - строковое представление значения
//
Функция ВидСравненияКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ВидСравненияКомпоновкиДанных.Больше Тогда
		Возврат "Больше";
	ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.БольшеИлиРавно Тогда
		Возврат "БольшеИлиРавно";
	ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.ВИерархии Тогда
		Возврат "ВИерархии";
	ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.ВСписке Тогда
		Возврат "ВСписке";
	ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.ВСпискеПоИерархии Тогда
		Возврат "ВСпискеПоИерархии";
	ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.Заполнено Тогда
		Возврат "Заполнено";
	ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.Меньше Тогда
		Возврат "Меньше";
	ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.МеньшеИлиРавно Тогда
		Возврат "МеньшеИлиРавно";
	ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.НачинаетсяС Тогда
		Возврат "НачинаетсяС";
	ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.НеВИерархии Тогда
		Возврат "НеВИерархии";
	ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.НеВСписке Тогда
		Возврат "НеВСписке";
	ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.НеВСпискеПоИерархии Тогда
		Возврат "НеВСпискеПоИерархии";
	ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.НеЗаполнено Тогда
		Возврат "НеЗаполнено";
	ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.НеНачинаетсяС Тогда
		Возврат "НеНачинаетсяС";
	ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.НеПодобно Тогда
		Возврат "НеПодобно";
	ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.НеРавно Тогда
		Возврат "НеРавно";
	ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.НеСодержит Тогда
		Возврат "НеСодержит";
	ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.Подобно Тогда
		Возврат "Подобно";
	ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.Равно Тогда
		Возврат "Равно";
	ИначеЕсли Значение = ВидСравненияКомпоновкиДанных.Содержит Тогда
		Возврат "Содержит";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ВидСравненияКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// 
// Параметры:
//     Значение             - <Перечисление СКД> - значение для получения строкового представления
// Возвращаемое значение:
//     Строка, Неопределено - строковое представление значения
//
Функция ПеречислениеСКДВСтроку(Значение)

	ТипЗначения = ТипЗнч(Значение);

	Если ТипЗначения = Тип("ТипМакетаОбластиКомпоновкиДанных") Тогда
		Возврат ТипМакетаОбластиКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗначения = Тип("ИспользованиеПараметраКомпоновкиДанных") Тогда
		Возврат ИспользованиеПараметраКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗначения = Тип("НаправлениеСортировкиКомпоновкиДанных") Тогда
		Возврат НаправлениеСортировкиКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗначения = Тип("РежимОтображенияЭлементаНастройкиКомпоновкиДанных") Тогда
		Возврат РежимОтображенияЭлементаНастройкиКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗначения = Тип("ТипПримененияОтбораКомпоновкиДанных") Тогда
		Возврат ТипПримененияОтбораКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗначения = Тип("ТипГруппыЭлементовОтбораКомпоновкиДанных") Тогда
		Возврат ТипГруппыЭлементовОтбораКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗначения = Тип("ДействиеОбработкиРасшифровкиКомпоновкиДанных") Тогда
		Возврат ДействиеОбработкиРасшифровкиКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗначения = Тип("РасположениеПоляКомпоновкиДанных") Тогда
		Возврат РасположениеПоляКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗначения = Тип("ТипБухгалтерскогоОстаткаКомпоновкиДанных") Тогда
		Возврат ТипБухгалтерскогоОстаткаКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗначения = Тип("ТипОстаткаКомпоновкиДанных") Тогда
		Возврат ТипОстаткаКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗначения = Тип("ТипПериодаКомпоновкиДанных") Тогда
		Возврат ТипПериодаКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗначения = Тип("СостояниеЭлементаНастройкиКомпоновкиДанных") Тогда
		Возврат СостояниеЭлементаНастройкиКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗначения = Тип("ТипГруппировкиКомпоновкиДанных") Тогда
		Возврат ТипГруппировкиКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗначения = Тип("ТипДополненияПериодаКомпоновкиДанных") Тогда
		Возврат ТипДополненияПериодаКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗначения = Тип("ИспользованиеУсловногоОформленияКомпоновкиДанных") Тогда
		Возврат ИспользованиеУсловногоОформленияКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗначения = Тип("ВидСравненияКомпоновкиДанных") Тогда
		Возврат ВидСравненияКомпоновкиДанныхВСтроку(Значение);
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ПеречислениеСКДВСтроку()

#КонецОбласти // СКДСлужебныеФункцииПолученияЗначенийПеречислений

#Область ПрочиеСлужебныеПроцедурыИФункции

// Функция - возвращает кэш описаний типов
//
// Возвращаемое значение:
//     - Соответствие  - кэш описаний типов
//
Функция КэшОписанийТипов()

	Если НЕ ТипЗнч(КэшОписанийТипов) = Тип("Соответствие") ИЛИ КэшОписанийТипов.Количество() = 0 Тогда

		КэшОписанийТипов = Новый Соответствие();
		 
		//@skip-warning
		МакетОписанияТипов = ЭтотОбъект.ПолучитьМакет("ОписаниеТипов");

		ОписаниеТиповМакет = ПрочитатьОписаниеОбъектаИзJSON(МакетОписанияТипов.ПолучитьТекст());

		Для Каждого ТекОписание Из ОписаниеТиповМакет Цикл

			КэшОписанийТипов.Вставить(ТекОписание.Ключ, ТекОписание.Значение);
			КэшОписанийТипов[ТекОписание.Ключ].Вставить("Имя", ТекОписание.Ключ);

			Для Каждого ТекИмя Из ТекОписание.Значение.ИменаКоллекции Цикл
				КэшОписанийТипов.Вставить(ТекИмя, ТекОписание.Значение);
			КонецЦикла;

		КонецЦикла;

	КонецЕсли;

	Возврат КэшОписанийТипов;

КонецФункции // КэшОписанийТипов()

// Функция - возвращает кэш объектов метаданных, которые могут содержать предопределенные значения
//
// Возвращаемое значение:
//     - Соответствие  - кэш объектов метаданных, которые могут содержать предопределенные значения
//
Функция КэшМетаданных()

	Если ТипЗнч(КэшМетаданных) = Тип("Соответствие") Тогда
		Возврат КэшМетаданных;
	КонецЕсли;

	КоллекцииМетаданных = СтрРазделитьВнутр("Справочники,
	                                        |Документы,
	                                        |Перечисления,
	                                        |ПланыВидовХарактеристик,
	                                        |ПланыСчетов,
	                                        |ПланыОбмена,
	                                        |ПланыВидовРасчета,
	                                        |БизнесПроцессы,
	                                        |Задачи,
	                                        |РегистрыСведений,
	                                        |РегистрыНакопления,
	                                        |РегистрыБухгалтерии,
	                                        |РегистрыРасчета");

	КэшМетаданных = Новый Соответствие();

	Для Каждого ТекКоллекция Из КоллекцииМетаданных Цикл
		Для Каждого ТекМета Из Метаданные[СокрЛП(ТекКоллекция)] Цикл
			Описание = Новый Структура();
			Описание.Вставить("Коллекция", СокрЛП(ТекКоллекция));
			Описание.Вставить("ПолноеИмя", ТекМета.ПолноеИмя());
			Описание.Вставить("Имя"      , ТекМета.Имя);

			Если Лев(Описание.Коллекция, 8) = "Регистры" Тогда
				ТипЗначения = Тип(СтрЗаменить(Описание.ПолноеИмя, ".", "Запись."));
				КэшМетаданных.Вставить(ТипЗначения, Описание);
				ТипЗначения = Тип(СтрЗаменить(Описание.ПолноеИмя, ".", "НаборЗаписей."));
				КэшМетаданных.Вставить(ТипЗначения, Описание);
			ИначеЕсли Описание.Коллекция = "Перечисления" Тогда
				ТипЗначения = Тип(СтрЗаменить(Описание.ПолноеИмя, ".", "Ссылка."));
				КэшМетаданных.Вставить(ТипЗначения, Описание);
			Иначе
				ТипЗначения = Тип(СтрЗаменить(Описание.ПолноеИмя, ".", "Объект."));
				КэшМетаданных.Вставить(ТипЗначения, Описание);
				ТипЗначения = Тип(СтрЗаменить(Описание.ПолноеИмя, ".", "Ссылка."));
				КэшМетаданных.Вставить(ТипЗначения, Описание);
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;

	Возврат КэшМетаданных;

КонецФункции // КэшМетаданных()

// Процедура - выодит сообщение пользователю
// 
// Параметры:
//     ТекстСообщения     - Строка - Текст сообщения
//     ВызыватьИсключение - Булево - Истина - будет вызвано исключение
//
Процедура ПоказатьСообщение(ТекстСообщения, ВызыватьИсключение = Ложь)

	Сообщение = Новый СообщениеПользователю();
	Сообщение.Текст = ТекстСообщения;
	Сообщение.Сообщить();

	Если ВызыватьИсключение Тогда
		ВызватьИсключение ТекстСообщения;
	КонецЕсли;

КонецПроцедуры // ПоказатьСообщение()

// Процедура - дополняет текст полями структуры
// 
// Параметры:
//     Текст             - Строка    - дополняемый текст
//     ПарамСтруктура    - Структура - структура, поля которой добавляются
//     ДобавлятьЗначения - Булево    - Истина - к тексту полей будут добавлены значения
//
Процедура ДополнитьТекстПолямиСтруктуры(Текст, ПарамСтруктура, ДобавлятьЗначения = Ложь)

	Для Каждого ТекЭлемент Из ПарамСтруктура Цикл
		Текст = СтрШаблон("%1%2%3", Текст, Символы.ПС, ТекЭлемент.Ключ);
		Если ДобавлятьЗначения Тогда
			Текст = СтрШаблон("%1 : %2", Текст, ТекЭлемент.Значение);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры // ДополнитьТекстПолямиСтруктуры()

// Функция "расщепляет" строку на подстроки, используя заданный 
//         разделитель. Разделитель может иметь любую длину. 
//         Если в качестве разделителя задан пробел, рядом стоящие пробелы 
//         считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//         игнорируются.
// (для совместимости с версиями < 8.3.6)
//
// Параметры: 
//     Стр            - строка, которую необходимо разложить на подстроки. 
//                      Параметр передается по значению.
//     Разделитель    - строка-разделитель, по умолчанию - запятая.
//     ВключатьПустые - Указывает необходимость включать в результат пустые строки.
//
//
// Возвращаемое значение:
//     массив значений, элементы которого - подстроки
//
Функция СтрРазделитьВнутр(Знач Стр, Разделитель = ",", ВключатьПустые = Истина) Экспорт

	Если Совместимость8_3(6) Тогда
		Возврат Вычислить("СтрРазделить(Стр, Разделитель, ВключатьПустые)");
	КонецЕсли;

	Возврат СтрРазделитьСтар(Стр, Разделитель, ВключатьПустые);

КонецФункции // СтрРазделитьВнутр()

// Функция "расщепляет" строку на подстроки, используя заданный разделитель.
// (используется для режима совместимости с версиями < 8.3.6)
//
// Параметры: 
//     Стр            - строка, которую необходимо разложить на подстроки. 
//                      Параметр передается по значению.
//     Разделитель    - строка-разделитель, по умолчанию - запятая.
//     ВключатьПустые - Указывает необходимость включать в результат пустые строки.
//
// Возвращаемое значение:
//     массив значений, элементы которого - подстроки
//
Функция СтрРазделитьСтар(Знач Стр, Разделитель = ",", ВключатьПустые = Истина) Экспорт

	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока Истина Цикл
			Поз = Найти(Стр, Разделитель);
			Если Поз = 0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр, Поз - 1));
			Стр = СокрЛ(Сред(Стр, Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока Истина Цикл
			Поз = Найти(Стр, Разделитель);
			Если Поз = 0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			Значение = Лев(Стр, Поз - 1);
			Если НЕ ПустаяСтрока(Значение) ИЛИ ВключатьПустые Тогда
				МассивСтрок.Добавить(Значение);
			КонецЕсли;
			Стр = Сред(Стр, Поз + ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;

КонецФункции // СтрРазделитьСтар()

// Функция выполняет подстановку значений в исходный текст
// (для совместимости с версиями < 8.3.6)
//
// Параметры: 
//     Текст          - Строка   - строка для подстановки 
//     Замена1..10    - Строка   - значения подстановки
//
// Возвращаемое значение:
//     Строка - результат подставновки
//
Функция СтрШаблонВнутр(Знач Текст, Замена1 = Неопределено, Замена2 = Неопределено, Замена3 = Неопределено,
                       Замена4 = Неопределено, Замена5 = Неопределено, Замена6 = Неопределено,
                       Замена7 = Неопределено, Замена8 = Неопределено, Замена9 = Неопределено, Замена10 = Неопределено)

	Если Совместимость8_3(6) Тогда

		Возврат Вычислить("СтрШаблон(Текст, Замена1, Замена2, Замена3,
		                                   |Замена4, Замена5, Замена6,
		                                   |Замена7, Замена8, Замена9, Замена10)");
	КонецЕсли;	

	Возврат СтрШаблонСтар(Текст, Замена1, Замена2, Замена3,
	                      Замена4, Замена5, Замена6, Замена7,
	                      Замена8, Замена9, Замена10);

КонецФункции // СтрШаблонВнутр()

// Функция выполняет подстановку значений в исходный текст
// (используется для режима совместимости с версиями < 8.3.6)
//
// Параметры: 
//     Текст          - Строка   - строка для подстановки 
//     Замена1..10    - Строка   - значения подстановки
//
// Возвращаемое значение:
//     Строка - результат подставновки
//
Функция СтрШаблонСтар(Знач Текст, Замена1 = Неопределено, Замена2 = Неопределено, Замена3 = Неопределено,
                       Замена4 = Неопределено, Замена5 = Неопределено, Замена6 = Неопределено,
                       Замена7 = Неопределено, Замена8 = Неопределено, Замена9 = Неопределено, Замена10 = Неопределено)

	Для й = 1 По 10 Цикл
		Значение = Вычислить("Замена" + СокрЛП(й));
		Если Значение = Неопределено Тогда
			Прервать;
		КонецЕсли;
		Текст = СтрЗаменить(Текст, "%" + СокрЛП(й), Значение);
	КонецЦикла;

	Возврат Текст;

КонецФункции // СтрШаблонСтар()

// Функция проверяет что переданная строка начинается с указанной подстроки
//
// Параметры: 
//     Строка            - Строка   - строка для проверки 
//     Подстрока         - Строка   - проверяемое начало строки
//     УчитыватьРегистр  - Булево   - Истина - проверка выполняется с учетом регистра;
//                                     Ложь - без учета регистра
//
// Возвращаемое значение:
//     Булево   - Истина - строка начинается с указанной подстроки;
//                Ложь - в противном случае
//
Функция СтрокаНачинаетсяСВнутр(Строка, Подстрока = "", УчитыватьРегистр = Ложь)

	Если НЕ ЗначениеЗаполнено(Подстрока) Тогда
		Возврат Истина;
	КонецЕсли;

	Если УчитыватьРегистр Тогда
		Возврат Лев(Строка, СтрДлина(Подстрока)) = Подстрока;
	Иначе
		Возврат ВРег(Лев(Строка, СтрДлина(Подстрока))) = ВРег(Подстрока);
	КонецЕсли;

КонецФункции // СтрокаНачинаетсяСВнутр()

// Функция сравнивает значения как строки
//
// Параметры: 
//     ЛевоеЗначение     - Произвольный   - левое значение для сравнения
//     ПравоеЗначение    - Произвольный   - правое значение для сравнения
//     УчитыватьРегистр  - Булево         - Истина - проверка выполняется с учетом регистра,
//                                          Ложь - без учета регистра
//
// Возвращаемое значение:
//     Булево   - Истина - строковые представления равны,
//                Ложь - в противном случае
//
Функция ПредставленияРавны(Знач ЛевоеЗначение, Знач ПравоеЗначение, Знач УчитыватьРегистр = Ложь)

	ЛевоеЗначение = СокрЛП(ЛевоеЗначение);
	ПравоеЗначение = СокрЛП(ПравоеЗначение);
	
	Если НЕ УчитыватьРегистр Тогда
		ЛевоеЗначение = ВРег(ЛевоеЗначение);
		ПравоеЗначение = ВРег(ПравоеЗначение);
	КонецЕсли;

	Возврат (ЛевоеЗначение = ПравоеЗначение);

КонецФункции // ПредставленияРавны()

// Функция проверяет наличие в структуре служебного поля "__Тип"
//
// Параметры: 
//     Структура     - Структура   - проверяемая структура
//
// Возвращаемое значение:
//     Булево   - Истина - в структуре есть поле "__Тип"
//
Функция ЕстьТип(Знач Структура)

	Если НЕ (ТипЗнч(Структура) = Тип("Структура")
	 ИЛИ ТипЗнч(Структура) = Тип("ФиксированнаяСтруктура"))Тогда
		Возврат Ложь;
	КонецЕсли;

	Возврат Структура.Свойство("__Тип");

КонецФункции // ЕстьТип()

// Функция проверяет наличие в структуре поля "Ссылка"
//
// Параметры: 
//     Структура     - Структура   - проверяемая структура
//
// Возвращаемое значение:
//     Булево   - Истина - в структуре есть поле "Ссылка"
//
Функция ЕстьСсылка(Знач Структура)

	Если НЕ (ТипЗнч(Структура) = Тип("Структура")
	 ИЛИ ТипЗнч(Структура) = Тип("ФиксированнаяСтруктура"))Тогда
		Возврат Ложь;
	КонецЕсли;

	Возврат Структура.Свойство("Ссылка");

КонецФункции // ЕстьСсылка()

// Функция - возвращает флаг, что текущая конфигурация на текущей платформы совместима с указанным релизом 8.3
// 
// Параметры:
//     ПроверяемыйРелиз    - Число    - номер проверяемого релиза платформы 8.3
//
// Возвращаемое значение:
//   Булево    - Истина - конфигурация на текущей платформы совместима с указанным релизом 8.3
//               Ложь - в противном случае
//
Функция Совместимость8_3(ПроверяемыйРелиз)

	Если НЕ ТипЗнч(Совместимость8_3) = Тип("Соответствие") Тогда
		Совместимость8_3 = Новый Соответствие();
	КонецЕсли;

	Если НЕ Совместимость8_3.Получить(ПроверяемыйРелиз) = Неопределено Тогда
		Возврат Совместимость8_3[ПроверяемыйРелиз];
	КонецЕсли;

	ПроверяемаяВерсия = 3;

	Совместимость8_3.Вставить(ПроверяемыйРелиз, Истина);

	СИ = Новый СистемнаяИнформация();

	ЧастиВерсии = СтрРазделитьСтар(СИ.ВерсияПриложения, ".");

	Для й = 0 По ЧастиВерсии.ВГраница() Цикл
		ЧастиВерсии[й] = Число(ЧастиВерсии[й]);
	КонецЦикла;

	Если Число(ЧастиВерсии[1]) < ПроверяемаяВерсия Тогда
		Совместимость8_3.Вставить(ПроверяемыйРелиз, Ложь);
	КонецЕсли;

	Если Число(ЧастиВерсии[2]) < ПроверяемыйРелиз Тогда
		Совместимость8_3.Вставить(ПроверяемыйРелиз, Ложь);
	КонецЕсли;

	РежимыСовместимости = РежимыСовместимости8_3(СтрШаблон("8.3.%1", ПроверяемыйРелиз));

	Если РежимыСовместимости.Получить(Метаданные.РежимСовместимости) = Неопределено Тогда
		Совместимость8_3.Вставить(ПроверяемыйРелиз, Ложь);
	КонецЕсли;

	Возврат Совместимость8_3[ПроверяемыйРелиз];

КонецФункции // Совместимость8_3()

// Функция - коллекцию режимов совместимости, "совместимых" с указанным режимом совместимости
// 
// Параметры:
//     НачинаяСВерсии8_3   - Строка     - минимальный режим совместимости, для которого
//                                        заполняется набор "совместимых" режимов совместимости
//
// Возвращаемое значение:
//     Соответствие - коллекция режимов совместимости
//
Функция РежимыСовместимости8_3(НачинаяСВерсии8_3)

	ПозицияНомераРелиза = 2;

	СИ = Новый СистемнаяИнформация();
	ЧастиВерсииПриложения = СтрРазделитьСтар(СИ.ВерсияПриложения, ".");
	РелизПриложения = СтрШаблонСтар("%1.%2.%3",
	                                ЧастиВерсииПриложения[0],
									ЧастиВерсииПриложения[1],
									ЧастиВерсииПриложения[ПозицияНомераРелиза]);

	ЧастиВерсии = СтрРазделитьСтар(НачинаяСВерсии8_3, ".");
	РелизНачинаяСВерсии8_3 = Число(ЧастиВерсии[ПозицияНомераРелиза]);

	РежимыСовместимости = Новый Соответствие();

	Если ЧастиВерсииПриложения[1] = "3"  Тогда

		Для й = РелизНачинаяСВерсии8_3 По Число(ЧастиВерсииПриложения[ПозицияНомераРелиза]) - 1 Цикл
			РежимыСовместимости.Вставить(Метаданные.СвойстваОбъектов.РежимСовместимости["Версия8_3_" + Формат(й, "ЧРГ=; ЧГ=")],
			                             "8.3." + Формат(й, "ЧРГ=; ЧГ="));
		КонецЦикла;

		РежимыСовместимости.Вставить(Метаданные.СвойстваОбъектов.РежимСовместимости.НеИспользовать, РелизПриложения);

	КонецЕсли;

	Возврат Новый ФиксированноеСоответствие(РежимыСовместимости);

КонецФункции // РежимыСовместимости8_3()

#КонецОбласти // ПрочиеСлужебныеПроцедурыИФункции

#КонецОбласти // СлужебныеПроцедурыИФункции
