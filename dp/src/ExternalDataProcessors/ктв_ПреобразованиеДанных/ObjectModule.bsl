// ----------------------------------------------------------
// This Source Code Form is subject to the terms of the
// Mozilla Public License, v.2.0. If a copy of the MPL
// was not distributed with this file, You can obtain one
// at http://mozilla.org/MPL/2.0/.
// ----------------------------------------------------------
// Codebase: https://github.com/ArKuznetsov/SerLib1C/
// ----------------------------------------------------------

Перем ПравилаВыгрузкиТипов;
Перем ПравилаЗагрузкиТипов;

Перем ОписаниеТипов;

Перем КэшСсылок;

#Область ПреобразованияОбъектовСлужебные

// Возвращает структуру, содержащую информацию
// о переданном виде объектов метаданных
//
// Параметры:
//  Имя					- Строка		- Имя вида объектов метаданных (например, константа,
//										  ПланСчетов и т.п.), может передаваться в ед. мн. числе
//  ТекИБ				- COMОбъект,	- Информационная база, из которой будет получена информация
//										  о виде объектов, Неопределено - текущая инф. база
//
// Возвращаемое значение:
//   Структура			- Содержимое:
//							Коллекция		- Менеджер вида объектов (например, СправочникиМенеджер)
//							МетаКоллекция	- Коллекция метаданных вида объектов (например, Справочники)
//							Имя				- Имя вида объектов (например, "ПланСчетов")
//							ИмяКоллекции	- Имя коллекции вида объектов (например,  "ПланыСчетов")
//							Представление	- Представление вида объектов (например, "План счетов")
//							ПредставлениеМ	- Представление коллекции вида объектов (например,  "Планы счетов")
//							ИмяТипа			- Имя типа (конкретный элемент, например, Контрагенты)
//							Картинка		- Картинка коллекции по умолчанию 
//							КартинкаОбъекта - Картинка объекта коллекции по умолчанию 
//							Конструктор		- Имя функции конструктора экземпляра объекта (например: СоздатьЭлемент)
//							КонструкторАльт - Имя альтернативной функции конструктора экземпляра объекта (например: СоздатьГруппу) 
//
Функция ПолучитьОписаниеВидаОбъектов(Имя, ТекИБ = Неопределено) Экспорт
	
	ИмяТипа = "";

	Если ТипЗнч(Имя) = Тип("Тип") Тогда
		МетаданныеТипа = Метаданные.НайтиПоТипу(Имя);
		Если МетаданныеТипа = Неопределено Тогда
			Возврат Неопределено;
		КонецЕсли;
		ПолноеИмяТипа = МетаданныеТипа.ПолноеИмя();
		ПозТчк = Найти(ПолноеИмяТипа, ".");
		НИмя = НРег(Лев(ПолноеИмяТипа, ПозТчк - 1));
		ИмяТипа = Сред(ПолноеИмяТипа, ПозТчк + 1);
	ИначеЕсли ТипЗнч(Имя) = Тип("Строка") Тогда
		Если Найти(Имя, ".") > 0 Тогда
			ПозТчк = Найти(Имя, ".");
			НИмя = НРег(Лев(Имя, ПозТчк - 1));
			ИмяТипа = Сред(Имя, ПозТчк + 1);
		Иначе
			НИмя = НРег(СтрЗаменить(СтрЗаменить(Имя, "-", ""), " ", ""));
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Если НЕ ТипЗнч(ОписаниеТипов) = Тип("Соответствие") ИЛИ ОписаниеТипов.Количество() = 0 Тогда
		
		ОписаниеТипов = Новый Соответствие();
		 
		//@skip-warning
		МакетОписанияТипов = ЭтотОбъект.ПолучитьМакет("ОписаниеТипов");

		ОписаниеТиповМакет = ПрочитатьОписаниеОбъектаИзJSON(МакетОписанияТипов.ПолучитьТекст());

		Для Каждого ТекОписание Из ОписаниеТиповМакет Цикл
			
			ОписаниеТипов.Вставить(ТекОписание.Ключ, ТекОписание.Значение);
			ОписаниеТипов[ТекОписание.Ключ].Вставить("Имя", ТекОписание.Ключ);
			
			Для Каждого ТекИмя Из ТекОписание.Значение.ИменаКоллекции Цикл
				ОписаниеТипов.Вставить(ТекИмя, ТекОписание.Значение);
			КонецЦикла;
			
		КонецЦикла;
		
	КонецЕсли;
	
	ОписаниеТипаКэш = ОписаниеТипов.Получить(НИмя);

	Если ОписаниеТипаКэш = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;

	ОписаниеТипа = Новый Структура();

	ОписаниеТипа.Вставить("ИмяТипа"        , ИмяТипа);
	ОписаниеТипа.Вставить("Коллекция"      , ?(ТекИБ = Неопределено,
	                                           Вычислить(ОписаниеТипаКэш.Коллекция),
	                                           ТекИБ.Вычислить(ОписаниеТипаКэш.Коллекция)));
	ОписаниеТипа.Вставить("МетаКоллекция"  , ?(ТекИБ = Неопределено,
	                                           Метаданные[ОписаниеТипаКэш.Коллекция],
	                                           ТекИБ.Метаданные[ОписаниеТипаКэш.Коллекция]));
	ОписаниеТипа.Вставить("Имя"            , ОписаниеТипаКэш.Имя);
	ОписаниеТипа.Вставить("ИмяКоллекции"   , ОписаниеТипаКэш.Коллекция);
	ОписаниеТипа.Вставить("Представление"  , ОписаниеТипаКэш.Представление);
	ОписаниеТипа.Вставить("ПредставлениеМ" , ОписаниеТипаКэш.ПредставлениеМ);
	ОписаниеТипа.Вставить("Конструктор"    , ОписаниеТипаКэш.Конструктор);
	ОписаниеТипа.Вставить("КонструкторАльт", ОписаниеТипаКэш.КонструкторАльт);
	ОписаниеТипа.Вставить("Картинка");
	ОписаниеТипа.Вставить("КартинкаОбъекта");

	#Если Клиент Тогда
	ОписаниеТипа.Картинка        = БиблиотекаКартинок[ОписаниеТипаКэш.Картинка];
	ОписаниеТипа.КартинкаОбъекта = БиблиотекаКартинок[ОписаниеТипаКэш.КартинкаОбъекта];
	#КонецЕсли

	Возврат ОписаниеТипа;
	
КонецФункции // ПолучитьОписаниеВидаОбъектов()

// Проверяет, что переданное значение является объектом регистра или его представлением
//
// Параметры:
//  Значение    - Произвольный - проверяемое значение или его представление
// 
// Возвращаемое значение:
//  Булево      - Истина - передан объект регистра или его представление,
//                Ложь   - в противном случае
//
Функция ЭтоОбъектРегистра(Значение) Экспорт

	ТипДляПроверки = Неопределено;
	
	Если ТипЗнч(Значение) = Тип("Структура") Тогда
		Если Значение.Свойство("__Тип") Тогда
			ТипДляПроверки = Значение.__Тип;
		КонецЕсли;
	Иначе
		ТипДляПроверки = ТипЗнч(Значение);
	КонецЕсли;

	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипДляПроверки);

	Если ОписаниеВида = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	КоллекцииРегистров = Новый Соответствие();
	КоллекцииРегистров.Вставить("РегистрСведений"   , Истина);
	КоллекцииРегистров.Вставить("РегистрНакопления" , Истина);
	КоллекцииРегистров.Вставить("РегистрБухгалтерии", Истина);
	КоллекцииРегистров.Вставить("РегистрРасчета"    , Истина);

	Возврат (КоллекцииРегистров.Получить(ОписаниеВида.Имя) = Истина);

КонецФункции // ЭтоОбъектРегистра()

// Проверяет, что переданное значение является записью регистра или ее представлением
//
// Параметры:
//  Значение    - Произвольный - проверяемое значение или его представление
// 
// Возвращаемое значение:
//  Булево      - Истина - передана запись регистра или ее представление
//                Ложь   - в противном случае
//
Функция ЭтоЗаписьРегистра(Значение) Экспорт

	Если НЕ ЭтоОбъектРегистра(Значение) Тогда
		Возврат Ложь;
	КонецЕсли;

	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипЗнч(Значение));

	Если ОписаниеВида = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("Структура") И Значение.Свойство("__Тип") Тогда
		Возврат (Найти(Значение.__Тип, "Запись.") > 1);
	КонецЕсли;

	Возврат (ТипЗнч(Значение) = Тип(СтрШаблонВнутр("%1Запись.%2", ОписаниеВида.Имя, ОписаниеВида.ИмяТипа)));

КонецФункции // ЭтоЗаписьРегистра()

// Проверяет, что переданное значение является набором записей регистра или его представлением
//
// Параметры:
//  Значение    - Произвольный - проверяемое значение или его представление
// 
// Возвращаемое значение:
//  Булево      - Истина - передан набор записей регистра или его представление,
//                Ложь   - в противном случае
//
Функция ЭтоНаборЗаписейРегистра(Значение) Экспорт

	Если НЕ ЭтоОбъектРегистра(Значение) Тогда
		Возврат Ложь;
	КонецЕсли;

	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипЗнч(Значение));

	Если ОписаниеВида = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("Структура") И Значение.Свойство("__Тип") Тогда
		Возврат (Найти(Значение.__Тип, "НаборЗаписей.") > 1);
	КонецЕсли;

	Возврат (ТипЗнч(Значение) = Тип(СтрШаблонВнутр("%1НаборЗаписей.%2", ОписаниеВида.Имя, ОписаниеВида.ИмяТипа)));

КонецФункции // ЭтоНаборЗаписейРегистра()

// Проверяет, что переданное значение является значением ссылочного типа или его представлением
//
// Параметры:
//  Значение    - Произвольный - проверяемое значение или его представление
// 
// Возвращаемое значение:
//  Булево      - Истина - передано ссылочное значение или его представление,
//                Ложь   - в противном случае
//
Функция ЭтоЗначениеСсылочногоТипа(Значение) Экспорт

	ТипДляПроверки = Неопределено;
	
	Если ТипЗнч(Значение) = Тип("Структура") Тогда
		Если Значение.Свойство("__Тип") Тогда
			ТипДляПроверки = Значение.__Тип;
		КонецЕсли;
	Иначе
		ТипДляПроверки = ТипЗнч(Значение);
	КонецЕсли;

	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипДляПроверки);

	Если ОписаниеВида = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СсылочныеКоллекции = Новый Соответствие();
	СсылочныеКоллекции.Вставить("Справочник"            , Истина);
	СсылочныеКоллекции.Вставить("Документ"              , Истина);
	СсылочныеКоллекции.Вставить("Перечисление"          , Истина);
	СсылочныеКоллекции.Вставить("ПланВидовХарактеристик", Истина);
	СсылочныеКоллекции.Вставить("ПланСчетов"            , Истина);
	СсылочныеКоллекции.Вставить("ПланОбмена"            , Истина);
	СсылочныеКоллекции.Вставить("ПланВидовРасчета"      , Истина);
	СсылочныеКоллекции.Вставить("БизнессПроцесс"        , Истина);
	СсылочныеКоллекции.Вставить("Задача"                , Истина);

	Возврат (СсылочныеКоллекции.Получить(ОписаниеВида.Имя) = Истина);

КонецФункции // ЭтоЗначениеСсылочногоТипа()

// Проверяет, что переданное значение является ссылкой на объект или ее представление
//
// Параметры:
//  Значение    - Произвольный - проверяемое значение или его представление
// 
// Возвращаемое значение:
//  Булево      - Истина - передано ссылочное значение или его представление,
//                Ложь   - в противном случае
//
Функция ЭтоСсылка(Значение) Экспорт

	Если НЕ ЭтоЗначениеСсылочногоТипа(Значение) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("Структура") И Значение.Свойство("__Тип") Тогда
		Возврат (Найти(Значение.__Тип, "Ссылка.") > 1);
	КонецЕсли;

	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипЗнч(Значение));

	Если ОписаниеВида = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат (ТипЗнч(Значение) = Тип(СтрШаблонВнутр("%1Ссылка.%2", ОписаниеВида.Имя, ОписаниеВида.ИмяТипа)));

КонецФункции // ЭтоСсылка()

// Проверяет, что переданное значение является ссылочным объектом или его представлением
//
// Параметры:
//  Значение    - Произвольный - проверяемое значение или его представление
// 
// Возвращаемое значение:
//  Булево      - Истина - передан ссылочный объект или его представление,
//                Ложь   - в противном случае
//
Функция ЭтоОбъект(Значение) Экспорт

	Если НЕ ЭтоЗначениеСсылочногоТипа(Значение) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("Структура") И Значение.Свойство("__Тип") Тогда
		Возврат (Найти(Значение.__Тип, "Объект.") > 1);
	КонецЕсли;

	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипЗнч(Значение));

	Если ОписаниеВида = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат (ТипЗнч(Значение) = Тип(СтрШаблонВнутр("%1Объект.%2", ОписаниеВида.Имя, ОписаниеВида.ИмяТипа)));

КонецФункции // ЭтоОбъект()

// Проверяет существование объекта по ссылке
//
// Параметры:
//  Значение    - ЛюбаяСсылка - ссылка на объект информационной базы
// 
// Возвращаемое значение:
//  Булево      - Истина - объект по ссылке существует,
//                Ложь   - в противном случае
//
Функция СсылкаСуществует(Значение) Экспорт
    
    Если НЕ ЗначениеЗаполнено(Значение) Тогда
    	Возврат Ложь;
    КонецЕсли;
    
    ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипЗнч(Значение));
    
    Если ОписаниеВида = Неопределено Тогда
        Возврат Ложь;
    КонецЕсли;
    
    Запрос = Новый Запрос("ВЫБРАТЬ
                          |    Таб.Ссылка
                          |ИЗ
                          |    //[ИмяТаблицы] КАК Таб
                          |ГДЕ
                          |    Ссылка = &Ссылка");
    
    Запрос.Текст = СтрЗаменить(Запрос.Текст,
                               "//[ИмяТаблицы]",
                               СтрШаблонВнутр("%1.%2", ОписаниеВида.Имя, ОписаниеВида.ИмяТипа));
    
    Запрос.УстановитьПараметр("Ссылка", Значение);
    
    УстановитьПривилегированныйРежим(Истина);
    
    Возврат НЕ Запрос.Выполнить().Пустой();
    
КонецФункции // СсылкаСуществует()

// Возвращает имя пердопределенных данных для переданного значения
// требуется, т.к. в разных версиях различается способ получения имени предопределенных данных
//
// Параметры:
//  Значение			- ЛюбаяСсылка	- Имя значение ссылочного типа (СправочникСсылка, ПеречислениеСсылка и т.п.)
//
// Возвращаемое значение:
//   Строка				- Имя предопределенных данных, если значение не является предопределенным, возвращается пустая строка
//
Функция ПолучитьИмяПредопределенныхДанных(Значение) Экспорт
	
	//@skip-warning
	МетаданныеЗначения = Значение.Метаданные();
	
	ИмяПредопределенныхДанных = "";
	
	Текст83 = "Если Метаданные.Справочники.Содержит(МетаданныеЗначения)
			  | ИЛИ Метаданные.ПланыВидовХарактеристик.Содержит(МетаданныеЗначения)
			  | ИЛИ Метаданные.ПланыСчетов.Содержит(МетаданныеЗначения)
			  | ИЛИ Метаданные.ПланыВидовРасчета.Содержит(МетаданныеЗначения) Тогда
			  |    Если Значение.Предопределенный Тогда
			  |        ИмяПредопределенныхДанных = Значение.ИмяПредопределенныхДанных;
			  |    КонецЕсли;
			  | ИначеЕсли Метаданные.ПланыОбмена.Содержит(МетаданныеЗначения) Тогда
			  |    Если Значение.ЭтотУзел Тогда
			  |        ИмяПредопределенныхДанных = ""ЭтотУзел"";
			  |    КонецЕсли;
			  |КонецЕсли;";
	
	Текст82 = "Если Значение.Предопределенный Тогда
			  |    Если Метаданные.Справочники.Содержит(МетаданныеЗначения) Тогда
			  |        ИмяПредопределенныхДанных = Справочники[МетаданныеЗначения.Имя].ПолучитьИмяПредопределенного(Значение);
			  |    ИначеЕсли Метаданные.ПланыВидовХарактеристик.Содержит(МетаданныеЗначения) Тогда
			  |        ИмяПредопределенныхДанных = ПланыВидовХарактеристик[МетаданныеЗначения.Имя].ПолучитьИмяПредопределенного(Значение);
			  |    ИначеЕсли Метаданные.ПланыСчетов.Содержит(МетаданныеЗначения) Тогда
			  |        ИмяПредопределенныхДанных = ПланыСчетов[МетаданныеЗначения.Имя].ПолучитьИмяПредопределенного(Значение);
			  |    ИначеЕсли Метаданные.ПланыВидовРасчета.Содержит(МетаданныеЗначения) Тогда
			  |        ИмяПредопределенныхДанных = ПланыВидовРасчета[МетаданныеЗначения.Имя].ПолучитьИмяПредопределенного(Значение);
			  |    ИначеЕсли Метаданные.ПланыОбмена.Содержит(МетаданныеЗначения) Тогда
			  |        ИмяПредопределенныхДанных = ""ЭтотУзел"";
			  |    КонецЕсли;
			  |КонецЕсли;";
	Если ЗначениеЗаполнено(Значение) Тогда
		Это83 = Истина;
		Попытка
			Выполнить(Текст83);
		Исключение
			Это83 = Ложь;
				ТекстОшибки = СтрШаблонВнутр("Ошибка получения имени предопределенных данных ""%1"": %2%3",
				                        СокрЛП(Значение),
				                        Символы.ПС,
				                        ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
			ПоказатьСообщение(ТекстОшибки);
		КонецПопытки;
		Если НЕ Это83 Тогда
			Попытка
				Выполнить(Текст82);
			Исключение
				ТекстОшибки = СтрШаблонВнутр("Ошибка получения имени предопределенных данных ""%1"": %2%3",
				                        СокрЛП(Значение),
				                        Символы.ПС,
				                        ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
				ВызватьИсключение ТекстОшибки;
			КонецПопытки;
		КонецЕсли;
	КонецЕсли;
		
	Возврат ИмяПредопределенныхДанных;	
	
КонецФункции // ПолучитьИмяПредопределенныхДанных()
	
// Проверяет использование свойства (по имени) в соответствии со списками используемых и исключаемых свойств
//
// Параметры:
//  ИмяСвойства			- Строка					- Имя проверяемого свойства
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Булево				- Истина - свойство используется; Ложь - свойство не используется
//
Функция ИспользоватьСвойство(Знач ИмяСвойства, Знач СписокСвойств = Неопределено, Знач ИсключаяСвойства = Неопределено)
	
	Если ТипЗнч(СписокСвойств) = Тип("Строка") Тогда
		СписокСвойств = СтрРазделитьВнутр(СписокСвойств, ",", Ложь);
	КонецЕсли;
	Если НЕ ТипЗнч(СписокСвойств) = Тип("Массив") Тогда
		СписокСвойств = Новый Массив();
	КонецЕсли;
	
	Если ТипЗнч(ИсключаяСвойства) = Тип("Строка") Тогда
		ИсключаяСвойства = СтрРазделитьВнутр(ИсключаяСвойства, ",", Ложь);
	КонецЕсли;
	Если НЕ ТипЗнч(ИсключаяСвойства) = Тип("Массив") Тогда
		ИсключаяСвойства = Новый Массив();
	КонецЕсли;
	
	Если СписокСвойств.Количество() = 0 И ИсключаяСвойства.Количество() = 0 Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если НЕ ИсключаяСвойства.Найти(ИмяСвойства) = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат (НЕ СписокСвойств.Найти(ИмяСвойства) = Неопределено) ИЛИ СписокСвойств.Количество() = 0;
	
КонецФункции // ИспользоватьСвойство()


// Функция, возвращает строковое представление типа данных
// 
// Параметры:
// 	ПарамТип  - Тип, Строка - тип данных
// 
// Возвращаемое значение:
// 	Строка    - строковое представление типа данных
//
Функция ПолучитьТипСтрокой(Знач ПарамТип) Экспорт
	
	МетаТип = Метаданные.НайтиПоТипу(ПарамТип);
	Если НЕ МетаТип = Неопределено Тогда
		 Возврат МетаТип.ПолноеИмя();
	КонецЕсли;
	
	ВремСтрока = СокрЛП(ПарамТип);
	Если Найти(ВремСтрока, " ") = 0 И Найти(ВремСтрока, "-") = 0 Тогда
		Возврат ВремСтрока;
	КонецЕсли;
	
	СтрокаТипа = "";
	ВерхнийРегистр = Истина;
	Для й = 1 По СтрДлина(ВремСтрока) Цикл
		Символ = Сред(ВремСтрока, й, 1);
		Если Символ = " " ИЛИ Символ = "-" Тогда
			ВерхнийРегистр = Истина;
			Продолжить;
		КонецЕсли;
		Если ВерхнийРегистр Тогда
			Символ = ВРег(Символ);
			ВерхнийРегистр = Ложь;
		КонецЕсли;
		СтрокаТипа = СтрокаТипа + Символ;
	КонецЦикла;
	
	Возврат СтрокаТипа;
	
КонецФункции // ПолучитьТипСтрокой()

// Преобразует описание типов в структуру
//
// Параметры:
//  ОписаниеТипов			- ОписаниеТипов				- Преобразуемое значение
//
// Возвращаемое значение:
//   Структура			- результат преобразования
//	   Типы							- Массив			- Список типов
//	   КвалификаторыЧисла			- Структура			- Описание квалификаторов числа
//		   Разрядность					- Число				- Разрядность
//		   РазрядностьДробнойЧасти		- Число				- Разрядность дробной части
//		   ДопустимыйЗнак				- ДопустимыйЗнак	- Допустимый знак
//	   КвалификаторыСтроки			- Структура			- Описание квалификаторов строки
//		   Длина						- Число				- Длина
//		   ДопустимаяДлина				- ДопустимаяДлина	- Разрядность дробной части
//	   КвалификаторыДаты			- Структура			- Описание квалификаторов даты
//		   ЧастиДаты					- ЧастиДаты			- Части даты (Дата / Время)
//	   КвалификаторыДвоичныхДанных	- Структура			- Описание квалификаторов двоичных данных
//		   Длина						- Число				- Длина
//		   ДопустимаяДлина				- ДопустимаяДлина	- Разрядность дробной части
//
Функция ОписаниеТиповВСтруктуру(ОписаниеТипов) Экспорт
	
	СтруктураОписаниеТипов = Новый Структура();
	СтруктураОписаниеТипов.Вставить("__Тип"                      , "ОписаниеТипов");
	СтруктураОписаниеТипов.Вставить("Типы"                       , Новый Массив());
	СтруктураОписаниеТипов.Вставить("КвалификаторыЧисла",
	                                Новый Структура("Разрядность, РазрядностьДробнойЧасти, ДопустимыйЗнак", 10, 0));
	СтруктураОписаниеТипов.Вставить("КвалификаторыСтроки",
	                                Новый Структура("Длина, ДопустимаяДлина", 10, "Переменная"));
	СтруктураОписаниеТипов.Вставить("КвалификаторыДаты",
	                                Новый Структура("ЧастиДаты", "ДатаВремя"));
	СтруктураОписаниеТипов.Вставить("КвалификаторыДвоичныхДанных",
	                                Новый Структура("Длина, ДопустимаяДлина", 0, "Переменная"));
								   
	Для Каждого ТекТип Из ОписаниеТипов.Типы() Цикл
		СтруктураОписаниеТипов.Типы.Добавить(ПолучитьТипСтрокой(ТекТип));
	КонецЦикла;
	
	СтруктураОписаниеТипов.КвалификаторыЧисла.Разрядность             = ОписаниеТипов.КвалификаторыЧисла.Разрядность;
	СтруктураОписаниеТипов.КвалификаторыЧисла.РазрядностьДробнойЧасти =
		ОписаниеТипов.КвалификаторыЧисла.РазрядностьДробнойЧасти;

	Если ОписаниеТипов.КвалификаторыЧисла.ДопустимыйЗнак = ДопустимыйЗнак.Неотрицательный Тогда
		СтруктураОписаниеТипов.КвалификаторыЧисла.ДопустимыйЗнак = "Неотрицательный";
	Иначе
		СтруктураОписаниеТипов.КвалификаторыЧисла.ДопустимыйЗнак = "Любой";
	КонецЕсли;
	
	СтруктураОписаниеТипов.КвалификаторыСтроки.Длина = ОписаниеТипов.КвалификаторыСтроки.Длина;

	Если ОписаниеТипов.КвалификаторыСтроки.ДопустимаяДлина = ДопустимаяДлина.Фиксированная Тогда
		СтруктураОписаниеТипов.КвалификаторыСтроки.ДопустимаяДлина = "Фиксированная";
	Иначе
		СтруктураОписаниеТипов.КвалификаторыСтроки.ДопустимаяДлина = "Переменная";
	КонецЕсли;
	
	Если ОписаниеТипов.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.Дата Тогда
		СтруктураОписаниеТипов.КвалификаторыДаты.ЧастиДаты = "Дата";
	ИначеЕсли ОписаниеТипов.КвалификаторыДаты.ЧастиДаты = ЧастиДаты.Время Тогда
		СтруктураОписаниеТипов.КвалификаторыДаты.ЧастиДаты = "Время";
	Иначе
		СтруктураОписаниеТипов.КвалификаторыДаты.ЧастиДаты = "ДатаВремя";
	КонецЕсли;
	
	СтруктураОписаниеТипов.КвалификаторыДвоичныхДанных.Длина = ОписаниеТипов.КвалификаторыДвоичныхДанных.Длина;
	
	Если ОписаниеТипов.КвалификаторыДвоичныхДанных.ДопустимаяДлина = ДопустимаяДлина.Фиксированная Тогда
		СтруктураОписаниеТипов.КвалификаторыДвоичныхДанных.ДопустимаяДлина = "Фиксированная";
	Иначе
		СтруктураОписаниеТипов.КвалификаторыДвоичныхДанных.ДопустимаяДлина = "Переменная";
	КонецЕсли;
		
	Возврат СтруктураОписаниеТипов;
	
КонецФункции // ОписаниеТиповВСтруктуру()

// Получает описание типов из структуры
//
// Параметры:
//   СтруктураОписаниеТипов			- Структура			- структура описания типов для преобразования
//	   Типы								- Массив			- Список типов
//	   КвалификаторыЧисла				- Структура			- Описание квалификаторов числа
//		   Разрядность						- Число				- Разрядность
//		   РазрядностьДробнойЧасти			- Число				- Разрядность дробной части
//		   ДопустимыйЗнак					- ДопустимыйЗнак	- Допустимый знак
//	   КвалификаторыСтроки				- Структура			- Описание квалификаторов строки
//		   Длина							- Число				- Длина
//		   ДопустимаяДлина					- ДопустимаяДлина	- Разрядность дробной части
//	   КвалификаторыДаты				- Структура			- Описание квалификаторов даты
//		   ЧастиДаты						- ЧастиДаты			- Части даты (Дата / Время)
//	   КвалификаторыДвоичныхДанных		- Структура			- Описание квалификаторов двоичных данных
//		   Длина							- Число				- Длина
//		   ДопустимаяДлина					- ДопустимаяДлина	- Разрядность дробной части
//
// Возвращаемое значение:
//  ОписаниеТипов			- Созданное описание типов
//
Функция ОписаниеТиповИзСтруктуры(СтруктураОписаниеТипов) Экспорт
	
	МассивТипов = Новый Массив();
	
	Для Каждого ТекТип Из СтруктураОписаниеТипов.Типы Цикл
		Попытка
			НовыйТип = Тип(СтрЗаменить(ТекТип, ".", "Ссылка."));
			МассивТипов.Добавить(НовыйТип);
		Исключение
			Продолжить;
		КонецПопытки;
	КонецЦикла;
		
	КвалификаторыЧисла = Новый КвалификаторыЧисла(СтруктураОписаниеТипов.КвалификаторыЧисла.Разрядность,
												  СтруктураОписаниеТипов.КвалификаторыЧисла.РазрядностьДробнойЧасти,
												  Вычислить("ДопустимыйЗнак." + СтруктураОписаниеТипов.КвалификаторыЧисла.ДопустимыйЗнак));
	
	КвалификаторыСтроки = Новый КвалификаторыСтроки(СтруктураОписаниеТипов.КвалификаторыСтроки.Длина,
													Вычислить("ДопустимаяДлина." + СтруктураОписаниеТипов.КвалификаторыСтроки.ДопустимаяДлина));
	
	КвалификаторыДаты =
		Новый КвалификаторыДаты(Вычислить("ЧастиДаты." + СтруктураОписаниеТипов.КвалификаторыДаты.ЧастиДаты));
	
	КвалификаторыДвоичныхДанных = Новый КвалификаторыДвоичныхДанных(СтруктураОписаниеТипов.КвалификаторыСтроки.Длина,
																	Вычислить("ДопустимаяДлина." + СтруктураОписаниеТипов.КвалификаторыДвоичныхДанных.ДопустимаяДлина));
																		  
	Возврат Новый ОписаниеТипов(МассивТипов,
								КвалификаторыЧисла,
								КвалификаторыСтроки,
								КвалификаторыДаты,
								КвалификаторыДвоичныхДанных);
	
КонецФункции // ОписаниеТиповИзСтруктуры()

// Функция, возвращает признак использования реквизита иерархического объекта
// 
// Параметры:
// 	Объект         - СправочникОбъект, СправочникСсылка                         - проверяемый объект 
// 	                 ПланВидовХарактеристикОбъект, ПланВидовХарактеристикСсылка
// 	МетаСвойство   - ОбъектМетаданныхРеквизит                                   - проверяемый реквизит
// 	МетаОбъект     - ОбъектМетаданных                                           - метаданные проверяемого объекта
//
// Возвращаемое значение:
// 	Булево         - Истина - реквизит используется для объекта,
//                 - Ложь - в противном случае
//
Функция СвойствоИерархическогоОбъектаИспользуется(Объект, МетаСвойство, МетаОбъект = Неопределено)

	Если МетаОбъект = Неопределено Тогда
		МетаОбъект = Объект.Метаданные();
	КонецЕсли;

	Если НЕ МетаОбъект.Иерархический Тогда
		Возврат Истина;
	КонецЕсли;

	Если СтрокаНачиснаетсяСВнутр(МетаОбъект.ПолноеИмя(), "Справочник.")
	   И МетаОбъект.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов
	 ИЛИ СтрокаНачиснаетсяСВнутр(МетаОбъект.ПолноеИмя(), "ПланВидовХарактеристик.") Тогда
		
		Если (Объект.ЭтоГруппа
			  И МетаСвойство.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
		 ИЛИ (НЕ Объект.ЭтоГруппа
		      И МетаСвойство.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы) Тогда
		
			Возврат Ложь;

		КонецЕсли;
		
	КонецЕсли;

	Возврат Истина;

КонецФункции // СвойствоОбъектаИспользуется()

// Проверяет использование свойства объекта и добавляет в структуру
//
// Параметры:
//  СтруктураОбъекта	- Структура					- Заполняемая структура объекта
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура СвойствоОбъектаВСтруктуру(СтруктураОбъекта
								  , Объект
								  , ИмяСвойства
								  , СписокСвойств = Неопределено
								  , ИсключаяСвойства = Неопределено)
	
	Если НЕ ИспользоватьСвойство(ИмяСвойства, СписокСвойств, ИсключаяСвойства) Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураОбъекта.Вставить(ИмяСвойства, ЗначениеВСтруктуру(Объект[ИмяСвойства]));
	
КонецПроцедуры // СвойствоОбъектаВСтруктуру()
	
// Проверяет использование свойства объекта и заполняет значение свойства из структуры
//
// Параметры:
//  Объект              - Объект                  - Заполняемый объект
//  СтруктураОбъекта    - Структура               - Структура объекта
//  ПолучатьБитыеСсылки - Булево                  - Истина - если объект по ссылке не существует,
//                                                  будет возвращена битая ссылка;
//                                                  Ложь - будет возвращена пустая ссылка
//  СписокСвойств       - Строка, Массив(Строка)  - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)  - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура СвойствоОбъектаИзСтруктуры(Объект
	                               , СтруктураОбъекта
	                               , ИмяСвойства
	                               , ПолучатьБитыеСсылки = Ложь
	                               , СписокСвойств = Неопределено
	                               , ИсключаяСвойства = Неопределено)
	
	Если НЕ СтруктураОбъекта.Свойство(ИмяСвойства) Тогда
		Возврат;
	КонецЕсли;
	
	Если НЕ ИспользоватьСвойство(ИмяСвойства, СписокСвойств, ИсключаяСвойства) Тогда
		Возврат;
	КонецЕсли;
	
	Объект[ИмяСвойства] = ЗначениеИзСтруктуры(СтруктураОбъекта[ИмяСвойства], ПолучатьБитыеСсылки);
	
КонецПроцедуры // СвойствоОбъектаИзСтруктуры()
	
// Добавляет данные табличной части объекта в структуру
//
// Параметры:
//  СтруктураОбъекта	- Структура					- Заполняемая структура объекта
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  ИмяТЧ				- Строка					- Имя преобразуемой табличной части
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ТЧОбъектаВСтруктуру(СтруктураОбъекта
							, Объект
							, ИмяТЧ
							, СписокСвойств = Неопределено
							, ИсключаяСвойства = Неопределено)
	
	Если НЕ ИспользоватьСвойство("__ТЧ." + ИмяТЧ, СписокСвойств, ИсключаяСвойства) Тогда
		Возврат;
	КонецЕсли;
	
	Если НЕ СтруктураОбъекта.Свойство("__ТЧ") Тогда
		СтруктураОбъекта.Вставить("__ТЧ", Новый Структура());
	КонецЕсли;
	
	МетаОбъект = Объект.Метаданные();
	
	МетаТЧ = МетаОбъект.ТабличныеЧасти.Найти(ИмяТЧ);
	
	Если МетаТЧ = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	МассивСтрок = Новый Массив();
	Для Каждого ТекСтрока Из Объект[ИмяТЧ] Цикл
		
		СтруктураСтроки = Новый Структура();
		СтруктураСтроки.Вставить("__Индекс", Объект[ИмяТЧ].Индекс(ТекСтрока));
		СтруктураСтроки.Вставить("НомерСтроки", ТекСтрока.НомерСтроки);
		
		Для Каждого ТекРеквизит Из МетаТЧ.Реквизиты Цикл
			Если НЕ ИспользоватьСвойство(ИмяТЧ + "." + ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекРеквизит.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекРеквизит.Имя]));
		КонецЦикла;
		
		МассивСтрок.Добавить(СтруктураСтроки);
		
	КонецЦикла;
	
	СтруктураОбъекта.__ТЧ.Вставить(ИмяТЧ, МассивСтрок);
	
КонецПроцедуры // ТЧОбъектаВСтруктуру()

// Заполняет табличную часть объекта из структуры
//
// Параметры:
//  Объект				- Объект, ЛюбаяСсылка     - Заполняемый объект
//  СтруктураОбъекта	- Структура               - Структура данных объекта
//  ИмяТЧ				- Строка                  - Имя преобразуемой табличной части
//  ПолучатьБитыеСсылки - Булево                  - Истина - если объект по ссылке не существует,
//                                                  будет возвращена битая ссылка;
//                                                  Ложь - будет возвращена пустая ссылка
//  СписокСвойств       - Строка, Массив(Строка)  - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)  - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ТЧОбъектаИзСтруктуры(Объект
	                         , СтруктураОбъекта
	                         , ИмяТЧ
	                         , ПолучатьБитыеСсылки = Ложь
	                         , СписокСвойств = Неопределено
	                         , ИсключаяСвойства = Неопределено)
	
	Если НЕ СтруктураОбъекта.Свойство("__ТЧ") Тогда
		Возврат;
	КонецЕсли;
		
	Если НЕ СтруктураОбъекта.__ТЧ.Свойство(ИмяТЧ) Тогда
		Возврат;
	КонецЕсли;
		
	Если НЕ ИспользоватьСвойство("__ТЧ." + ИмяТЧ, СписокСвойств, ИсключаяСвойства) Тогда
		Возврат;
	КонецЕсли;
	
	МетаОбъект = Объект.Метаданные();
	
	МетаТЧ = МетаОбъект.ТабличныеЧасти.Найти(ИмяТЧ);
	
	Если МетаТЧ = Неопределено Тогда
		Возврат;
	КонецЕсли;

	Объект[ИмяТЧ].Очистить();
	
	МассивСтрок = СтруктураОбъекта.__ТЧ[ИмяТЧ];
	
	Для Каждого ТекСтрока Из МассивСтрок Цикл
		
		НоваяСтрока = Объект[ИмяТЧ].Добавить();
		
		Для Каждого ТекРеквизит Из МетаТЧ.Реквизиты Цикл
			
			Если НЕ ТекСтрока.Свойство(ТекРеквизит.Имя) Тогда
				Продолжить;
			КонецЕсли;
			
			Если НЕ ИспользоватьСвойство(ИмяТЧ + "." + ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			
			НоваяСтрока[ТекРеквизит.Имя] = ЗначениеИзСтруктуры(ТекСтрока[ТекРеквизит.Имя], ПолучатьБитыеСсылки);
			
		КонецЦикла;
		
	КонецЦикла;
	
КонецПроцедуры // ТЧОбъектаИзСтруктуры()
	
// Преобразует значения субконто записи регистра бухгалтерии в структуру
//
// Параметры:
//  Запись				- РегистрБухгалтерииЗапись	- Преобразуемая запись регистра бухгалтерии
//  ДтКт				- Строка					- признак Дт/Кт - "Дт", "Кт", "" 
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Массив(Структура)			- результат преобразования
//		НомерСтроки		- Число								- Номер субконто
//		ВидСубконто		- ПланВидовХарактеристикСсылка		- Вид субконто
//		Значение		- Произвольный						- Значение субконто
//
Функция ЗначенияСубконтоЗаписиВСтруктуру(Запись
									   , ДтКт
									   , СписокСвойств = Неопределено
									   , ИсключаяСвойства = Неопределено)
	
	ВидыСубконто = Запись["Счет" + ДтКт].ВидыСубконто;
	ЗначенияСубконто = Запись["Субконто" + ДтКт];
	
	МассивСубконто = Новый Массив();
	й = 1;
	Для Каждого ТекСтрокаВида Из ВидыСубконто Цикл
		Если НЕ ИспользоватьСвойство("Субконто" + ДтКт + Формат(й, "ЧДЦ=; ЧГ="), СписокСвойств, ИсключаяСвойства) Тогда
			й = й + 1;
			Продолжить;
		КонецЕсли;
		МассивСубконто.Добавить(Новый Структура("НомерСтроки, ВидСубконто, Значение"
												, й
												, ЗначениеВСтруктуру(ТекСтрокаВида.ВидСубконто)
												, ЗначениеВСтруктуру(ЗначенияСубконто[ТекСтрокаВида.ВидСубконто])));
		й = й + 1;
	КонецЦикла;
	
	Возврат МассивСубконто;
	
КонецФункции // ЗначенияСубконтоВСтруктуру()

// Заполняет значения субконто записи регистра бухгалтерии из структуры
//
// Параметры:
//  Запись              - РегистрБухгалтерииЗапись  - Заполняемая запись регистра бухгалтерии
//  СтруктураЗаписи     - Структура                 - Структура данных записи регистра бухгалтерии 
//  ДтКт                - Строка                    - признак Дт/Кт - "Дт", "Кт", "" 
//  ПолучатьБитыеСсылки - Булево                    - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//  СписокСвойств       - Строка, Массив(Строка)    - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)    - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ЗначенияСубконтоЗаписиИзСтруктуры(Запись
	                                      , СтруктураЗаписи
	                                      , ДтКт
	                                      , ПолучатьБитыеСсылки = Ложь
	                                      , СписокСвойств = Неопределено
	                                      , ИсключаяСвойства = Неопределено)
	
	ВидыСубконто = Запись["Счет" + ДтКт].ВидыСубконто;
	ЗначенияСубконто = Запись["Субконто" + ДтКт];
	
	МассивСубконто = СтруктураЗаписи["Субконто" + ДтКт];
	
	й = 1;
	Для Каждого ТекСтрока Из МассивСубконто Цикл
		
		Если НЕ ИспользоватьСвойство("Субконто" + ДтКт + Формат(й, "ЧДЦ=; ЧГ="), СписокСвойств, ИсключаяСвойства) Тогда
			й = й + 1;
			Продолжить;
		КонецЕсли;
		
		ВидСубконто = ЗначениеИзСтруктуры(ТекСтрока.ВидСубконто, ПолучатьБитыеСсылки);
		
		Если НЕ ЗначениеЗаполнено(ВидСубконто) Тогда
			й = й + 1;
			Продолжить;
		КонецЕсли;
		
		СтрокаВида = ВидыСубконто.Найти(ВидСубконто, "ВидСубконто");
		
		Если СтрокаВида = Неопределено Тогда
			й = й + 1;
			Продолжить;
		КонецЕсли;
		
		ЗначенияСубконто[ВидСубконто] = ЗначениеИзСтруктуры(ТекСтрока.Значение, ПолучатьБитыеСсылки);
		
		й = й + 1;
		
	КонецЦикла;
	
КонецПроцедуры // ЗначенияСубконтоИзСтруктуры()

// Заполняет значение измерения записи регистра бухгалтерии из структуры
// с учетом признаков учета счета
//
// Параметры:
//  Запись               - РегистрБухгалтерииЗапись    - Заполняемая запись регистра бухгалтерии
//  СтруктураЗаписи      - Структура                   - Структура данных записи регистра бухгалтерии 
//  ОписаниеПоля         - ОбъектМетаданных.Измерение  - Описание метаданных измерения регистра 
//  ДтКт                 - Строка                      - признак Дт/Кт - "Дт", "Кт", "" 
//  ПолучатьБитыеСсылки  - Булево                      - Истина - если объект по ссылке не существует,
//                                                       будет возвращена битая ссылка;
//                                                       Ложь - будет возвращена пустая ссылка
//  СписокСвойств        - Строка, Массив(Строка)      - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства     - Строка, Массив(Строка)      - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ЗаполнитьИзмерениеРегистраБухгалтерии(Запись
                                              , СтруктураЗаписи
                                              , ОписаниеПоля
                                              , ДтКт
                                              , ПолучатьБитыеСсылки = Ложь  
                                              , СписокСвойств = Неопределено
                                              , ИсключаяСвойства = Неопределено)
	
	Если НЕ (СтруктураЗаписи.Свойство(ОписаниеПоля.Имя + ДтКт)
			 И ИспользоватьСвойство(ОписаниеПоля.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
		Возврат;
	КонецЕсли;
	
	ЗаполнятьЗначение = Истина;
	
	Если НЕ ОписаниеПоля.ПризнакУчета = Неопределено Тогда
		Если НЕ Запись["Счет" + ДтКт][ОписаниеПоля.ПризнакУчета.Имя] Тогда
			ЗаполнятьЗначение = Ложь;
			Запись[ОписаниеПоля.Имя + ДтКт] = NULL;
		КонецЕсли;
	КонецЕсли;
	
	Если ЗаполнятьЗначение Тогда
		Запись[ОписаниеПоля.Имя + ДтКт] = ЗначениеИзСтруктуры(СтруктураЗаписи[ОписаниеПоля.Имя + ДтКт],
		                                                      ПолучатьБитыеСсылки);
	КонецЕсли;
	
КонецПроцедуры // ЗаполнитьИзмерениеРегистраБухгалтерии()

// Заполняет значение ресурса записи регистра бухгалтерии из структуры
// с учетом признаков учета счета
//
// Параметры:
//  Запись              - РегистрБухгалтерииЗапись      - Заполняемая запись регистра бухгалтерии
//  СтруктураЗаписи     - Структура                     - Структура данных записи регистра бухгалтерии 
//  ОписаниеПоля        - ОбъектМетаданных.Ресурс       - Описание метаданных ресурса регистра 
//  ДтКт                - Строка                        - признак Дт/Кт - "Дт", "Кт", "" 
//  СписокСвойств       - Строка, Массив(Строка)        - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)        - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ЗаполнитьРесурсРегистраБухгалтерии(Запись,
                                             СтруктураЗаписи,
                                             ОписаниеПоля,
                                             ДтКт,
                                             СписокСвойств,
                                             ИсключаяСвойства)
	
	Если НЕ (СтруктураЗаписи.Свойство(ОписаниеПоля.Имя + ДтКт)
			 И ИспользоватьСвойство(ОписаниеПоля.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
		Возврат;
	КонецЕсли;
	
	ЗаполнятьЗначение = Истина;
	
	Если НЕ ОписаниеПоля.ПризнакУчета = Неопределено Тогда
		Если НЕ Запись["Счет" + ДтКт][ОписаниеПоля.ПризнакУчета.Имя] Тогда
			ЗаполнятьЗначение = Ложь;
			Запись[ОписаниеПоля.Имя + ДтКт] = NULL;
		КонецЕсли;
	КонецЕсли;
	
	Если ЗаполнятьЗначение Тогда
		Запись[ОписаниеПоля.Имя + ДтКт] = ЗначениеИзСтруктуры(СтруктураЗаписи[ОписаниеПоля.Имя + ДтКт]);
	КонецЕсли;
	
КонецПроцедуры // ЗаполнитьРесурсРегистраБухгалтерии()

#КонецОбласти // ПреобразованияОбъектовСлужебные

#Область ПреобразованиеОбъектовОбработчики

// Получает правило преобразования в структуру для указанного типа значений
//
// Параметры:
//  ПолноеИмяТипа         - Строка    - Имя типа преобразуемого значения
//
// Возвращаемое значение:
//	Структура					- Правило выгрузки типа
//		ФункцияДополнения - Строка    - имя функции дополнительной обработки данных при выгрузке
//		Модуль            - Модуль    - модуль из которого будет вызвана функция дополнения
//
Функция ПолучитьПравилоВыгрузкиТипа(ПолноеИмяТипа)
	
	Правила = ПолучитьПравилаВыгрузкиТипов();
	
	Возврат Правила[ПолноеИмяТипа];
	
КонецФункции // ПолучитьПравилоВыгрузкиТипа()

// Добавляет правило преобразования в структуру для указанного типа значений
//
// Параметры:
//	ТипИсточника           - Строка                   - Имя типа преобразуемого значения
//	ФункцияДополнения      - Строка                   - Имя функции преобразования значения
//  Модуль                 - УправляемаяФорма, Модуль - модуль, содержащий функцию дополнения,
//                                                      Неопределено - функция будет вызвана
//                                                      из модуля обработки (этот модуль)
//
Процедура ДобавитьПравилоВыгрузкиТипа(ТипИсточника, ФункцияДополнения, Модуль = Неопределено) Экспорт
	
	Если НЕ ТипЗнч(ПравилаВыгрузкиТипов) = Тип("Соответствие") Тогда
		ПравилаВыгрузкиТипов = Новый Соответствие();
	КонецЕсли;
	
	ПравилаВыгрузкиТипов.Вставить(ТипИсточника, Новый Структура("ФункцияДополнения, Модуль", ФункцияДополнения, Модуль));
	
КонецПроцедуры // ДобавитьПравилоВыгрузкиТипа()

// Переопределяемая процедура, позволяющая дополнить алгоритмы преобразования данных в структуру
//
// Параметры:
//
// Возвращаемое значение:
//   Соответствие			- правила выгрузки типов
//		<ТипЗначения>			- Структура			- Имя выгружаемого типа значения
//			ФункцияДополнения	- Строка			- Имя функции дополнительной обработки данных при выгрузке
//
Функция ПолучитьПравилаВыгрузкиТипов()
	
	Если НЕ ТипЗнч(ПравилаВыгрузкиТипов) = Тип("Соответствие") Тогда
		ПравилаВыгрузкиТипов = Новый Соответствие();
	КонецЕсли;
	
	Возврат ПравилаВыгрузкиТипов;
	
КонецФункции // ПолучитьПравилаВыгрузкиТипов()

// Получает правило преобразования данных из структуры для указанного типа значений
//
// Параметры:
//  ПолноеИмяТипа			- Строка				- Имя типа преобразуемого значения
//
// Возвращаемое значение:
//	Структура					- Правило выгрузки типа
//		ТипЗначения			- Строка			- Имя типа значения целевых данных
//		ФункцияПоиска		- Строка			- Имя функции поиска значения
//
Функция ПолучитьПравилоЗагрузкиТипа(ПолноеИмяТипа)
	
	Правила = ПолучитьПравилаЗагрузкиТипов();
	
	Правило = Правила[ПолноеИмяТипа];
	
	Если Правило = Неопределено Тогда
		Правило = Новый Структура("ТипЗначения, ФункцияПоиска, Модуль", ПолноеИмяТипа, "НайтиЗначениеПоОписанию");
	КонецЕсли;
	
	Возврат Правило;
	
КонецФункции // ПолучитьПравилоЗагрузкиТипа()

// Добавляет правило преобразования данных из структуры для указанного типа значений
//
// Параметры:
//	ТипИсточника             - Строка                   - Имя типа преобразуемого значения
//	ТипПриемника             - Строка                   - Имя типа целевого значения
//	ФункцияПоиска            - Строка                   - Имя функции поиска значения
//  Модуль                   - УправляемаяФорма, Модуль - модуль, содержащий функцию поиска,
//                                                        Неопределено - функция будет вызвана
//                                                        из модуля обработки (этот модуль)
//
Процедура ДобавитьПравилоЗагрузкиТипа(ТипИсточника, ТипПриемника, ФункцияПоиска, Модуль = Неопределено) Экспорт
	
	Если НЕ ТипЗнч(ПравилаЗагрузкиТипов) = Тип("Соответствие") Тогда
		ПравилаЗагрузкиТипов = Новый Соответствие();
	КонецЕсли;
	
	ПравилаЗагрузкиТипов.Вставить(ТипИсточника, Новый Структура());
	ПравилаЗагрузкиТипов[ТипИсточника].Вставить("ТипЗначения"  , ТипПриемника);
	ПравилаЗагрузкиТипов[ТипИсточника].Вставить("ФункцияПоиска", ФункцияПоиска);
	ПравилаЗагрузкиТипов[ТипИсточника].Вставить("Модуль"       , Модуль);
	
КонецПроцедуры // ДобавитьПравилоЗагрузкиТипа()

// Переопределяемая процедура, позволяющая дополнить алгоритмы преобразования данных из структуры
//
// Параметры:
//
// Возвращаемое значение:
//   Соответствие(Структура)			- правила выгрузки типов
//		<ТипЗначения>			- Строка			- Имя типа значения преобразованных данных
//		ТипЗначения					- Строка			- Имя типа значения целевых данных
//		ФункцияПоиска				- Строка			- Имя функции поиска значения
//
Функция ПолучитьПравилаЗагрузкиТипов()
	
	Если НЕ ТипЗнч(ПравилаЗагрузкиТипов) = Тип("Соответствие") Тогда
		ПравилаЗагрузкиТипов = Новый Соответствие();
	КонецЕсли;
	
	Возврат ПравилаЗагрузкиТипов;
	
КонецФункции // ПолучитьПравилаЗагрузкиТипов()

// Функция поиска значений по структуре описания (шаблон процедуры поиска)
// Ищет значение по имени предопределенных данных, затем по полному иидентификатору, затем по представлению (наименованию)
//
// Параметры:
//		ОписаниеВида			- Структура				- Описание вида значения
//		МетаОбъект				- ОписаниеМетаданных	- Описание метаданных обрабатываемого типа значений
// 		ОписаниеЗначения		- Структура				- Структура значения для обработки
//
// Возвращаемое значение:
//   ЛюбаяСсылка			- найденное значение
//
//@skip-warning
Функция НайтиЗначениеПоОписанию(ОписаниеВида, МетаОбъект, ОписаниеЗначения)
	
	Коллекция = ОписаниеВида.Коллекция;
	
	Если ЗначениеЗаполнено(ОписаниеЗначения.ИмяПредопределенныхДанных) Тогда
		Если ВРег(ОписаниеВида.Имя) = ВРег("ПланОбмена")
		   И ВРег(ОписаниеЗначения.ИмяПредопределенныхДанных) = ВРег("ЭтотУзел") Тогда
			Возврат Коллекция[МетаОбъект.Имя].ЭтотУзел();
		Иначе
			Возврат Коллекция[МетаОбъект.Имя][ОписаниеЗначения.ИмяПредопределенныхДанных];
		КонецЕсли;
	Иначе
		ВремСсылка = ЗначениеИзСтрокиВнутр(ОписаниеЗначения.ИдПолный);
		Если СсылкаСуществует(ВремСсылка) Тогда
			Возврат ВремСсылка;
		КонецЕсли;
		
		Если ОписаниеЗначения.Свойство("ИдПолный")
		   И Найти(ОписаниеЗначения.ИдПолный, "00000000000000000000000000000000") = 0 Тогда
			ВремСсылка = Коллекция[МетаОбъект.Имя].ПолучитьСсылку(Новый УникальныйИдентификатор(ОписаниеЗначения.Ид));
			Если СсылкаСуществует(ВремСсылка) Тогда
				Возврат ВремСсылка;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ОписаниеЗначения.Представление)
	   И (ВРег(ОписаниеВида.Имя) = ВРег("Справочник")
			ИЛИ ВРег(ОписаниеВида.Имя) = ВРег("ПланВидовХарактеристик")
			ИЛИ ВРег(ОписаниеВида.Имя) = ВРег("ПланСчетов")
			ИЛИ ВРег(ОписаниеВида.Имя) = ВРег("ПланВидовРасчета")
			ИЛИ ВРег(ОписаниеВида.Имя) = ВРег("ПланОбмена")
			ИЛИ ВРег(ОписаниеВида.Имя) = ВРег("Задача")) Тогда
		
		ВремСсылка = Коллекция[МетаОбъект.Имя].НайтиПоНаименованию(ОписаниеЗначения.Представление, Истина); 
		Если НЕ ВремСсылка.Пустая() Тогда
			Возврат ВремСсылка;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Коллекция[МетаОбъект.Имя].ПустаяСсылка();
	
КонецФункции // НайтиЗначениеПоОписанию()

#КонецОбласти // ПреобразованиеОбъектовОбработчики

#Область ПреобразованияJSON

// Функция - возвращает представление описания объекта в текстовом формате JSON
//
// Параметры:
//  ОписаниеОбъекта	 - Структура, Массив(Структура)	 - описание объекта для преобразования
// 
// Возвращаемое значение:
//  Строка - представление описания объекта в текстовом формате JSON
//
Функция ЗаписатьОписаниеОбъектаВJSON(Знач ОписаниеОбъекта) Экспорт
	
	Запись = Новый ЗаписьJSON();
	Запись.УстановитьСтроку(Новый ПараметрыЗаписиJSON(ПереносСтрокJSON.Unix, Символы.Таб));
	
	НастройкиСериализации = Новый НастройкиСериализацииJSON();
	НастройкиСериализации.ВариантЗаписиДаты = ВариантЗаписиДатыJSON.УниверсальнаяДата;
	НастройкиСериализации.ФорматСериализацииДаты = ФорматДатыJSON.Microsoft;
	
	Попытка
		ЗаписатьJSON(Запись, ОписаниеОбъекта, НастройкиСериализации, "ОбработчикЗаписиЗначенийJSON", ЭтотОбъект);
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	Возврат Запись.Закрыть();
	
КонецФункции // ЗаписатьОписаниеОбъектаВJSON()

// Функция - возвращает описание объекта, прочитанное из текстового формата JSON
//
// Параметры:
//  ТекстОписанияОбъекта       - Строка           - представление описания объекта в текстовом формате JSON
//  СвойстваСоЗначениемДата    - Массив, Строка   - список свойств, которые должны быть преобразованы в формат даты
// 
// Возвращаемое значение:
//  Структура, Массив(Структура)	 - описание объекта 
//
Функция ПрочитатьОписаниеОбъектаИзJSON(Знач ТекстОписанияОбъекта, Знач СвойстваСоЗначениемДата = Неопределено) Экспорт
	
	Чтение = Новый ЧтениеJSON();
	Чтение.УстановитьСтроку(ТекстОписанияОбъекта);
		
	Если ТипЗнч(СвойстваСоЗначениемДата) = Тип("Строка") Тогда
		СвойстваСоЗначениемДата = СтрРазделитьВнутр(СвойстваСоЗначениемДата, ",", Ложь);
	КонецЕсли;

	Если НЕ ТипЗнч(СвойстваСоЗначениемДата) = Тип("Массив") Тогда
		СвойстваСоЗначениемДата = Новый Массив();
	КонецЕсли;
		
	Попытка
		Возврат ПрочитатьJSON(Чтение,
		                      Ложь,
		                      СвойстваСоЗначениемДата,
		                      ФорматДатыJSON.Microsoft,
		                      "ОбработчикЧтенияЗначенийJSON",
		                      ЭтотОбъект);
	Исключение
		ТекстОшибки = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
КонецФункции // ПрочитатьОписаниеОбъектаИзJSON()


// Обработчик записи значений JSON
// 
Функция ОбработчикЗаписиЗначенийJSON(Свойство, Значение, ДополнительныеПараметры, Отказ) Экспорт
	
	Если ТипЗнч(Значение) = Тип("ХранилищеЗначения") Тогда
		Значение = "/ValueStorage(" + ЗначениеВСтрокуВнутр(Значение) + ")/";
	ИначеЕсли ТипЗнч(Значение) = Тип("УникальныйИдентификатор") Тогда
		Значение = "/UniqueID(" + СокрЛП(Значение) + ")/";
	ИначеЕсли ТипЗнч(Значение) = Тип("NULL") Тогда
		Значение = "/NULL()/";
	ИначеЕсли ТипЗнч(Значение) = Тип("Неопределено") Тогда
		Значение = "/Undefined()/";
	Иначе
		Значение = "/UnknownType(" + ЗначениеВСтрокуВнутр(Значение) + ")/";
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции // ОбработчикЗаписиЗначенийJSON()

// Обработчик чтения значений JSON
// 
Функция ОбработчикЧтенияЗначенийJSON(Свойство, Значение, ДополнительныеПараметры) Экспорт
	
	Если ТипЗнч(Значение) = Тип("Строка") Тогда
		Если СтрокаНачиснаетсяСВнутр(Значение, "/Date(") Тогда
			Значение = ПрочитатьДатуJSON(Значение, ФорматДатыJSON.Microsoft);
			Если Значение < '00020101000000' Тогда
				Значение = '00010101000000';
			КонецЕсли;
		ИначеЕсли СтрокаНачиснаетсяСВнутр(Значение, "/ValueStorage(") Тогда
			Если Прав(Значение, 2) = ")/" Тогда
				Значение = ЗначениеИзСтрокиВнутр(Сред(Значение, 15, СтрДлина(Значение) - 16));
			КонецЕсли;
		ИначеЕсли СтрокаНачиснаетсяСВнутр(Значение, "/UniqueID(") Тогда
			Если Прав(Значение, 2) = ")/" Тогда
				Значение = Новый УникальныйИдентификатор(Сред(Значение, 11, СтрДлина(Значение) - 12));
			КонецЕсли;
		ИначеЕсли Значение = "/NULL()/" Тогда
			Значение = NULL;
		ИначеЕсли Значение = "/Undefined()/" Тогда
			Значение = Неопределено;
		ИначеЕсли СтрокаНачиснаетсяСВнутр(Значение, "/UnknownType(") Тогда
			Если Прав(Значение, 2) = ")/" Тогда
				Значение = ЗначениеИзСтрокиВнутр(Сред(Значение, 14, СтрДлина(Значение) - 15));
			КонецЕсли;
		Иначе
			Возврат Значение;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Значение;
	
КонецФункции // ОбработчикЧтенияЗначенийJSON()

#КонецОбласти // ПреобразованияJSON

#Область ПреобразованияКоллекций

// Функция определяет тип значения, сохраненного в массив или структуру
// для преобразования в значение 1С
//
// Параметры:
//		СтруктураЗначения		- Структура, Массив		- Проверяемое значения
//
// Возвращаемое значение:
//   Тип			- Тип 1С (Массив, Структура, Соответствие, СписокЗначений, ТаблицаЗначений, ДеревоЗначений, ЛюбаяСсылка)
//
Функция СтруктураТипЗнч(СтруктураЗначения)
	
	Если ТипЗнч(СтруктураЗначения) = Тип("Массив") Тогда
			Если СтруктураЗначения.Количество() = 0 Тогда
			Возврат Тип("Массив");
		КонецЕсли;
		Если ТипЗнч(СтруктураЗначения[0]) = Тип("Структура") Тогда
			Если СтруктураЗначения[0].Свойство("Ключ")
			   И СтруктураЗначения[0].Свойство("Значение") Тогда
				Возврат Тип("Соответствие");
			ИначеЕсли СтруктураЗначения[0].Свойство("Представление")
			   И СтруктураЗначения[0].Свойство("Значение")
			   И СтруктураЗначения[0].Свойство("Пометка") Тогда
				Возврат Тип("СписокЗначений");
			Иначе
				Возврат Тип("ТаблицаЗначений");
			КонецЕсли;
		КонецЕсли;
		Возврат Тип("Массив");
	ИначеЕсли ТипЗнч(СтруктураЗначения) = Тип("Структура") Тогда
		Если СтруктураЗначения.Свойство("__Тип") Тогда
			Возврат Тип(СтруктураЗначения.__Тип);
		КонецЕсли;
		Если СтруктураЗначения.Свойство("Тип")
		   И СтруктураЗначения.Свойство("Ид")
		   И СтруктураЗначения.Свойство("ИдПолный") Тогда
			Если СтруктураЗначения.Свойство("Ссылка") Тогда
				ПравилоЗагрузки = ПолучитьПравилоЗагрузкиТипа(СтруктураЗначения.Ссылка.Тип);
				Возврат Тип(СтрЗаменить(ПравилоЗагрузки.ТипЗначения, ".", "Объект."));
			Иначе
				ПравилоЗагрузки = ПолучитьПравилоЗагрузкиТипа(СтруктураЗначения.Тип);
				Возврат Тип(СтрЗаменить(ПравилоЗагрузки.ТипЗначения, ".", "Ссылка."));
			КонецЕсли;
		КонецЕсли;
		Если СтруктураЗначения.Свойство("Типы")
		   И СтруктураЗначения.Свойство("КвалификаторыСтроки")
		   И СтруктураЗначения.Свойство("КвалификаторыЧисла")
		   И СтруктураЗначения.Свойство("КвалификаторыДаты") Тогда
			Если ТипЗнч(СтруктураЗначения.Типы) = Тип("Массив") Тогда
				Возврат Тип("ОписаниеТипов");
			КонецЕсли;
		КонецЕсли;
		Если СтруктураЗначения.Свойство("Строки") Тогда
			Если ТипЗнч(СтруктураЗначения.Строки) = Тип("Массив") Тогда
				Возврат Тип("ДеревоЗначений");
			КонецЕсли;
		КонецЕсли;
		Возврат Тип("Структура");
	Иначе
		Возврат ТипЗнч(СтруктураЗначения);
	КонецЕсли;
	
КонецФункции // СтруктураТипЗнч()

// Функция рекурсивно преобразует структуру значений в структуру с "простыми" типами
//
// Параметры:
//		Значение		- Структура		- Значение для преобразования
//
// Возвращаемое значение:
//   Структура			           - Результат преобразования
//   	*__Тип       - Строка			- тип значения (Структура, ФиксированнаяСтруктура)
//   	*<элемент>   - Произвольный     - элемент структуры
//
Функция СтруктураВСтруктуру(Значение)
	
	ВремСтруктура = Новый Структура();

	Если ТипЗнч(Значение) = Тип("Структура") Тогда
		ВремСтруктура.Вставить("__Тип", "Структура");
	ИначеЕсли ТипЗнч(Значение) = Тип("ФиксированнаяСтруктура") Тогда
		ВремСтруктура.Вставить("__Тип", "ФиксированнаяСтруктура");
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	Если НЕ (ТипЗнч(Значение) = Тип("Структура")
		  ИЛИ ТипЗнч(Значение) = Тип("ФиксированнаяСтруктура")) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Для Каждого ТекЭлемент Из Значение Цикл
		ВремСтруктура.Вставить(ТекЭлемент.Ключ, ЗначениеВСтруктуру(ТекЭлемент.Значение));
	КонецЦикла;
	
	Возврат ВремСтруктура;
	
КонецФункции // СтруктураВСтруктуру()

// Функция рекурсивно преобразует структуру с "простыми" типами значений в структуру значений 1С
//
// Параметры:
//		СтруктураЗначения		- Структура		- Значение для преобразования
//  ПолучатьБитыеСсылки         - Булево        - Истина - если объект по ссылке не существует,
//                                                будет возвращена битая ссылка;
//                                                Ложь - будет возвращена пустая ссылка
//
// Возвращаемое значение:
//   Структура, ФиксированнаяСтруктура			- Результат преобразования
//
Функция СтруктураИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки = Ложь)
	
	Если НЕ ТипЗнч(СтруктураЗначения) = Тип("Структура") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ВремСтруктура = Новый Структура();
	
	Тип = "Структура";
	
	Для Каждого ТекЭлемент Из СтруктураЗначения Цикл
		Если ВРег(ТекЭлемент.Ключ) = ВРег("__Тип") Тогда
			Тип = ТекЭлемент.Значение;
		КонецЕсли;
		ВремСтруктура.Вставить(ТекЭлемент.Ключ, ЗначениеИзСтруктуры(ТекЭлемент.Значение, ПолучатьБитыеСсылки));
	КонецЦикла;
	
	Если ВРег(Тип) = ВРег("ФиксированнаяСтруктура") Тогда
		ВремСтруктура = Новый ФиксированнаяСтруктура(ВремСтруктура);
	КонецЕсли;
	
	Возврат ВремСтруктура;
	
КонецФункции // СтруктураИзСтруктуры()

// Функция рекурсивно преобразует массив значений в массив с "простыми" типами
//
// Параметры:
//		Значение		- Массив		- Значение для преобразования
//
// Возвращаемое значение:
//   Структура                     - Результат преобразования
//   	*__Тип       - Строка			- Тип значения (Массив, ФиксированныйМассив)
//   	* Элементы   - Массив			- элементы массива
//
Функция МассивВСтруктуру(Значение)
	
	ВремМассив = Новый Структура();
	
	Если ТипЗнч(Значение) = Тип("Массив") Тогда
		ВремМассив.Вставить("__Тип", "Массив");
	ИначеЕсли ТипЗнч(Значение) = Тип("ФиксированныйМассив") Тогда
		ВремМассив.Вставить("__Тип", "ФиксированныйМассив");
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	ВремМассив.Вставить("Элементы", Новый Массив());
	
	Для Каждого ТекЗначение Из Значение Цикл
		ВремМассив.Элементы.Добавить(ЗначениеВСтруктуру(ТекЗначение));
	КонецЦикла;
	
	Возврат ВремМассив;
	
КонецФункции // МассивВСтруктуру()

// Функция рекурсивно преобразует массив с "простыми" типами значений в массив значений 1С
//
// Параметры:
//	СтруктураЗначения           - Массив        - Значение для преобразования
//  ПолучатьБитыеСсылки         - Булево        - Истина - если объект по ссылке не существует,
//                                                будет возвращена битая ссылка;
//                                                Ложь - будет возвращена пустая ссылка
//
// Возвращаемое значение:
//   Массив, ФиксированныйМассив			- Результат преобразования
//
Функция МассивИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки = Ложь)
	
	ВремМассив = Новый Массив();
	
	Элементы = Неопределено;
	
	Тип = Неопределено;
	 
	Если ТипЗнч(СтруктураЗначения) = Тип("Массив") Тогда
		Элементы = СтруктураЗначения;
		Тип = "Массив";
	ИначеЕсли ТипЗнч(СтруктураЗначения) = Тип("Структура") Тогда
		Если НЕ СтруктураЗначения.Свойство("__Тип") Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Если ВРег(СтруктураЗначения.__Тип) = ВРег("Массив")
		 ИЛИ ВРег(СтруктураЗначения.__Тип) = ВРег("ФиксированныйМассив") Тогда
			Элементы = СтруктураЗначения.Элементы;
			Тип = СтруктураЗначения.__Тип;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Для Каждого ТекЭлемент Из Элементы Цикл
		ВремМассив.Добавить(ЗначениеИзСтруктуры(ТекЭлемент, ПолучатьБитыеСсылки));
	КонецЦикла;
	
	Если ВРег(Тип) = ВРег("ФиксированныйМассив") Тогда
		ВремМассив = Новый ФиксированныйМассив(ВремМассив);
	КонецЕсли;
	 
	Возврат ВремМассив;
	
КонецФункции // МассивИзСтруктуры()

// Функция рекурсивно преобразует соответствие значений в массив структур с "простыми" типами
//
// Параметры:
//		Значение		- Соответствие		- Значение для преобразования
//
// Возвращаемое значение:
//   Структура                      - Результат преобразования
//   	*__Тип       - Строка             - Тип значения (Соответствие, ФиксированноеСоответствие)
//   	* Элементы   - Массив(Структура)  - элементы соответствия
//   		* Ключ       - Произвольный      - ключ элемента соответствия
//   		* Значение   - Произвольный      - значение элемента соответствия
//
Функция СоответствиеВСтруктуру(Значение)
	
	ВремСоответствие = Новый Структура();
	
	Если ТипЗнч(Значение) = Тип("Соответствие") Тогда
		ВремСоответствие.Вставить("__Тип", "Соответствие");
	ИначеЕсли ТипЗнч(Значение) = Тип("ФиксированноеСоответствие") Тогда
		ВремСоответствие.Вставить("__Тип", "ФиксированноеСоответствие");
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Если НЕ (ТипЗнч(Значение) = Тип("Соответствие")
	 ИЛИ ТипЗнч(Значение) = Тип("ФиксированноеСоответствие")) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ВремСоответствие.Вставить("Элементы", Новый Массив());
	
	Для Каждого ТекЭлемент Из Значение Цикл
		ВремСоответствие.Элементы.Добавить(Новый Структура("Ключ,
											               |Значение",
											               ЗначениеВСтруктуру(ТекЭлемент.Ключ),
											               ЗначениеВСтруктуру(ТекЭлемент.Значение)));
	КонецЦикла;
	
	Возврат ВремСоответствие;
	
КонецФункции // СоответствиеВСтруктуру()

// Функция рекурсивно преобразует массив структур с "простыми" типами значений в соответствие значений 1С
//
// Параметры:
//	СтруктураЗначения      - Массив(Структура)		- Значение для преобразования
//		Ключ                    - Произвольный			- Ключ элемента соответствия
//		Значение                - Произвольный			- Значение элемента соответствия
//  ПолучатьБитыеСсылки    - Булево                 - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//
// Возвращаемое значение:
//   Соответствие, ФиксированноеСоответствие        - Результат преобразования
//
Функция СоответствиеИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки = Ложь)
	
	ВремСоответствие = Новый Соответствие();

	Элементы = Неопределено;
	
	Тип = Неопределено;
	 
	Если ТипЗнч(СтруктураЗначения) = Тип("Массив") Тогда
		Элементы = СтруктураЗначения;
		Тип = "Соответствие";
	ИначеЕсли ТипЗнч(СтруктураЗначения) = Тип("Структура") Тогда
		Если НЕ СтруктураЗначения.Свойство("__Тип") Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Если ВРег(СтруктураЗначения.__Тип) = ВРег("Соответствие")
		 ИЛИ ВРег(СтруктураЗначения.__Тип) = ВРег("ФиксированноеСоответствие") Тогда
			Элементы = СтруктураЗначения.Элементы;
			Тип = СтруктураЗначения.__Тип;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Для Каждого ТекЭлемент Из Элементы Цикл
		ВремСоответствие.Вставить(ЗначениеИзСтруктуры(ТекЭлемент.Ключ, ПолучатьБитыеСсылки),
		                          ЗначениеИзСтруктуры(ТекЭлемент.Значение, ПолучатьБитыеСсылки));
	КонецЦикла;

	Если ВРег(Тип) = ВРег("ФиксированноеСоответствие") Тогда
		ВремСоответствие = Новый ФиксированноеСоответствие(ВремСоответствие);
	КонецЕсли;
	 
	Возврат ВремСоответствие;
	
КонецФункции // СоответствиеИзСтруктуры()

// Функция рекурсивно преобразует список значений в массив структур с "простыми" типами
//
// Параметры:
//		Значение		- СписокЗначений		- Значение для преобразования
//
// Возвращаемое значение:
//   Структура                          - Результат преобразования
//   	*__Тип          - Строка             - Тип значения (СписокЗначений)
//   	* Элементы      - Массив(Структура)  - элементы списка
//			*Значение        - Произвольный		- Значение элемента списка значений
//			*Представление   - Строка			- Представление элемента списка значений
//			*Пометка         - Булево			- Пометка элемента списка значений
//
Функция СписокЗначенийВСтруктуру(Значение)
	
	Если НЕ ТипЗнч(Значение) = Тип("СписокЗначений") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ВремСписок = Новый Структура();
	ВремСписок.Вставить("__Тип"   , "СписокЗначений");
	ВремСписок.Вставить("Элементы", Новый Массив());
	
	Для Каждого ТекЭлемент Из Значение Цикл
		ВремЭлемент = Новый Структура();
		ВремЭлемент.Вставить("Значение"     , ЗначениеВСтруктуру(ТекЭлемент.Значение));
		ВремЭлемент.Вставить("Представление", ТекЭлемент.Представление);
		ВремЭлемент.Вставить("Пометка"      , ТекЭлемент.Пометка);
		ВремЭлемент.Вставить("Картинка"     , Неопределено);

		ВремСписок.Элементы.Добавить(ВремЭлемент);
	КонецЦикла;
	
	Возврат ВремСписок;
	
КонецФункции // СписокЗначенийВСтруктуру()

// Функция рекурсивно преобразует массив структур с "простыми" типами значений в список значений 1С
//
// Параметры:
//	СтруктураЗначения      - Структура         - Значение для преобразования
//   	*__Тип                 - Строка             - Тип значения (СписокЗначений)
//   	* Элементы             - Массив(Структура)  - элементы списка
//			*Значение              - Произвольный      - Значение элемента списка значений
//			*Представление         - Строка			   - Представление элемента списка значений
//			*Пометка               - Булево			   - Пометка элемента списка значений
//  ПолучатьБитыеСсылки    - Булево            - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//
// Возвращаемое значение:
//   СписокЗначений			- Результат преобразования
//
Функция СписокЗначенийИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки = Ложь)
	
	Если ТипЗнч(СтруктураЗначения) = Тип("Массив") Тогда
		Элементы = СтруктураЗначения;
	ИначеЕсли ТипЗнч(СтруктураЗначения) = Тип("Структура") Тогда
		Если НЕ СтруктураЗначения.Свойство("__Тип") Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Если ВРег(СтруктураЗначения.__Тип) = ВРег("СписокЗначений") Тогда
			Элементы = СтруктураЗначения.Элементы;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Если Элементы.Количество() = 0 Тогда
		Возврат Новый СписокЗначений();
	КонецЕсли;
	
	Если Элементы[0].Свойство("Значение")  = Неопределено Тогда
		Возврат Новый СписокЗначений();
	КонецЕсли;
	
	ВремСписок = Новый СписокЗначений();
	Для Каждого ТекЭлемент Из Элементы Цикл
		ВремСписок.Добавить(ЗначениеИзСтруктуры(ТекЭлемент.Значение, ПолучатьБитыеСсылки),
		                    ТекЭлемент.Представление,
		                    ТекЭлемент.Пометка);
	КонецЦикла;
	
	Возврат ВремСписок;
	
КонецФункции // СписокЗначенийИзСтруктуры()

// Функция рекурсивно преобразует строку таблицы/дерева значений в структуру с "простыми" типами
//
// Параметры:
//		СтрокаЗначений	- СтрокаТаблицыЗначений		- Строка для преобразования
//						  СтрокаДереваЗначений
//		СписокСвойств	- Массив(Строка), Структура	- Список заполняемых полей строки
//
// Возвращаемое значение:
//   Структура			- Результат преобразования
//		<Имя колонки>			- Произвольный		- Значение поля строки таблицы/дерева
//
Функция СтрокаЗначенийВСтруктуру(СтрокаЗначений, СписокСвойств)
	
	ВремСтрока = Новый Структура();
	
	Для Каждого ТекСвойство Из СписокСвойств Цикл
		Если ТипЗнч(ТекСвойство) = Тип("КлючИЗначение") Тогда
			ВремСтрока.Вставить(ТекСвойство.Ключ, ЗначениеВСтруктуру(СтрокаЗначений[ТекСвойство.Ключ]));
		Иначе
			ВремСтрока.Вставить(ТекСвойство, ЗначениеВСтруктуру(СтрокаЗначений[ТекСвойство]));
		КонецЕсли;
	КонецЦикла;
	
	Возврат ВремСтрока;
	
КонецФункции // СтрокаЗначенийВСтруктуру()

// Процедура рекурсивно заполняет строку таблицы/дерева значений данными из структуры с "простыми" типами значений
//
// Параметры:
//	СтрокаЗначений      - СтрокаТаблицыЗначений     - Строка для преобразования
//                        СтрокаДереваЗначений
//	СтруктураЗначений   - Структура                 - Значение для преобразования
//		<Имя колонки>       - Произвольный              - Значение поля строки таблицы/дерева
//  ПолучатьБитыеСсылки - Булево                    - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//	СписокСвойств       - Массив(Строка), Структура - Список заполняемых полей строки
//
Процедура СтрокаЗначенийИзСтруктуры(СтрокаЗначений
	                              , СтруктураЗначений
	                              , ПолучатьБитыеСсылки = Ложь
	                              , СписокСвойств = Неопределено)
	
	Если СписокСвойств = Неопределено Тогда
		СписокСвойств = Новый Массив();
		Для Каждого ТекЭлемент Из СтруктураЗначений Цикл
			СписокСвойств.Добавить(ТекЭлемент.Ключ);
		КонецЦикла;
	КонецЕсли;
	
	Для Каждого ТекСвойство Из СписокСвойств Цикл
		Если ТипЗнч(ТекСвойство) = Тип("КлючИЗначение") Тогда
			ИмяКолонки = ТекСвойство.Ключ;
		ИначеЕсли ТипЗнч(ТекСвойство) = Тип("КолонкаТаблицыЗначений")
		      ИЛИ ТипЗнч(ТекСвойство) = Тип("КолонкаДереваЗначений") Тогда
			ИмяКолонки = ТекСвойство.Имя;
		Иначе
			ИмяКолонки = ТекСвойство;
		КонецЕсли;
		СтрокаЗначений[ИмяКолонки] = ЗначениеИзСтруктуры(СтруктураЗначений[ИмяКолонки], ПолучатьБитыеСсылки);
	КонецЦикла;
	
КонецПроцедуры // СтрокаЗначенийИзСтруктуры()

// Функция рекурсивно преобразует таблицу значений в массив структур с "простыми" типами
//
// Параметры:
//		Значение       - ТаблицаЗначений        - Значение для преобразования
//
// Возвращаемое значение:
//   Структура                          - результат преобразования
//   	*__Тип          - Строка             - тип значения (ТаблицаЗначений)
//   	*Колонки        - Структура          - описания колонок таблицы
//			*<Имя колонки>   - Структура        - описание колонки таблицы
//			    *Заголовок   - Строка               - заголовок колонки
//			    *ТипЗначения - Структура            - описание типа колонки
//			    *Ширина      - Строка               - ширина колонки по умолчанию
//   	*Строки         - Массив(Структура)  - строки таблицы значений
//			*<Имя колонки>   - Произвольный		- значение поля таблицы значений
//
Функция ТаблицаЗначенийВСтруктуру(Значение, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено)
	
	Если НЕ ТипЗнч(Значение) = Тип("ТаблицаЗначений") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ВремТаб = Новый Структура();
	ВремТаб.Вставить("__Тип"  , "ТаблицаЗначений");
	ВремТаб.Вставить("Колонки", Новый Структура());
	ВремТаб.Вставить("Строки" , Новый Массив());
	
	Для Каждого ТекКолонка Из Значение.Колонки Цикл
		Если НЕ ИспользоватьСвойство(ТекКолонка.Имя, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		
		ОписаниеКолонки = Новый Структура();
		ОписаниеКолонки.Вставить("Заголовок"  , ТекКолонка.Заголовок);
		ОписаниеКолонки.Вставить("ТипЗначения", ЗначениеВСтруктуру(ТекКолонка.ТипЗначения));
		ОписаниеКолонки.Вставить("Ширина"     , ТекКолонка.Ширина);
		
		ВремТаб.Колонки.Вставить(ТекКолонка.Имя, ОписаниеКолонки);
	КонецЦикла;
	
	Для Каждого ТекСтрока Из Значение Цикл
		ВремТаб.Строки.Добавить(СтрокаЗначенийВСтруктуру(ТекСтрока, ВремТаб.Колонки));
	КонецЦикла;
	
	Возврат ВремТаб;
	
КонецФункции // ТаблицаЗначенийВСтруктуру()

// Функция рекурсивно преобразует массив структур с "простыми" типами значений в таблицу значений 1С
//
// Параметры:
//	СтруктураЗначения   - Структура                - Значение для преобразования
//   	*__Тип          - Строка                      - тип значения (ТаблицаЗначений)
//   	*Колонки        - Структура                   - описания колонок таблицы
//			*<Имя колонки>   - Структура                 - описание колонки таблицы
//			    *Заголовок   - Строка                       - заголовок колонки
//			    *ТипЗначения - Структура                    - описание типа колонки
//			    *Ширина      - Строка                       - ширина колонки по умолчанию
//   	*Строки         - Массив(Структура)           - строки таблицы значений
//			*<Имя колонки>   - Произвольный		         - значение поля таблицы значений
//  ПолучатьБитыеСсылки     - Булево             - Истина - если объект по ссылке не существует,
//                                                 будет возвращена битая ссылка;
//                                                 Ложь - будет возвращена пустая ссылка
//  СписокСвойств       - Строка, Массив(Строка) - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка) - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   ТаблицаЗначений        - Результат преобразования
//
Функция ТаблицаЗначенийИзСтруктуры(СтруктураЗначения
	                             , ПолучатьБитыеСсылки = Ложь
	                             , СписокСвойств = Неопределено
	                             , ИсключаяСвойства = Неопределено)
	
	Если ТипЗнч(СтруктураЗначения) = Тип("Массив") Тогда
		Если СтруктураЗначения.Количество() = 0 Тогда
			Возврат Новый ТаблицаЗначений();
		КонецЕсли;
		Колонки = СтруктураЗначения[0];
		Строки = СтруктураЗначения;
	ИначеЕсли ТипЗнч(СтруктураЗначения) = Тип("Структура") Тогда
		Если НЕ СтруктураЗначения.Свойство("__Тип") Тогда
			Возврат Неопределено;
		КонецЕсли;
		
		Если ВРег(СтруктураЗначения.__Тип) = ВРег("ТаблицаЗначений") Тогда
			Колонки = СтруктураЗначения.Колонки;
			Строки = СтруктураЗначения.Строки;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	ВремТаб = Новый ТаблицаЗначений();
	
	Для Каждого ТекЭлемент Из Колонки Цикл
		Если НЕ ИспользоватьСвойство(ТекЭлемент.Ключ, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		Если ТипЗнч(ТекЭлемент.Значение) = Тип("Структура") Тогда
			ВремТаб.Колонки.Добавить(ТекЭлемент.Ключ,
			                         ЗначениеИзСтруктуры(ТекЭлемент.Значение.ТипЗначения),
			                         ТекЭлемент.Значение.Заголовок,
			                         ТекЭлемент.Значение.Ширина);
		Иначе
			ВремТаб.Колонки.Добавить(ТекЭлемент.Ключ);
		КонецЕсли;
	КонецЦикла;
	
	Для Каждого ТекСтрока Из Строки Цикл
		НоваяСтрока = ВремТаб.Добавить();
		СтрокаЗначенийИзСтруктуры(НоваяСтрока, ТекСтрока, ПолучатьБитыеСсылки, ВремТаб.Колонки);
	КонецЦикла;
	
	Возврат ВремТаб;
	
КонецФункции // ТаблицаЗначенийИзСтруктуры()

// Функция рекурсивно преобразует строки дерева значений в массив структур с "простыми" типами
//
// Параметры:
//		СтрокиДерева	- КоллекцияСтрокДереваЗначений		- Строки для преобразования
//		СписокСвойств	- Массив(Строка)					- Список заполняемых полей строки
//
// Возвращаемое значение:
//   Массив(Структура)		- Результат преобразования
//		<Имя колонки>			- Произвольный		- Значение поля строки дерева
//
Функция СтрокиДереваВСтруктуру(СтрокиДерева, СписокСвойств)
	
	ВремСтроки = Новый Массив();
	
	Для Каждого ТекСтрока Из СтрокиДерева Цикл
		ВремСтрока = СтрокаЗначенийВСтруктуру(ТекСтрока, СписокСвойств);
		ВремСтрока.Вставить("Строки", СтрокиДереваВСтруктуру(ТекСтрока.Строки, СписокСвойств));
		ВремСтроки.Добавить(ВремСТрока);
	КонецЦикла;
	
	Возврат ВремСтроки;
	
КонецФункции // СтрокиДереваВСтруктуру()

// Процедура рекурсивно заполняет строки дерева значений данными из массива структур с "простыми" типами значений
//
// Параметры:
//	СтрокиДерева        - КоллекцияСтрокДереваЗначений    - Строка для преобразования
//	СтруктураСтрок      - Массив(Структура)               - Значение для преобразования
//		<Имя колонки>       - Произвольный                    - Значение поля строки дерева
//  ПолучатьБитыеСсылки     - Булево                      - Истина - если объект по ссылке не существует,
//                                                          будет возвращена битая ссылка;
//                                                          Ложь - будет возвращена пустая ссылка
//	СписокСвойств        - Массив(Строка)                 - Список заполняемых полей строк
//
Процедура СтрокиДереваИзСтруктуры(СтрокиДерева
	                            , СтруктураСтрок
	                            , ПолучатьБитыеСсылки = Ложь
	                            , СписокСвойств = Неопределено)
	
	Для Каждого ТекСтрока Из СтруктураСтрок Цикл
		НоваяСтрока = СтрокиДерева.Добавить();
		СтрокаЗначенийИзСтруктуры(НоваяСтрока, ТекСтрока, ПолучатьБитыеСсылки, СписокСвойств);
		СтрокиДереваИзСтруктуры(НоваяСтрока.Строки, ТекСтрока.Строки, ПолучатьБитыеСсылки, СписокСвойств);
	КонецЦикла;
	
КонецПроцедуры // СтрокиДереваИзСтруктуры()

// Функция рекурсивно преобразует дерево значений в структуру с "простыми" типами
//
// Параметры:
//		Значение		- ДеревоЗначений		- Значение для преобразования
//
// Возвращаемое значение:
//   Структура                          - результат преобразования
//   	*__Тип          - Строка             - тип значения (ДеревоЗначений)
//   	*Колонки        - Структура          - описания колонок дерева
//			*<Имя колонки>   - Структура        - описание колонки дерева
//			    *Заголовок   - Строка           - заголовок колонки
//			    *ТипЗначения - Структура        - описание типа колонки
//			    *Ширина      - Строка           - ширина колонки по умолчанию
//   	*Строки         - Массив(Структура)  - строки дерева значений
//			*<Имя колонки>   - Произвольный		- значение поля дерева значений
//
Функция ДеревоЗначенийВСтруктуру(Значение, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено)
	
	Если НЕ ТипЗнч(Значение) = Тип("ДеревоЗначений") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	ВремДерево = Новый Структура();
	ВремДерево.Вставить("__Тип"  , "ДеревоЗначений");
	ВремДерево.Вставить("Колонки", Новый Структура());
	ВремДерево.Вставить("Строки" , Новый Массив());
	
	Для Каждого ТекКолонка Из Значение.Колонки Цикл
		Если НЕ ИспользоватьСвойство(ТекКолонка.Имя, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		Если ВРег(ТекКолонка.Имя) = ВРег("Родитель") Тогда
			ПоказатьСообщение("Имя колонки ""Родитель"" совпадает с именем свойства строки дерева значений,
                              |колонка не может быть сохранена!");
            Продолжить;
        КонецЕсли;	
		
		ОписаниеКолонки = Новый Структура();
		ОписаниеКолонки.Вставить("Заголовок"  , ТекКолонка.Заголовок);
		ОписаниеКолонки.Вставить("ТипЗначения", ЗначениеВСтруктуру(ТекКолонка.ТипЗначения));
		ОписаниеКолонки.Вставить("Ширина"     , ТекКолонка.Ширина);
		
		ВремДерево.Колонки.Вставить(ТекКолонка.Имя, ОписаниеКолонки);
	КонецЦикла;
	
	МассивКолонок = Новый Массив();
	Для Каждого ТекКолонка Из Значение.Колонки Цикл
		Если НЕ ИспользоватьСвойство(ТекКолонка.Имя, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		МассивКолонок.Добавить(ТекКолонка.Имя);
	КонецЦикла;
	
	ВремДерево.Строки = СтрокиДереваВСтруктуру(Значение.Строки, ВремДерево.Колонки);
	
	Возврат ВремДерево;
	
КонецФункции // ДеревоЗначенийВСтруктуру()

// Функция рекурсивно преобразует структуру с "простыми" типами значений в дерево значений 1С
//
// Параметры:
//	СтруктураЗначения   - Структура                - Значение для преобразования
//   	*__Тип          - Строка                      - тип значения (ДеревоЗначений)
//   	*Колонки        - Структура                   - описания колонок дерева
//			*<Имя колонки>   - Структура                 - описание колонки дерева
//			    *Заголовок   - Строка                       - заголовок колонки
//			    *ТипЗначения - Структура                    - описание типа колонки
//			    *Ширина      - Строка                       - ширина колонки по умолчанию
//   	*Строки         - Массив(Структура)           - строки дерева значений
//			*<Имя колонки>   - Произвольный		         - значение поля дерева значений
//  ПолучатьБитыеСсылки   - Булево                 - Истина - если объект по ссылке не существует,
//                                                   будет возвращена битая ссылка;
//                                                   Ложь - будет возвращена пустая ссылка
//  СписокСвойств         - Строка, Массив(Строка) - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства      - Строка, Массив(Строка) - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   ДеревоЗначений			- Результат преобразования
//
Функция ДеревоЗначенийИзСтруктуры(СтруктураЗначения
	                            , ПолучатьБитыеСсылки = Ложь
	                            , СписокСвойств = Неопределено
	                            , ИсключаяСвойства = Неопределено)
	
	Если ТипЗнч(СтруктураЗначения) = Тип("Структура") Тогда
		Если НЕ СтруктураЗначения.Свойство("__Тип") Тогда
			Колонки = СтруктураЗначения.Строки[0];
			Строки = СтруктураЗначения.Строки;
		ИначеЕсли ВРег(СтруктураЗначения.__Тип) = ВРег("ДеревоЗначений") Тогда
			Колонки = СтруктураЗначения.Колонки;
			Строки = СтруктураЗначения.Строки;
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Если НЕ ТипЗнч(Строки) = Тип("Массив") Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если НЕ СтруктураЗначения.Свойство("Колонки") И Строки.Количество() = 0 Тогда
		Возврат Новый ДеревоЗначений();
	КонецЕсли;

	ВремДерево = Новый ДеревоЗначений();
	
	Для Каждого ТекЭлемент Из Колонки Цикл
		Если НЕ ИспользоватьСвойство(ТекЭлемент.Ключ, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		Если ВРег(ТекЭлемент.Ключ) = ВРег("Родитель") Тогда
			ПоказатьСообщение("Имя колонки ""Родитель"" совпадает с именем свойства строки дерева значений,
                              |колонка не может быть сохранена!");
            Продолжить;
        КонецЕсли;	
		Если ТипЗнч(ТекЭлемент.Значение) = Тип("Структура") Тогда
			ВремДерево.Колонки.Добавить(ТекЭлемент.Ключ,
			                         ЗначениеИзСтруктуры(ТекЭлемент.Значение.ТипЗначения),
			                         ТекЭлемент.Значение.Заголовок,
			                         ТекЭлемент.Значение.Ширина);
		Иначе
			ВремДерево.Колонки.Добавить(ТекЭлемент.Ключ);
		КонецЕсли;
	КонецЦикла;
	
	СтрокиДереваИзСтруктуры(ВремДерево.Строки, Строки, ПолучатьБитыеСсылки, ВремДерево.Колонки);
	
	Возврат ВремДерево;
	
КонецФункции // ДеревоЗначенийИзСтруктуры()

#КонецОбласти // ПреобразованияКоллекций

#Область ПреобразованияОбъектовОбщие

// Преобразует переданное значение в структуру, значения атомарных типов, возвращаются как есть
//
// Параметры:
//  Значение			- Произвольный				- Преобразуемое значение
//
// Возвращаемое значение:
//   Структура, Массив, Число, Строка, Дата, Булево			- результат преобразования
//
Функция ЗначениеВСтруктуру(Значение) Экспорт
	
	Если ТипЗнч(Значение) = Тип("Строка")
	 ИЛИ ТипЗнч(Значение) = Тип("Число")
	 ИЛИ ТипЗнч(Значение) = Тип("Булево")
	 ИЛИ ТипЗнч(Значение) = Тип("Дата")
	 ИЛИ ТипЗнч(Значение) = Тип("ХранилищеЗначения")
	 ИЛИ ТипЗнч(Значение) = Тип("УникальныйИдентификатор")
	 ИЛИ ТипЗнч(Значение) = Тип("NULL")
	 ИЛИ ТипЗнч(Значение) = Тип("Неопределено") Тогда
		Возврат Значение;
	КонецЕсли;

	Если ТипЗнч(Значение) = Тип("Массив")
		  ИЛИ ТипЗнч(Значение) = Тип("ФиксированныйМассив") Тогда
		Возврат МассивВСтруктуру(Значение);
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("Структура")
		  ИЛИ ТипЗнч(Значение) = Тип("ФиксированнаяСтруктура") Тогда
		Возврат СтруктураВСтруктуру(Значение);
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("Соответствие")
		  ИЛИ ТипЗнч(Значение) = Тип("ФиксированноеСоответствие") Тогда
		Возврат СоответствиеВСтруктуру(Значение);
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("СписокЗначений") Тогда
		Возврат СписокЗначенийВСтруктуру(Значение);
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("ТаблицаЗначений") Тогда
		Возврат ТаблицаЗначенийВСтруктуру(Значение);
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("ДеревоЗначений") Тогда
		Возврат ДеревоЗначенийВСтруктуру(Значение);
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип("ОписаниеТипов") Тогда
		Возврат ОписаниеТиповВСтруктуру(Значение);
	КонецЕсли;
	
	Если ЭтоСсылка(Значение) Тогда
		Возврат СсылкаВСтруктуру(Значение);
	КонецЕсли;

	Если ЭтоОбъект(Значение) Тогда
		Возврат ОбъектВСтруктуру(Значение);
	КонецЕсли;

	Если ЭтоНаборЗаписейРегистра(Значение) Тогда
		Возврат НаборЗаписейРегистраВСтруктуру(Значение);
	КонецЕсли;

	Возврат Значение;
		
КонецФункции // ЗначениеВСтруктуру()

// Получает значение из переданного описания, значения атомарных типов, возвращаются как есть
//
// Параметры:
//  СтруктураЗначения          - Структура, Число, Строка,      - Описание значение
//                               Дата, Булево
//  ПолучатьБитыеСсылки        - Булево                         - Истина - если объект по ссылке не существует,
//                                                                будет возвращена битая ссылка;
//                                                                Ложь - будет возвращена пустая ссылка
//
// Возвращаемое значение:
//   Произвольный			- результат преобразования
// TODO: продумать управление получением битых ссылок
Функция ЗначениеИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки = Ложь) Экспорт
	
	Если ТипЗнч(СтруктураЗначения) = Тип("Строка")
	 ИЛИ ТипЗнч(СтруктураЗначения) = Тип("Число")
	 ИЛИ ТипЗнч(СтруктураЗначения) = Тип("Булево")
	 ИЛИ ТипЗнч(СтруктураЗначения) = Тип("Дата")
	 ИЛИ ТипЗнч(СтруктураЗначения) = Тип("ХранилищеЗначения")
	 ИЛИ ТипЗнч(СтруктураЗначения) = Тип("УникальныйИдентификатор")
	 ИЛИ ТипЗнч(СтруктураЗначения) = Тип("Неопределено")
	 ИЛИ ТипЗнч(СтруктураЗначения) = Тип("NULL") Тогда
		Возврат СтруктураЗначения;
	КонецЕсли;
	
	ВремТип = СтруктураТипЗнч(СтруктураЗначения);
	
	Если ВремТип = Тип("Массив") Тогда
		Возврат МассивИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки);
	КонецЕсли;
	
	Если ВремТип = Тип("Структура") Тогда
		Возврат СтруктураИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки);
	КонецЕсли;
	
	Если ВремТип = Тип("Соответствие") Тогда
		Возврат СоответствиеИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки);
	КонецЕсли;
	
	Если ВремТип = Тип("СписокЗначений") Тогда
		Возврат СписокЗначенийИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки);
	КонецЕсли;
	
	Если ВремТип = Тип("ТаблицаЗначений") Тогда
		Возврат ТаблицаЗначенийИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки);
	КонецЕсли;
	
	Если ВремТип = Тип("ДеревоЗначений") Тогда
		Возврат ДеревоЗначенийИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки);
	КонецЕсли;
	
	Если ВремТип = Тип("ОписаниеТипов") Тогда
		Возврат ОписаниеТиповИзСтруктуры(СтруктураЗначения);
	КонецЕсли;
	
	Если ЭтоСсылка(СтруктураЗначения) Тогда
		Возврат СсылкаИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки);
	КонецЕсли;
	
	Если ЭтоОбъект(СтруктураЗначения) Тогда
		Возврат СоздатьОбъектИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки);
	КонецЕсли;
	
	Если ЭтоНаборЗаписейРегистра(СтруктураЗначения) Тогда
		Возврат СоздатьНаборЗаписейРегистраИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки);
	КонецЕсли;
	
	Возврат СтруктураЗначения;
	
КонецФункции // ЗначениеИзСтруктуры()

// Преобразует значение ссылочного типа в структуру
//
// Параметры:
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Ссылка			- Структура		- Описание ссылки на объект
//			Тип 						- Строка		- Текстовое описание типа объекта
//			Ид                          - Строка		- Уникальный идентификатор ссылки
//			ИдПолный					- Строка		- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево		- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка		- Имя предопределенного значения
//			Представление				- Строка		- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный	- Дополнительные поля добавленные при выгрузке
//		__ТЧ			- Массив		- Массив табличных частей объекта
//		<имя поля>						- Произвольный	- Значения реквизитов объекта
//
Функция ОбъектВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипЗнч(Объект));
	
	Если ОписаниеВида = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СтруктураОбъекта = Неопределено;
	
	Если ВРег(ОписаниеВида.Имя) = ВРег("Справочник") Тогда
		СтруктураОбъекта = СправочникВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("Документ") Тогда
		СтруктураОбъекта = ДокументВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("ПланВидовХарактеристик") Тогда
		СтруктураОбъекта = ПланВидовХарактеристикВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("ПланСчетов") Тогда
		СтруктураОбъекта = ПланСчетовВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("ПланВидовРасчета") Тогда
		СтруктураОбъекта = ПланВидовРасчетаВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("ПланОбмена") Тогда
		СтруктураОбъекта = ПланОбменаВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("БизнесПроцесс") Тогда
		СтруктураОбъекта = БизнесПроцессВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("Задача") Тогда
		СтруктураОбъекта = ЗадачаВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства);
	Иначе
		ПоказатьСообщение(СтрШаблонВнутр("Неизвестный тип объекта: %1", Объект));
	КонецЕсли;
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ОбъектВСтруктуру()

// Заполняет объект (ссылочного типа) из структуры
//
// Параметры:
//  Объект                 - Объект                 - Заполняемый объект
//  СтруктураОбъекта       - Структура                  - Данные для заполнения объекта
//		Ссылка                   - Структура                - Описание ссылки на объект
//			Тип                         - Строка            - Текстовое описание типа объекта
//			Ид                          - Строка            - Уникальный идентификатор ссылки
//			ИдПолный                    - Строка            - Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный            - Булево            - Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных   - Строка            - Имя предопределенного значения
//			Представление               - Строка            - Стандатрное строковое представление объекта
//			<имя поля>                  - Произвольный      - Дополнительные поля добавленные при выгрузке
//		__ТЧ                    - Массив                - Массив табличных частей объекта
//		<имя поля>              - Произвольный          - Значения реквизитов объекта
//  ПолучатьБитыеСсылки    - Булево                     - Истина - если объект по ссылке не существует,
//                                                        будет возвращена битая ссылка;
//                                                        Ложь - будет возвращена пустая ссылка
//  СписокСвойств          - Строка, Массив(Строка)	    - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства       - Строка, Массив(Строка)	    - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ЗаполнитьОбъектИзСтруктуры(Объект
	                               , СтруктураОбъекта
	                               , ПолучатьБитыеСсылки = Ложь
	                               , СписокСвойств = Неопределено
	                               , ИсключаяСвойства = Неопределено) Экспорт
	
	ТипОбъекта = "NULL";
	Если СтруктураОбъекта.Свойство("Ссылка") И СтруктураОбъекта.Ссылка.Свойство("Тип") Тогда 
		ТипОбъекта = СтруктураОбъекта.Ссылка.Тип;
	ИначеЕсли СтруктураОбъекта.Свойство("Ссылка") И СтруктураОбъекта.Ссылка.Свойство("__Тип") Тогда 
		ТипОбъекта = СтруктураОбъекта.Ссылка.__Тип;
	Иначе
		ТекстОшибки = "Структура не содержит указания типа значения или не является представлением ссылочного объекта. Поля %1 объекта:";
		
		Если СтруктураОбъекта.Свойство("Ссылка") Тогда
			ВремСтруктура = СтруктураОбъекта.Ссылка;
			ТекстОшибки = СтрШаблонВнутр(ТекстОшибки, "ссылки");
		Иначе
			ВремСтруктура = СтруктураОбъекта;
			ТекстОшибки = СтрШаблонВнутр(ТекстОшибки, "структуры");
		КонецЕсли;
		ДополнитьТекстПолямиСтруктуры(ТекстОшибки, ВремСтруктура);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Попытка
		ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипОбъекта);
	Исключение
		ВызватьИсключение СтрШаблонВнутр("Ошибка получения описания вида объекта ""%1"": %2%3",
		                            ТипОбъекта,
		                            Символы.ПС,
		                            ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Если ВРег(ОписаниеВида.Имя) = ВРег("Справочник") Тогда
		СправочникИзСтруктуры(Объект, СтруктураОбъекта, ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("Документ") Тогда
		ДокументИзСтруктуры(Объект, СтруктураОбъекта, ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("ПланВидовХарактеристик") Тогда
		ПланВидовХарактеристикИзСтруктуры(Объект,
		                                  СтруктураОбъекта,
		                                  ПолучатьБитыеСсылки,
		                                  СписокСвойств,
		                                  ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("ПланСчетов") Тогда
		ПланСчетовИзСтруктуры(Объект, СтруктураОбъекта, ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("ПланВидовРасчета") Тогда
		ПланВидовРасчетаИзСтруктуры(Объект, СтруктураОбъекта, ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("ПланОбмена") Тогда
		ПланОбменаИзСтруктуры(Объект, СтруктураОбъекта, ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("БизнесПроцесс") Тогда
		БизнесПроцессИзСтруктуры(Объект, СтруктураОбъекта, ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("Задача") Тогда
		ЗадачаИзСтруктуры(Объект, СтруктураОбъекта, ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
	Иначе
		ПоказатьСообщение(СтрШаблонВнутр("Неизвестный тип объекта: %1", ТипОбъекта));
	КонецЕсли;
	
КонецПроцедуры // ЗаполнитьОбъектИзСтруктуры()

// Создает объект (ссылочного типа) из структуры
//
// Параметры:
//  СтруктураОбъекта       - Структура                  - Данные для заполнения объекта
//		Ссылка                   - Структура                - Описание ссылки на объект
//			Тип                         - Строка            - Текстовое описание типа объекта
//			Ид                          - Строка            - Уникальный идентификатор ссылки
//			ИдПолный                    - Строка            - Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный            - Булево            - Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных   - Строка            - Имя предопределенного значения
//			Представление               - Строка            - Стандатрное строковое представление объекта
//			<имя поля>                  - Произвольный      - Дополнительные поля добавленные при выгрузке
//		__ТЧ                    - Массив                - Массив табличных частей объекта
//		<имя поля>              - Произвольный          - Значения реквизитов объекта
//  ПолучатьБитыеСсылки    - Булево                     - Истина - если объект по ссылке не существует,
//                                                        будет возвращена битая ссылка;
//                                                        Ложь - будет возвращена пустая ссылка
//  СписокСвойств          - Строка, Массив(Строка)	    - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства       - Строка, Массив(Строка)	    - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Объект             - созданный объект
//
Функция СоздатьОбъектИзСтруктуры(СтруктураОбъекта
	                           , УстановитьСсылку = Ложь
	                           , ПолучатьБитыеСсылки = Ложь
	                           , СписокСвойств = Неопределено
	                           , ИсключаяСвойства = Неопределено) Экспорт
	
	ТипОбъекта = "NULL";
	Если СтруктураОбъекта.Свойство("Ссылка") И СтруктураОбъекта.Ссылка.Свойство("Тип") Тогда 
		ТипОбъекта = СтруктураОбъекта.Ссылка.Тип;
	ИначеЕсли СтруктураОбъекта.Свойство("Ссылка") И СтруктураОбъекта.Ссылка.Свойство("__Тип") Тогда 
		ТипОбъекта = СтруктураОбъекта.Ссылка.__Тип;
	Иначе
		ТекстОшибки = "Структура не содержит указания типа значения или не является представлением ссылочного объекта. Поля %1 объекта:";
		
		Если СтруктураОбъекта.Свойство("Ссылка") Тогда
			ВремСтруктура = СтруктураОбъекта.Ссылка;
			ТекстОшибки = СтрШаблонВнутр(ТекстОшибки, "ссылки");
		Иначе
			ВремСтруктура = СтруктураОбъекта;
			ТекстОшибки = СтрШаблонВнутр(ТекстОшибки, "структуры");
		КонецЕсли;
		ДополнитьТекстПолямиСтруктуры(ТекстОшибки, ВремСтруктура);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Попытка
		ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипОбъекта);
	Исключение
		ВызватьИсключение СтрШаблонВнутр("Ошибка получения описания вида объекта ""%1"": %2%3",
		                            ТипОбъекта,
		                            Символы.ПС,
		                            ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	МетаОбъект = Метаданные.НайтиПоПолномуИмени(СтрШаблонВнутр("%1.%2", ОписаниеВида.Имя, ОписаниеВида.ИмяТипа));
	Менеджер = ОписаниеВида.Коллекция[МетаОбъект.Имя];
	
	Конструктор = ОписаниеВида.Конструктор;
	
	ИерархияГруппИЭлементов = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов;
	
	Если ВРег(ОписаниеВида.Имя) = ВРег("Справочник") Тогда
		Если ОписаниеВида.МетаКоллекция[МетаОбъект.Имя].Иерархический
		   И ОписаниеВида.МетаКоллекция[МетаОбъект.Имя].ВидИерархии = ИерархияГруппИЭлементов Тогда
			Если СтруктураОбъекта.ЭтоГруппа Тогда 
				Конструктор = ОписаниеВида.КонструкторАльт;
			КонецЕсли;
		КонецЕсли;
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("ПланВидовХарактеристик") Тогда
		Если ОписаниеВида.МетаКоллекция[МетаОбъект.Имя].Иерархический Тогда
			Если СтруктураОбъекта.ЭтоГруппа Тогда 
				Конструктор = ОписаниеВида.КонструкторАльт;
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Объект = Неопределено;
	
	Если ЗначениеЗаполнено(Конструктор) Тогда
		
		Объект = Вычислить("Менеджер." + Конструктор + "()");
		
		Если УстановитьСсылку Тогда
			НоваяСсылка = Менеджер.ПолучитьСсылку(Новый УникальныйИдентификатор(СтруктураОбъекта.Ссылка.Ид)); 
			Объект.УстановитьСсылкуНового(НоваяСсылка);
		КонецЕсли;
		
		ЗаполнитьОбъектИзСтруктуры(Объект, СтруктураОбъекта, ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
		
	КонецЕсли;
	
	Возврат Объект;
	
КонецФункции // СоздатьОбъектИзСтруктуры()

// Преобразует переданную ссылку в структуру, значения атомарных типов, возвращаются как есть
//
// Параметры:
//  Значение			- ЛюбаяСсылка				- Преобразуемое ссылка
//
// Возвращаемое значение:
//   Структура			- результат преобразования
//
Функция СсылкаВСтруктуру(Значение) Экспорт
	
	МетаданныеЗначения = Метаданные.НайтиПоТипу(ТипЗнч(Значение));
	
	Если МетаданныеЗначения = Неопределено Тогда
		Возврат Значение;
	КонецЕсли;
	
	Если НЕ ТипЗнч(КэшСсылок) = Тип("Соответствие") Тогда
		КэшСсылок = Новый Соответствие();
	КонецЕсли;
	  
	ЗначениеИзКэша = КэшСсылок.Получить(Значение); 
	Если НЕ ЗначениеИзКэша = Неопределено Тогда
		Возврат ЗначениеизКэша;
	КонецЕсли;
					
	Если СтрокаНачиснаетсяСВнутр(МетаданныеЗначения.ПолноеИмя(), "Перечисление.") Тогда
		ИмяПредопределенныхДанных = "";
		Если ЗначениеЗаполнено(Значение) Тогда
			Индекс = Перечисления[МетаданныеЗначения.Имя].Индекс(Значение);
			ИмяПредопределенныхДанных = МетаданныеЗначения.ЗначенияПеречисления.Получить(Индекс).Имя;
		КонецЕсли;
		
		Предопределенный = Истина;
		
		Ид = ИмяПредопределенныхДанных;
		
	Иначе
		Предопределенный = Ложь;
		Если Метаданные.Справочники.Содержит(МетаданныеЗначения)
		 ИЛИ Метаданные.ПланыВидовХарактеристик.Содержит(МетаданныеЗначения)
		 ИЛИ Метаданные.ПланыСчетов.Содержит(МетаданныеЗначения)
		 ИЛИ Метаданные.ПланыВидовРасчета.Содержит(МетаданныеЗначения) Тогда
			Предопределенный = Значение.Предопределенный;
		ИначеЕсли Метаданные.ПланыОбмена.Содержит(МетаданныеЗначения) Тогда
			Предопределенный = Значение.ЭтотУзел;
		Иначе
			Предопределенный = Ложь;
		КонецЕсли;
	
		Ид = СокрЛП(Значение.УникальныйИдентификатор());
	
	КонецЕсли;
	
	ОписаниеЗначения = Новый Структура();
	ОписаниеЗначения.Вставить("__Тип"                    , СтрЗаменить(МетаданныеЗначения.ПолноеИмя(), ".", "Ссылка."));
	Если НЕ Значение.Пустая() Тогда
		ОписаниеЗначения.Вставить("Ид"                       , Ид);
		ОписаниеЗначения.Вставить("ИдПолный"                 , ЗначениеВСтрокуВнутр(Значение));
		ОписаниеЗначения.Вставить("Предопределенный"         , Предопределенный);
		ОписаниеЗначения.Вставить("ИмяПредопределенныхДанных", ПолучитьИмяПредопределенныхДанных(Значение));
		ОписаниеЗначения.Вставить("Представление"            , СокрЛП(Значение));
	КонецЕсли;
	
	ПравилоВыгрузки = ПолучитьПравилоВыгрузкиТипа(МетаданныеЗначения.ПолноеИмя());
	
	Если ПравилоВыгрузки = Неопределено Тогда
		Возврат ОписаниеЗначения;
	КонецЕсли;
			
	КодДополненияЗначения = "";
	Если НЕ ПравилоВыгрузки.Модуль = Неопределено Тогда
		КодДополненияЗначения = КодДополненияЗначения + "ПравилоВыгрузки.Модуль.";
	КонецЕсли;
	
	КодДополненияЗначения = КодДополненияЗначения
						  + СокрЛП(ПравилоВыгрузки.ФункцияДополнения)
						  + "(ОписаниеЗначения, Значение);";
	
	Попытка
		Выполнить(КодДополненияЗначения);
	Исключение
		ТекстОшибки = "Ошибка дополнения значения: "
					+ СокрЛП(Значение) + Символы.ПС
					+ ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	КэшСсылок.Вставить(Значение, ОписаниеЗначения);
	
	Возврат ОписаниеЗначения;
	
КонецФункции // СсылкаВСтруктуру()

// Получает ссылку по переданной структуре
//
// Параметры:
//  СтруктураЗначения			- Структура			- Структура описания ссылки
//  ПолучатьБитыеСсылки         - Булево            - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//
// Возвращаемое значение:
//   ЛюбаяСсылка			- полученная ссылка
// TODO: продумать управление получением битых ссылок
Функция СсылкаИзСтруктуры(СтруктураЗначения, ПолучатьБитыеСсылки = Ложь) Экспорт
	
	Если Не ТипЗнч(СтруктураЗначения) = Тип("Структура") Тогда
		Возврат СтруктураЗначения;
	КонецЕсли;
	
	Если СтруктураЗначения.Свойство("__Тип") Тогда
		ПравилоЗагрузки = ПолучитьПравилоЗагрузкиТипа(СтруктураЗначения.__Тип);
	ИначеЕсли СтруктураЗначения.Свойство("Тип") Тогда
		ПравилоЗагрузки = ПолучитьПравилоЗагрузкиТипа(СтруктураЗначения.Тип);
	Иначе
		ТекстОшибки = "Структура не содержит поля с типом значения или не является представлением ссылки. Поля: ";
		ДополнитьТекстПолямиСтруктуры(ТекстОшибки, СтруктураЗначения);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
		
	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ПравилоЗагрузки.ТипЗначения);

	МетаОбъект = Метаданные.НайтиПоПолномуИмени(СтрШаблонВнутр("%1.%2", ОписаниеВида.Имя, ОписаниеВида.ИмяТипа));
	
	Если МетаОбъект = Неопределено Тогда
		ТекстОшибки = "Не найден тип " + ПравилоЗагрузки.ТипЗначения 
		            + " для значения: """
		            + СтруктураЗначения.Представление
		            + " (" + СтруктураЗначения.Ид + ")""";
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Коллекция = ОписаниеВида.Коллекция;
	
	Результат = Коллекция[МетаОбъект.Имя].ПустаяСсылка();
	
	Если НЕ СтруктураЗначения.Свойство("ИдПолный") Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если Найти(СтруктураЗначения.ИдПолный, "00000000000000000000000000000000") > 0 Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если НЕ ТипЗнч(КэшСсылок) = Тип("Соответствие") Тогда
		КэшСсылок = Новый Соответствие();
	КонецЕсли;
	  
	ЗначениеИзКэша = КэшСсылок.Получить(СтруктураЗначения.ИдПолный); 
	Если НЕ ЗначениеИзКэша = Неопределено Тогда
		Возврат ЗначениеизКэша;
	КонецЕсли;
					
	КодПоискаСсылки = "Результат = ";
	Если НЕ ПравилоЗагрузки.Модуль = Неопределено Тогда
		КодПоискаСсылки = КодПоискаСсылки + "ПравилоЗагрузки.Модуль.";
	КонецЕсли;
	
	КодПоискаСсылки = КодПоискаСсылки
	                + СокрЛП(ПравилоЗагрузки.ФункцияПоиска)
	                + "(ОписаниеВида, МетаОбъект, СтруктураЗначения);";
	
	Попытка
		Выполнить(КодПоискаСсылки);
	Исключение
		ТекстОшибки = "Ошибка поиска ссылки по описанию: "
		            + Символы.ПС
		            + ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
		ВызватьИсключение ТекстОшибки;
	КонецПопытки;
	
	Если НЕ ЗначениеЗаполнено(Результат) Тогда
		ПоказатьСообщение("Не найдено значение "
		                 + МетаОбъект.ПолноеИмя() + ": """
			             + СтруктураЗначения.Представление
			             + " (" + СтруктураЗначения.Ид + ")""");
		Если ПолучатьБитыеСсылки Тогда
			Результат = Коллекция[МетаОбъект.Имя].ПолучитьСсылку(Новый УникальныйИдентификатор(СтруктураЗначения.Ид));
		КонецЕсли;
	КонецЕсли;
	
	КэшСсылок.Вставить(СтруктураЗначения.ИдПолный, Результат);
	
	Возврат Результат;
	
КонецФункции // СсылкаИзСтруктуры()

// Преобразует набор записей регистра в структуру
//
// Параметры:
//  НаборЗаписей		- РегистрСведенийНаборЗаписей,   - набор записей регистра для преобразования
//                        РегистрНакопленияНаборЗаписей,
//                        РегистрБухгалтерииНаборЗаписей,
//                        РегистрРасчетаНаборЗаписей
//  СписокСвойств       - Строка, Массив(Строка)         - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)         - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура       - результат преобразования
//		Отбор          - Структура            - Описание отбора записей регистра
//			<имя поля>     - Произвольный          - Значение отбора
//		Записи         - Массив(Структура)    - Массив записей регистра
//			<имя поля>     - Произвольный          - Значения измерений, ресурсов и реквизитов записи регистра
//
//
Функция НаборЗаписейРегистраВСтруктуру(НаборЗаписей 
									 , СписокСвойств = Неопределено
									 , ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = НаборЗаписей.Метаданные();
	
	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(МетаОбъект.ПолноеИмя());

	СтруктураНабораЗаписей = Неопределено;
	
	Если ВРег(ОписаниеВида.Имя) = ВРег("РегистрСведений") Тогда
		СтруктураНабораЗаписей = НаборЗаписейРегистраСведенийВСтруктуру(НаборЗаписей, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("РегистрНакопления") Тогда
		СтруктураНабораЗаписей = НаборЗаписейРегистраНакопленияВСтруктуру(НаборЗаписей, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("РегистрБухгалтерии") Тогда
		СтруктураНабораЗаписей = НаборЗаписейРегистраБухгалтерииВСтруктуру(НаборЗаписей, СписокСвойств, ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("РегистрРасчета") Тогда
		СтруктураНабораЗаписей = НаборЗаписейРегистраРасчетаВСтруктуру(НаборЗаписей, СписокСвойств, ИсключаяСвойства);
	Иначе
		ПоказатьСообщение(СтрШаблонВнутр("Неизвестный тип объекта: %1", МетаОбъект.ПолноеИмя()));
	КонецЕсли;
		
	Возврат СтруктураНабораЗаписей;
	
КонецФункции // НаборЗаписейРегистраВСтруктуру()

// Заполняет набор записей регистра из структуры
//
//  НаборЗаписей         - РегистрСведенийНаборЗаписей   - Набор записей регистра для заполнения
//  СтруктураОбъекта     - Структура                     - Данные для заполнения объекта
//		Отбор                - Структура                     - Описание отбора записей регистра
//			<имя поля>           - Произвольный                  - Значение отбора
//		Записи               - Массив(Структура)             - Массив записей регистра
//			<имя поля>           - Произвольный                  - Значения измерений, ресурсов и реквизитов записи регистра
//  ПолучатьБитыеСсылки  - Булево                        - Истина - если объект по ссылке не существует,
//                                                         будет возвращена битая ссылка;
//                                                         Ложь - будет возвращена пустая ссылка
//  СписокСвойств		 - Строка, Массив(Строка)        - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	 - Строка, Массив(Строка)        - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ЗаполнитьНаборЗаписейРегистраИзСтруктуры(НаборЗаписей
	                                    , СтруктураНабораЗаписей
	                                    , ПолучатьБитыеСсылки
									    , СписокСвойств = Неопределено
									    , ИсключаяСвойства = Неопределено) Экспорт

	МетаОбъект = НаборЗаписей.Метаданные();
	
	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(МетаОбъект.ПолноеИмя());
	
	Если ВРег(ОписаниеВида.Имя) = ВРег("РегистрСведений") Тогда
		НаборЗаписейРегистраСведенийИзСтруктуры(НаборЗаписей,
		                                        СтруктураНабораЗаписей,
		                                        ПолучатьБитыеСсылки,
		                                        СписокСвойств,
		                                        ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("РегистрНакопления") Тогда
		НаборЗаписейРегистраНакопленияИзСтруктуры(НаборЗаписей,
		                                          СтруктураНабораЗаписей,
		                                          ПолучатьБитыеСсылки,
		                                          СписокСвойств,
		                                          ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("РегистрБухгалтерии") Тогда
		НаборЗаписейРегистраБухгалтерииИзСтруктуры(НаборЗаписей,
		                                           СтруктураНабораЗаписей,
		                                           ПолучатьБитыеСсылки,
		                                           СписокСвойств,
		                                           ИсключаяСвойства);
	ИначеЕсли ВРег(ОписаниеВида.Имя) = ВРег("РегистрРасчета") Тогда
		НаборЗаписейРегистраРасчетаИзСтруктуры(НаборЗаписей,
		                                       СтруктураНабораЗаписей,
		                                       ПолучатьБитыеСсылки,
		                                       СписокСвойств,
		                                       ИсключаяСвойства);
	Иначе
		ПоказатьСообщение(СтрШаблонВнутр("Неизвестный тип объекта: %1", МетаОбъект.ПолноеИмя()));
	КонецЕсли;
	
КонецПроцедуры // ЗаполнитьНаборЗаписейРегистраИзСтруктуры()

// Заполняет набор записей регистра из структуры
//
//  НаборЗаписей         - РегистрСведенийНаборЗаписей   - Набор записей регистра для заполнения
//  СтруктураОбъекта     - Структура                     - Данные для заполнения объекта
//		Отбор                - Структура                     - Описание отбора записей регистра
//			<имя поля>           - Произвольный                  - Значение отбора
//		Записи               - Массив(Структура)             - Массив записей регистра
//			<имя поля>           - Произвольный                  - Значения измерений, ресурсов и реквизитов записи регистра
//  ПолучатьБитыеСсылки  - Булево                        - Истина - если объект по ссылке не существует,
//                                                         будет возвращена битая ссылка;
//                                                         Ложь - будет возвращена пустая ссылка
//  СписокСвойств		 - Строка, Массив(Строка)        - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	 - Строка, Массив(Строка)        - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Функция СоздатьНаборЗаписейРегистраИзСтруктуры(СтруктураНабораЗаписей
	                                         , ПолучатьБитыеСсылки
									         , СписокСвойств = Неопределено
									         , ИсключаяСвойства = Неопределено) Экспорт

	ТипОбъекта = "NULL";
	Если СтруктураНабораЗаписей.Свойство("__Тип") Тогда 
		ТипОбъекта = СтруктураНабораЗаписей.Ссылка.__Тип;
	Иначе
		ТекстОшибки = "Структура не содержит указания типа значения или не является представлением набора записей. Поля :";
		ДополнитьТекстПолямиСтруктуры(ТекстОшибки, СтруктураНабораЗаписей);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Попытка
		ОписаниеВида = ПолучитьОписаниеВидаОбъектов(ТипОбъекта);
	Исключение
		ВызватьИсключение СтрШаблонВнутр("Ошибка получения описания вида объекта ""%1"": %2%3",
		                            ТипОбъекта,
		                            Символы.ПС,
		                            ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	МетаОбъект = Метаданные.НайтиПоПолномуИмени(СтрШаблонВнутр("%1.%2", ОписаниеВида.Имя, ОписаниеВида.ИмяТипа));
	//@skip-warning
	Менеджер = ОписаниеВида.Коллекция[МетаОбъект.Имя];
	
	Конструктор = ОписаниеВида.Конструктор;
	
	НаборЗаписей = Неопределено;
	
	Если ЗначениеЗаполнено(Конструктор) Тогда
		
		НаборЗаписей = Вычислить("Менеджер." + Конструктор + "()");
		
		ЗаполнитьНаборЗаписейРегистраИзСтруктуры(НаборЗаписей,
		                                         СтруктураНабораЗаписей,
		                                         ПолучатьБитыеСсылки,
		                                         СписокСвойств,
		                                         ИсключаяСвойства);
		
	КонецЕсли;
	
	Возврат НаборЗаписей;
	
КонецФункции // СоздатьНаборЗаписейРегистраИзСтруктуры()

// Преобразует набор записей регистра, полученный по указанному отбору, в структуру
//
// Параметры:
//  Регистр				- Строка					- Строковое представление типа регистра (например: РегистрСведений.КурсыВалют)
//  Отбор				- Структура					- Структура вида <Имя поля>: <Значение поля>, значения полей отбора
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Отбор			- Структура				- Описание отбора записей регистра
//			<имя поля>		- Произвольный			- Значение отбора
//		Записи			- Массив(Структура)		- Массив записей регистра
//			<имя поля>		- Произвольный			- Значения измерений, ресурсов и реквизитов записи регистра
//
Функция РегистрПоОтборуВСтруктуру(Регистр, Отбор) Экспорт
	
	ОписаниеВида = ПолучитьОписаниеВидаОбъектов(Регистр);
	
	Если ОписаниеВида = Неопределено Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	НаборЗаписей = ОписаниеВида.Коллекция[ОписаниеВида.ИмяТипа].СоздатьНаборЗаписей();
	Для Каждого ТекЭлемент Из Отбор Цикл
		НаборЗаписей.Отбор[ТекЭлемент.Ключ].Установить(ТекЭлемент.Значение);
	КонецЦикла;
	НаборЗаписей.Прочитать();
	
	Возврат НаборЗаписейРегистраВСтруктуру(НаборЗаписей);
	
КонецФункции // РегистрПоОтборуВСтруктуру()

// Преобразует движения документа в структуру
//
// Параметры:
//  Объект				- ДокументСсылка			- Документ, для которого получаются движения
//  СписокРегистров		- Строка, Массив(Строка)	- Список обрабатываемых регистров (если пустой, то обрабатываются все регистры)
//  ИсключаяРегистры	- Строка, Массив(Строка)	- Список исключаемых регистров (если пустой, то обрабатываются все регистры)
//
// Возвращаемое значение:
//   Структура				- движения документа по регистрам
//		<Имя регистра>			- Структура				- Движения регистра
//			Отбор					- Структура				- Описание отбора записей регистра
//				<имя поля>				- Произвольный			- Значение отбора
//			Записи				- Массив(Структура)		- Массив записей регистра
//				<имя поля>			- Произвольный			- Значения измерений, ресурсов и реквизитов записи регистра
//
Функция ДвиженияДокументаВСтруктуру(Объект, СписокРегистров = Неопределено, ИсключаяРегистры = Неопределено) Экспорт
	
	МетаОбъект = Объект.Метаданные();
	
	ДвиженияПрочитаны = Ложь;
	Для Каждого ТекДвижения Из МетаОбъект.Движения Цикл
		Если Объект.Движения[ТекДвижения.Имя].Количество() > 0 Тогда
			ДвиженияПрочитаны = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;

	СтруктураДвижений = Новый Структура();
	Для Каждого ТекДвижения Из МетаОбъект.Движения Цикл
		Если НЕ ИспользоватьСвойство(ТекДвижения.Имя, СписокРегистров, ИсключаяРегистры) Тогда
			Продолжить;
		КонецЕсли;
		
		Если НЕ ДвиженияПрочитаны Тогда
			Объект.Движения[ТекДвижения.Имя].Прочитать();
		КонецЕсли;
		
		СтруктураОбъекта = НаборЗаписейРегистраВСтруктуру(Объект.Движения[ТекДвижения.Имя]);
		
		СтруктураДвижений.Вставить(ТекДвижения.Имя, СтруктураОбъекта);
	КонецЦикла;
	
	Возврат СтруктураДвижений;
	
КонецФункции // ДвиженияДокументаВСтруктуру()

// Заполняет движения документа из структуры
//
// Параметры:
//  Объект              - ДокументОбъект            - Документ, для которого заполняются движения
//  СтруктураДвижений   - Структура	                - Движения документа по регистрам
//		<Имя регистра>      - Структура	                - Движения регистра
//			Отбор               - Структура	                - Описание отбора записей регистра
//				<имя поля>          - Произвольный              - Значение отбора
//			Записи          - Массив(Структура)             - Массив записей регистра
//				<имя поля>      - Произвольный                  - Значения измерений, ресурсов и реквизитов записи регистра
//  ПолучатьБитыеСсылки     - Булево                - Истина - если объект по ссылке не существует,
//                                                                будет возвращена битая ссылка;
//                                                                Ложь - будет возвращена пустая ссылка
//  СписокРегистров     - Строка, Массив(Строка)	- Список обрабатываемых регистров (если пустой, то обрабатываются все регистры)
//  ИсключаяРегистры	- Строка, Массив(Строка)	- Список исключаемых регистров (если пустой, то обрабатываются все регистры)
//
// Возвращаемое значение:
//
Процедура ДвиженияДокументаИзСтруктуры(Объект
	                                 , СтруктураДвижений
	                                 , ПолучатьБитыеСсылки = Ложь
	                                 , СписокРегистров = Неопределено
	                                 , ИсключаяРегистры = Неопределено) Экспорт

	МетаОбъект = Объект.Метаданные();
	
	Для Каждого ТекДвижения Из МетаОбъект.Движения Цикл
		
		Если НЕ СтруктураДвижений.Свойство(ТекДвижения.Имя) Тогда
			Продолжить;
		КонецЕсли;
		
		Если НЕ ИспользоватьСвойство(ТекДвижения.Имя, СписокРегистров, ИсключаяРегистры) Тогда
			Продолжить;
		КонецЕсли;
		
		ЗаполнитьНаборЗаписейРегистраИзСтруктуры(Объект.Движения[ТекДвижения.Имя],
		                                         СтруктураДвижений[ТекДвижения.Имя],
		                                         ПолучатьБитыеСсылки);
	КонецЦикла;
	
КонецПроцедуры // ДвиженияДокументаИзСтруктуры()

#КонецОбласти // ПреобразованияОбъектовОбщие

#Область ПреобразованияОбъектовПоВидам

// Преобразует элемент справочника в структуру
//
// Параметры:
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Ссылка			- Структура		- Описание ссылки на объект
//			Тип 						- Строка		- Текстовое описание типа объекта
//			Ид                          - Строка		- Уникальный идентификатор ссылки
//			ИдПолный					- Строка		- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево		- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка		- Имя предопределенного значения
//			Представление				- Строка		- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный	- Дополнительные поля добавленные при выгрузке
//		__ТЧ			- Массив		- Массив табличных частей объекта
//		<имя поля>						- Произвольный	- Значения реквизитов объекта
//
Функция СправочникВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = Объект.Метаданные();
	
	Если НЕ ТипЗнч(Объект) = Тип(СтрШаблонВнутр("СправочникОбъект.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("СправочникОбъект.%1", МетаОбъект.Имя));

	Если Объект.Ссылка.Пустая() Тогда
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.ПолучитьСсылкуНового()));
	Иначе
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.Ссылка));
	КонецЕсли;
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ЭтоГруппа", СписокСвойств, ИсключаяСвойства);
	
	СтруктураОбъекта.Вставить("Родитель", Неопределено);
	Если МетаОбъект.Иерархический Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Родитель", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
			
	СтруктураОбъекта.Вставить("Владелец", Неопределено);
	Если МетаОбъект.Владельцы.Количество() > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Владелец", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("Код", Неопределено);
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Код", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("Наименование", Неопределено);
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		Если НЕ СвойствоИерархическогоОбъектаИспользуется(Объект, ТекРеквизит, МетаОбъект) Тогда
			Продолжить;
		КонецЕсли;
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		Если НЕ СвойствоИерархическогоОбъектаИспользуется(Объект, ТекТЧ, МетаОбъект) Тогда
			Продолжить;
		КонецЕсли;
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Возврат СтруктураОбъекта;
	
КонецФункции // СправочникВСтруктуру()

// Заполняет справочник из структуры
//
// Параметры:
//  Объект               - Объект                    - Заполняемый объект
//  СтруктураОбъекта     - Структура                      - Данные для заполнения объекта
//        Ссылка                   - Структура                - Описание ссылки на объект
//            Тип                         - Строка                - Текстовое описание типа объекта
//            Ид                          - Строка                - Уникальный идентификатор ссылки
//            ИдПолный                    - Строка                - Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//            Предопределенный            - Булево                - Истина - предопределенное значение; Ложь - в противном случае
//            ИмяПредопределенныхДанных   - Строка                - Имя предопределенного значения
//            Представление               - Строка                - Стандатрное строковое представление объекта
//            <имя поля>                  - Произвольный          - Дополнительные поля добавленные при выгрузке
//        __ТЧ                    - Массив                    - Массив табличных частей объекта
//        <имя поля>              - Произвольный              - Значения реквизитов объекта
//  ПолучатьБитыеСсылки  - Булево                   - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//  СписокСвойств       - Строка, Массив(Строка)    - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)    - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура СправочникИзСтруктуры(Объект
	                          , СтруктураОбъекта
	                          , ПолучатьБитыеСсылки = Ложь
	                          , СписокСвойств = Неопределено
	                          , ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = Объект.Метаданные();
	
	МетаСвойства = Метаданные.СвойстваОбъектов;
	
	СвойствоОбъектаИзСтруктуры(Объект,
							   СтруктураОбъекта,
							   "ПометкаУдаления",
							   ,
							   СписокСвойств,
							   ИсключаяСвойства);
	
	Если МетаОбъект.Иерархический Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "Родитель",
								   ПолучатьБитыеСсылки,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЕсли;
			
	Если МетаОбъект.Владельцы.Количество() > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "Владелец",
								   ПолучатьБитыеСсылки,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЕсли;
	
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "Код",
								   ,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЕсли;
	
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "Наименование",
								   ,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		Если МетаОбъект.Иерархический И МетаОбъект.ВидИерархии = МетаСвойства.ВидИерархии.ИерархияГруппИЭлементов Тогда
			Если (Объект.ЭтоГруппа И ТекРеквизит.Использование = МетаСвойства.ИспользованиеРеквизита.ДляЭлемента)
			 ИЛИ (НЕ Объект.ЭтоГруппа И ТекРеквизит.Использование = МетаСвойства.ИспользованиеРеквизита.ДляГруппы)Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   ТекРеквизит.Имя,
								   ПолучатьБитыеСсылки,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		Если МетаОбъект.Иерархический И МетаОбъект.ВидИерархии = МетаСвойства.ВидИерархии.ИерархияГруппИЭлементов Тогда
			Если (Объект.ЭтоГруппа И ТекТЧ.Использование = МетаСвойства.ИспользованиеРеквизита.ДляЭлемента)
			 ИЛИ (НЕ Объект.ЭтоГруппа И ТекТЧ.Использование = МетаСвойства.ИспользованиеРеквизита.ДляГруппы)Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		ТЧОбъектаИзСтруктуры(Объект,
							 СтруктураОбъекта,
							 ТекТЧ.Имя,
							 ПолучатьБитыеСсылки,
							 СписокСвойств,
							 ИсключаяСвойства);
	КонецЦикла;
	
КонецПроцедуры // СправочникИзСтруктуры()

// Преобразует счет в структуру
//
// Параметры:
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Ссылка			- Структура		- Описание ссылки на объект
//			Тип 						- Строка		- Текстовое описание типа объекта
//			Ид                          - Строка		- Уникальный идентификатор ссылки
//			ИдПолный					- Строка		- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево		- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка		- Имя предопределенного значения
//			Представление				- Строка		- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный	- Дополнительные поля добавленные при выгрузке
//		__ТЧ			- Массив		- Массив табличных частей объекта
//		<имя поля>						- Произвольный	- Значения реквизитов объекта
//
Функция ПланСчетовВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = Объект.Метаданные();
	
	Если НЕ ТипЗнч(Объект) = Тип(СтрШаблонВнутр("ПланСчетовОбъект.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("ПланСчетовОбъект.%1", МетаОбъект.Имя));

	Если Объект.Ссылка.Пустая() Тогда
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.ПолучитьСсылкуНового()));
	Иначе
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.Ссылка));
	КонецЕсли;
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Забалансовый", СписокСвойств, ИсключаяСвойства);
	
	Если ИспользоватьСвойство("Вид", СписокСвойств, ИсключаяСвойства) Тогда
		Если Объект.Вид = ВидСчета.Активный Тогда
			СтруктураОбъекта.Вставить("Вид", "Активный");
		ИначеЕсли Объект.Вид = ВидСчета.Пассивный Тогда
			СтруктураОбъекта.Вставить("Вид", "Пассивный");
		Иначе
			СтруктураОбъекта.Вставить("Вид", "АктивноПассивный");
		КонецЕсли;
	КонецЕсли;
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Родитель", СписокСвойств, ИсключаяСвойства);
			
	СтруктураОбъекта.Вставить("Код", Неопределено);
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Код", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("Порядок", Неопределено);
	Если МетаОбъект.ДлинаПорядка > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Порядок", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("Наименование", Неопределено);
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Для Каждого ТекПризнак Из МетаОбъект.ПризнакиУчета Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекПризнак.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	СтруктураОбъекта.Вставить("ВидыСубконто", Новый Массив());
	Если ИспользоватьСвойство("ВидыСубконто", СписокСвойств, ИсключаяСвойства)
	   И МетаОбъект.МаксКоличествоСубконто > 0 Тогда
		й = 1;
		Для Каждого ТекСтрока Из Объект.ВидыСубконто Цикл
			СтрокаСубконто = Новый Структура("НомерСтроки, ВидСубконто, ТолькоОбороты"
											, й
											, ЗначениеВСтруктуру(ТекСтрока.ВидСубконто)
											, ТекСтрока.ТолькоОбороты);
			
			Для Каждого ТекПризнак Из МетаОбъект.ПризнакиУчетаСубконто Цикл
				СтрокаСубконто.Вставить(ТекПризнак.Имя, ТекСтрока[ТекПризнак.Имя]);
			КонецЦикла;
			СтруктураОбъекта.ВидыСубконто.Добавить(СтрокаСубконто);
			й = й + 1;
		КонецЦикла;
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ПланСчетовВСтруктуру()

// Заполняет счет из структуры
//
// Параметры:
//  Объект               - Объект                    - Заполняемый объект
//  СтруктураОбъекта     - Структура                      - Данные для заполнения объекта
//        Ссылка                   - Структура                - Описание ссылки на объект
//            Тип                         - Строка                - Текстовое описание типа объекта
//            Ид                          - Строка                - Уникальный идентификатор ссылки
//            ИдПолный                    - Строка                - Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//            Предопределенный            - Булево                - Истина - предопределенное значение; Ложь - в противном случае
//            ИмяПредопределенныхДанных   - Строка                - Имя предопределенного значения
//            Представление               - Строка                - Стандатрное строковое представление объекта
//            <имя поля>                  - Произвольный          - Дополнительные поля добавленные при выгрузке
//        __ТЧ                    - Массив                    - Массив табличных частей объекта
//        <имя поля>              - Произвольный              - Значения реквизитов объекта
//  ПолучатьБитыеСсылки  - Булево                   - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//  СписокСвойств       - Строка, Массив(Строка)    - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)    - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ПланСчетовИзСтруктуры(Объект
	                          , СтруктураОбъекта
	                          , ПолучатьБитыеСсылки = Ложь
	                          , СписокСвойств = Неопределено
	                          , ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = Объект.Метаданные();
	
	СвойствоОбъектаИзСтруктуры(Объект,
							   СтруктураОбъекта,
							   "ПометкаУдаления",
							   ,
							   СписокСвойств,
							   ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект,
							   СтруктураОбъекта,
							   "Забалансовый",
							   ,
							   СписокСвойств,
							   ИсключаяСвойства);
	Если ИспользоватьСвойство("Вид", СписокСвойств, ИсключаяСвойства) Тогда
		Объект.Вид = Вычислить("ВидСчета." + СтруктураОбъекта.Вид);
	КонецЕсли;
	
	СвойствоОбъектаИзСтруктуры(Объект,
							   СтруктураОбъекта,
							   "Родитель",
							   ПолучатьБитыеСсылки,
							   СписокСвойств,
							   ИсключаяСвойства);
			
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "Код",
								   ,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЕсли;
	
	Если МетаОбъект.ДлинаПорядка > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "Порядок",
								   ,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЕсли;
	
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "Наименование",
								   ,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЕсли;
	
	Для Каждого ТекПризнак Из МетаОбъект.ПризнакиУчета Цикл
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   ТекПризнак.Имя,
								   ПолучатьБитыеСсылки,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЦикла;
	
	Если СтруктураОбъекта.Свойство("ВидыСубконто")
	   И ИспользоватьСвойство("ВидыСубконто", СписокСвойств, ИсключаяСвойства)
	   И МетаОбъект.МаксКоличествоСубконто > 0 Тогда
		Объект.ВидыСубконто.Очистить();
		Для Каждого ТекСтрока Из СтруктураОбъекта.ВидыСубконто Цикл
			Если Объект.ВидыСубконто.Количество() >= МетаОбъект.МаксКоличествоСубконто Тогда
				Прервать;
			КонецЕсли;
			НоваяСтрока = Объект.ВидыСубконто.Добавить();
			НоваяСтрока.ВидСубконто		= ЗначениеИзСтруктуры(ТекСтрока.ВидСубконто, ПолучатьБитыеСсылки);
			НоваяСтрока.ТолькоОбороты	= ТекСтрока.ТолькоОбороты;
			
			Для Каждого ТекПризнак Из МетаОбъект.ПризнакиУчетаСубконто Цикл
				Если НЕ ТекСтрока.Свойство(ТекПризнак.Имя) Тогда
					Продолжить;
				КонецЕсли;
				НоваяСтрока[ТекПризнак.Имя] = ТекСтрока[ТекПризнак.Имя];
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   ТекРеквизит.Имя,
								   ПолучатьБитыеСсылки,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаИзСтруктуры(Объект,
							 СтруктураОбъекта,
							 ТекТЧ.Имя,
							 ПолучатьБитыеСсылки,
							 СписокСвойств,
							 ИсключаяСвойства);
	КонецЦикла;
	
КонецПроцедуры // ПланСчетовИзСтруктуры()

// Преобразует элемент плана видов характеристик в структуру
//
// Параметры:
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Ссылка			- Структура		- Описание ссылки на объект
//			Тип 						- Строка		- Текстовое описание типа объекта
//			Ид                          - Строка		- Уникальный идентификатор ссылки
//			ИдПолный					- Строка		- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево		- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка		- Имя предопределенного значения
//			Представление				- Строка		- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный	- Дополнительные поля добавленные при выгрузке
//		__ТЧ			- Массив		- Массив табличных частей объекта
//		<имя поля>						- Произвольный	- Значения реквизитов объекта
//
Функция ПланВидовХарактеристикВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = Объект.Метаданные();
	
	Если НЕ ТипЗнч(Объект) = Тип(СтрШаблонВнутр("ПланВидовХарактеристикОбъект.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("ПланВидовХарактеристикОбъект.%1", МетаОбъект.Имя));

	Если Объект.Ссылка.Пустая() Тогда
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.ПолучитьСсылкуНового()));
	Иначе
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.Ссылка));
	КонецЕсли;
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ЭтоГруппа", СписокСвойств, ИсключаяСвойства);
	
	СтруктураОбъекта.Вставить("Родитель", Неопределено);
	Если МетаОбъект.Иерархический Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Родитель", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
			
	СтруктураОбъекта.Вставить("Код", Неопределено);
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Код", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("Наименование", Неопределено);
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("ТипЗначения", ОписаниеТиповВСтруктуру(Объект.ТипЗначения));

	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		Если НЕ СвойствоИерархическогоОбъектаИспользуется(Объект, ТекРеквизит) Тогда
			Продолжить;
		КонецЕсли;
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		Если НЕ СвойствоИерархическогоОбъектаИспользуется(Объект, ТекТЧ) Тогда
			Продолжить;
		КонецЕсли;
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ПланВидовХарактеристикВСтруктуру()

// Заполняет элемент плана вида характеристик из структуры
//
// Параметры:
//  Объект               - Объект                    - Заполняемый объект
//  СтруктураОбъекта     - Структура                      - Данные для заполнения объекта
//        Ссылка                   - Структура                - Описание ссылки на объект
//            Тип                         - Строка                - Текстовое описание типа объекта
//            Ид                          - Строка                - Уникальный идентификатор ссылки
//            ИдПолный                    - Строка                - Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//            Предопределенный            - Булево                - Истина - предопределенное значение; Ложь - в противном случае
//            ИмяПредопределенныхДанных   - Строка                - Имя предопределенного значения
//            Представление               - Строка                - Стандатрное строковое представление объекта
//            <имя поля>                  - Произвольный          - Дополнительные поля добавленные при выгрузке
//        __ТЧ                    - Массив                    - Массив табличных частей объекта
//        <имя поля>              - Произвольный              - Значения реквизитов объекта
//  ПолучатьБитыеСсылки  - Булево                   - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//  СписокСвойств       - Строка, Массив(Строка)    - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)    - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ПланВидовХарактеристикИзСтруктуры(Объект
	                                      , СтруктураОбъекта
	                                      , ПолучатьБитыеСсылки = Ложь
	                                      , СписокСвойств = Неопределено
	                                      , ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = Объект.Метаданные();
	
	СвойствоОбъектаИзСтруктуры(Объект,
							   СтруктураОбъекта,
							   "ПометкаУдаления",
							   ,
							   СписокСвойств,
							   ИсключаяСвойства);
	
	Если МетаОбъект.Иерархический Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "Родитель",
								   ПолучатьБитыеСсылки,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЕсли;
			
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "Код",
								   ,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЕсли;
	
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "Наименование",
								   ,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЕсли;
	
	Если СтруктураОбъекта.ТипЗначения.Типы.Количество() > 0 Тогда
		Объект.ТипЗначения = ОписаниеТиповИзСтруктуры(СтруктураОбъекта.ТипЗначения);
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		Если МетаОбъект.Иерархический Тогда
			Если (Объект.ЭтоГруппа
				  И ТекРеквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
			 ИЛИ (НЕ Объект.ЭтоГруппа
			      И ТекРеквизит.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы)Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   ТекРеквизит.Имя,
								   ПолучатьБитыеСсылки,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		Если МетаОбъект.Иерархический Тогда
			Если (Объект.ЭтоГруппа И ТекТЧ.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляЭлемента)
			 ИЛИ (НЕ Объект.ЭтоГруппа И ТекТЧ.Использование = Метаданные.СвойстваОбъектов.ИспользованиеРеквизита.ДляГруппы)Тогда
				Продолжить;
			КонецЕсли;
		КонецЕсли;
		ТЧОбъектаИзСтруктуры(Объект,
							 СтруктураОбъекта,
							 ТекТЧ.Имя,
							 ПолучатьБитыеСсылки,
							 СписокСвойств,
							 ИсключаяСвойства);
	КонецЦикла;
	
КонецПроцедуры // ПланВидовХарактеристикИзСтруктуры()

// Преобразует вид расчета в структуру
//
// Параметры:
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Ссылка			- Структура		- Описание ссылки на объект
//			Тип 						- Строка		- Текстовое описание типа объекта
//			Ид                          - Строка		- Уникальный идентификатор ссылки
//			ИдПолный					- Строка		- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево		- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка		- Имя предопределенного значения
//			Представление				- Строка		- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный	- Дополнительные поля добавленные при выгрузке
//		__ТЧ			- Массив		- Массив табличных частей объекта
//		<имя поля>						- Произвольный	- Значения реквизитов объекта
//
Функция ПланВидовРасчетаВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = Объект.Метаданные();
	
	Если НЕ ТипЗнч(Объект) = Тип(СтрШаблонВнутр("ПланВидовРасчетаОбъект.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("ПланВидовРасчетаОбъект.%1", МетаОбъект.Имя));

	Если Объект.Ссылка.Пустая() Тогда
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.ПолучитьСсылкуНового()));
	Иначе
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.Ссылка));
	КонецЕсли;
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	
	СтруктураОбъекта.Вставить("БазовыеВидыРасчета", Новый Массив());
	Если НЕ МетаОбъект.ЗависимостьОтВидовРасчета =
			Метаданные.СвойстваОбъектов.ИспользованиеБазыПланаВидовРасчета.НеИспользовать
	   И ИспользоватьСвойство("БазовыеВидыРасчета", СписокСвойств, ИсключаяСвойства) Тогда
		Для Каждого ТекВР Из Объект.БазовыеВидыРасчета Цикл
			СтруктураОбъекта.БазовыеВидыРасчета.Добавить(ЗначениеВСтруктуру(ТекВР.ВидРасчета));
		КонецЦикла;
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("ВедущиеВидыРасчета", Новый Массив());
	Если ИспользоватьСвойство("ВедущиеВидыРасчета", СписокСвойств, ИсключаяСвойства) Тогда
		Для Каждого ТекВР Из Объект.ВедущиеВидыРасчета Цикл
			СтруктураОбъекта.ВедущиеВидыРасчета.Добавить(ЗначениеВСтруктуру(ТекВР.ВидРасчета));
		КонецЦикла;
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("ВытесняющиеВидыРасчета", Новый Массив());
	Если МетаОбъект.ИспользованиеПериодаДействия
	   И ИспользоватьСвойство("ВытесняющиеВидыРасчета", СписокСвойств, ИсключаяСвойства) Тогда
		Для Каждого ТекВР Из Объект.ВытесняющиеВидыРасчета Цикл
			СтруктураОбъекта.ВытесняющиеВидыРасчета.Добавить(ЗначениеВСтруктуру(ТекВР.ВидРасчета));
		КонецЦикла;
	КонецЕсли;
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПериодДействияБазовый", СписокСвойств, ИсключаяСвойства);
	
	СтруктураОбъекта.Вставить("Код", Неопределено);
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Код", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	СтруктураОбъекта.Вставить("Наименование", Неопределено);
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ПланВидовРасчетаВСтруктуру()

// Заполняет вид расчета из структуры
//
// Параметры:
//  Объект               - Объект                    - Заполняемый объект
//  СтруктураОбъекта     - Структура                      - Данные для заполнения объекта
//        Ссылка                   - Структура                - Описание ссылки на объект
//            Тип                         - Строка                - Текстовое описание типа объекта
//            Ид                          - Строка                - Уникальный идентификатор ссылки
//            ИдПолный                    - Строка                - Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//            Предопределенный            - Булево                - Истина - предопределенное значение; Ложь - в противном случае
//            ИмяПредопределенныхДанных   - Строка                - Имя предопределенного значения
//            Представление               - Строка                - Стандатрное строковое представление объекта
//            <имя поля>                  - Произвольный          - Дополнительные поля добавленные при выгрузке
//        __ТЧ                    - Массив                    - Массив табличных частей объекта
//        <имя поля>              - Произвольный              - Значения реквизитов объекта
//  ПолучатьБитыеСсылки  - Булево                   - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//  СписокСвойств       - Строка, Массив(Строка)    - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)    - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ПланВидовРасчетаИзСтруктуры(Объект
	                                , СтруктураОбъекта
	                                , ПолучатьБитыеСсылки = Ложь
	                                , СписокСвойств = Неопределено
	                                , ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = Объект.Метаданные();
	
	СвойствоОбъектаИзСтруктуры(Объект,
							   СтруктураОбъекта,
							   "ПометкаУдаления",
							   ,
							   СписокСвойств,
							   ИсключаяСвойства);
	
	Если НЕ МетаОбъект.ЗависимостьОтВидовРасчета =
			Метаданные.СвойстваОбъектов.ИспользованиеБазыПланаВидовРасчета.НеИспользовать
	   И ИспользоватьСвойство("БазовыеВидыРасчета", СписокСвойств, ИсключаяСвойства) Тогда
		Объект.БазовыеВидыРасчета.Очистить();
		Для Каждого ТекВР Из СтруктураОбъекта.БазовыеВидыРасчета Цикл
			ВремВР = ЗначениеИзСтруктуры(ТекВР, ПолучатьБитыеСсылки);
			Если НЕ ЗначениеЗаполнено(ВремВР) Тогда
				Продолжить;
			КонецЕсли;
			НоваяСтрока = Объект.БазовыеВидыРасчета.Добавить();
			НоваяСтрока.ВидРасчета = ВремВР;
		КонецЦикла;
	КонецЕсли;
	
	Если ИспользоватьСвойство("ВедущиеВидыРасчета", СписокСвойств, ИсключаяСвойства) Тогда
		Объект.ВедущиеВидыРасчета.Очистить();
		Для Каждого ТекВР Из СтруктураОбъекта.ВедущиеВидыРасчета Цикл
			ВремВР = ЗначениеИзСтруктуры(ТекВР, ПолучатьБитыеСсылки);
			Если НЕ ЗначениеЗаполнено(ВремВР) Тогда
				Продолжить;
			КонецЕсли;
			НоваяСтрока = Объект.ВедущиеВидыРасчета.Добавить();
			НоваяСтрока.ВидРасчета = ВремВР;
		КонецЦикла;
	КонецЕсли;
	
	Если МетаОбъект.ИспользованиеПериодаДействия
	   И ИспользоватьСвойство("ВытесняющиеВидыРасчета", СписокСвойств, ИсключаяСвойства) Тогда
		Объект.ВытесняющиеВидыРасчета.Очистить();
		Для Каждого ТекВР Из СтруктураОбъекта.ВытесняющиеВидыРасчета Цикл
			ВремВР = ЗначениеИзСтруктуры(ТекВР, ПолучатьБитыеСсылки);
			Если НЕ ЗначениеЗаполнено(ВремВР) Тогда
				Продолжить;
			КонецЕсли;
			НоваяСтрока = Объект.ВытесняющиеВидыРасчета.Добавить();
			НоваяСтрока.ВидРасчета = ВремВР;
		КонецЦикла;
	КонецЕсли;
	
	СвойствоОбъектаИзСтруктуры(Объект,
							   СтруктураОбъекта,
							   "ПериодДействияБазовый",
							   ,
							   СписокСвойств,
							   ИсключаяСвойства);
	
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "Код",
								   ,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЕсли;
	
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "Наименование",
								   ,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   ТекРеквизит.Имя,
								   ПолучатьБитыеСсылки,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаИзСтруктуры(Объект,
							 СтруктураОбъекта,
							 ТекТЧ.Имя,
							 ПолучатьБитыеСсылки,
							 СписокСвойств,
							 ИсключаяСвойства);
	КонецЦикла;
	
КонецПроцедуры // ПланВидовРасчетаИзСтруктуры()

// Преобразует узел обмена в структуру
//
// Параметры:
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Ссылка			- Структура		- Описание ссылки на объект
//			Тип 						- Строка		- Текстовое описание типа объекта
//			Ид                          - Строка		- Уникальный идентификатор ссылки
//			ИдПолный					- Строка		- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево		- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка		- Имя предопределенного значения
//			Представление				- Строка		- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный	- Дополнительные поля добавленные при выгрузке
//		__ТЧ			- Массив		- Массив табличных частей объекта
//		<имя поля>						- Произвольный	- Значения реквизитов объекта
//
Функция ПланОбменаВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = Объект.Метаданные();
	
	Если НЕ ТипЗнч(Объект) = Тип(СтрШаблонВнутр("ПланОбменаОбъект.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("ПланОбменаОбъект.%1", МетаОбъект.Имя));

	Если Объект.Ссылка.Пустая() Тогда
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.ПолучитьСсылкуНового()));
	Иначе
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.Ссылка));
	КонецЕсли;
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	
	// совместимость с версиями < 8.3.5
	Попытка
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ЭтотУзел", СписокСвойств, ИсключаяСвойства);
	Исключение
		Если ИспользоватьСвойство("ЭтотУзел", СписокСвойств, ИсключаяСвойства) Тогда
			Если Объект.Ссылка.Пустая() Тогда
				СтруктураОбъекта.Вставить("ЭтотУзел", ПланыОбмена[МетаОбъект.Имя].ЭтотУзел() = Объект.ПолучитьСсылкуНового());
			Иначе
				СтруктураОбъекта.Вставить("ЭтотУзел", ПланыОбмена[МетаОбъект.Имя].ЭтотУзел() = Объект.Ссылка);
			КонецЕсли;
		КонецЕсли;
	КонецПопытки;
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "НомерОтправленного", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "НомерПринятого", СписокСвойств, ИсключаяСвойства);
	
	СтруктураОбъекта.Вставить("Код", Неопределено);
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Код", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("Наименование", Неопределено);
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ПланОбменаВСтруктуру()

// Заполняет узел плана обмена из структуры
//
// Параметры:
//  Объект               - Объект                    - Заполняемый объект
//  СтруктураОбъекта     - Структура                      - Данные для заполнения объекта
//        Ссылка                   - Структура                - Описание ссылки на объект
//            Тип                         - Строка                - Текстовое описание типа объекта
//            Ид                          - Строка                - Уникальный идентификатор ссылки
//            ИдПолный                    - Строка                - Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//            Предопределенный            - Булево                - Истина - предопределенное значение; Ложь - в противном случае
//            ИмяПредопределенныхДанных   - Строка                - Имя предопределенного значения
//            Представление               - Строка                - Стандатрное строковое представление объекта
//            <имя поля>                  - Произвольный          - Дополнительные поля добавленные при выгрузке
//        __ТЧ                    - Массив                    - Массив табличных частей объекта
//        <имя поля>              - Произвольный              - Значения реквизитов объекта
//  ПолучатьБитыеСсылки  - Булево                   - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//  СписокСвойств       - Строка, Массив(Строка)    - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)    - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ПланОбменаИзСтруктуры(Объект
	                          , СтруктураОбъекта
	                          , ПолучатьБитыеСсылки = Ложь
	                          , СписокСвойств = Неопределено
	                          , ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = Объект.Метаданные();
	
	СвойствоОбъектаИзСтруктуры(Объект, СтруктураОбъекта, "ПометкаУдаления", , СписокСвойств, ИсключаяСвойства);
	
	// совместимость с версиями < 8.3.5
	Попытка
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "ЭтотУзел",
								   ,
								   СписокСвойств, ИсключаяСвойства);
	Исключение
	КонецПопытки;
	
	Если НЕ Объект.ЭтотУзел Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "НомерОтправленного",
								   ,
								   СписокСвойств,
								   ИсключаяСвойства);
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "НомерПринятого",
								   ,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЕсли;
	
	Если МетаОбъект.ДлинаКода > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "Код",
								   ,
								   СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "Наименование",
								   ,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   ТекРеквизит.Имя,
								   ПолучатьБитыеСсылки,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаИзСтруктуры(Объект,
							 СтруктураОбъекта,
							 ТекТЧ.Имя,
							 ПолучатьБитыеСсылки,
							 СписокСвойств,
							 ИсключаяСвойства);
	КонецЦикла;
	
КонецПроцедуры // ПланОбменаИзСтруктуры()

// Преобразует документ в структуру
//
// Параметры:
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Ссылка			- Структура		- Описание ссылки на объект
//			Тип 						- Строка		- Текстовое описание типа объекта
//			Ид                          - Строка		- Уникальный идентификатор ссылки
//			ИдПолный					- Строка		- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево		- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка		- Имя предопределенного значения
//			Представление				- Строка		- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный	- Дополнительные поля добавленные при выгрузке
//		__ТЧ			- Массив		- Массив табличных частей объекта
//		<имя поля>						- Произвольный	- Значения реквизитов объекта
//
Функция ДокументВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = Объект.Метаданные();
	
	Если НЕ ТипЗнч(Объект) = Тип(СтрШаблонВнутр("ДокументОбъект.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("ДокументОбъект.%1", МетаОбъект.Имя));

	Если Объект.Ссылка.Пустая() Тогда
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.ПолучитьСсылкуНового()));
	Иначе
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.Ссылка));
	КонецЕсли;
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Проведен", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Дата", СписокСвойств, ИсключаяСвойства);
	
	СтруктураОбъекта.Вставить("Номер", Неопределено);
	// TODO: Тут еще нужно проверить использование нумератора
	Если МетаОбъект.ДлинаНомера > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Номер", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Если ИспользоватьСвойство("Движения", СписокСвойств, ИсключаяСвойства) Тогда
		СтруктураОбъекта.Вставить("Движения", ДвиженияДокументаВСтруктуру(Объект, СписокСвойств, ИсключаяСвойства));
	КонецЕсли;
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ДокументВСтруктуру()

// Заполняет документ из структуры
//
// Параметры:
//  Объект               - Объект                    - Заполняемый объект
//  СтруктураОбъекта     - Структура                      - Данные для заполнения объекта
//        Ссылка                   - Структура                - Описание ссылки на объект
//            Тип                         - Строка                - Текстовое описание типа объекта
//            Ид                          - Строка                - Уникальный идентификатор ссылки
//            ИдПолный                    - Строка                - Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//            Предопределенный            - Булево                - Истина - предопределенное значение; Ложь - в противном случае
//            ИмяПредопределенныхДанных   - Строка                - Имя предопределенного значения
//            Представление               - Строка                - Стандатрное строковое представление объекта
//            <имя поля>                  - Произвольный          - Дополнительные поля добавленные при выгрузке
//        __ТЧ                    - Массив                    - Массив табличных частей объекта
//        <имя поля>              - Произвольный              - Значения реквизитов объекта
//  ПолучатьБитыеСсылки  - Булево                   - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//  СписокСвойств       - Строка, Массив(Строка)    - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)    - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ДокументИзСтруктуры(Объект
	                        , СтруктураОбъекта
	                        , ПолучатьБитыеСсылки = Ложь
	                        , СписокСвойств = Неопределено
	                        , ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = Объект.Метаданные();
	
	СвойствоОбъектаИзСтруктуры(Объект,
							   СтруктураОбъекта,
							   "ПометкаУдаления",
							   ,
							   СписокСвойств,
							   ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект,
							   СтруктураОбъекта,
							   "Проведен",
							   ,
							   СписокСвойств,
							   ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект,
							   СтруктураОбъекта,
							   "Дата",
							   ,
							   СписокСвойств,
							   ИсключаяСвойства);
	
	// TODO: Тут еще нужно проверить использование нумератора
	Если МетаОбъект.ДлинаНомера > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "Номер",
								   ,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   ТекРеквизит.Имя,
								   ПолучатьБитыеСсылки,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаИзСтруктуры(Объект,
							 СтруктураОбъекта,
							 ТекТЧ.Имя,
							 ПолучатьБитыеСсылки,
							 СписокСвойств,
							 ИсключаяСвойства);
	КонецЦикла;
	
	Если ИспользоватьСвойство("Движения", СписокСвойств, ИсключаяСвойства) И СтруктураОбъекта.Свойство("Движения") Тогда
		ДвиженияДокументаИзСтруктуры(Объект,
									 СтруктураОбъекта.Движения,
									 ПолучатьБитыеСсылки,
									 СписокСвойств,
									 ИсключаяСвойства);
	КонецЕсли;
	
КонецПроцедуры // ДокументИзСтруктуры()

// Преобразует бизнес-процесс в структуру
//
// Параметры:
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Ссылка			- Структура		- Описание ссылки на объект
//			Тип 						- Строка		- Текстовое описание типа объекта
//			Ид                          - Строка		- Уникальный идентификатор ссылки
//			ИдПолный					- Строка		- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево		- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка		- Имя предопределенного значения
//			Представление				- Строка		- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный	- Дополнительные поля добавленные при выгрузке
//		__ТЧ			- Массив		- Массив табличных частей объекта
//		<имя поля>						- Произвольный	- Значения реквизитов объекта
//
Функция БизнесПроцессВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = Объект.Метаданные();
	
	Если НЕ ТипЗнч(Объект) = Тип(СтрШаблонВнутр("БизнесПроцессОбъект.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("БизнесПроцессОбъект.%1", МетаОбъект.Имя));

	Если Объект.Ссылка.Пустая() Тогда
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.ПолучитьСсылкуНового()));
	Иначе
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.Ссылка));
	КонецЕсли;
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Дата", СписокСвойств, ИсключаяСвойства);
	
	СтруктураОбъекта.Вставить("Номер", Неопределено);
	Если МетаОбъект.ДлинаНомера > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Номер", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Стартован", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Завершен", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ВедущаяЗадача", СписокСвойств, ИсключаяСвойства);
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Возврат СтруктураОбъекта;
	
КонецФункции // БизнесПроцессВСтруктуру()

// Заполняет бизнес-процесс из структуры
//
// Параметры:
//  Объект               - Объект                    - Заполняемый объект
//  СтруктураОбъекта     - Структура                      - Данные для заполнения объекта
//        Ссылка                   - Структура                - Описание ссылки на объект
//            Тип                         - Строка                - Текстовое описание типа объекта
//            Ид                          - Строка                - Уникальный идентификатор ссылки
//            ИдПолный                    - Строка                - Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//            Предопределенный            - Булево                - Истина - предопределенное значение; Ложь - в противном случае
//            ИмяПредопределенныхДанных   - Строка                - Имя предопределенного значения
//            Представление               - Строка                - Стандатрное строковое представление объекта
//            <имя поля>                  - Произвольный          - Дополнительные поля добавленные при выгрузке
//        __ТЧ                    - Массив                    - Массив табличных частей объекта
//        <имя поля>              - Произвольный              - Значения реквизитов объекта
//  ПолучатьБитыеСсылки  - Булево                   - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//  СписокСвойств       - Строка, Массив(Строка)    - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)    - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура БизнесПроцессИзСтруктуры(Объект
	                             , СтруктураОбъекта
	                             , ПолучатьБитыеСсылки = Ложь
	                             , СписокСвойств = Неопределено
	                             , ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = Объект.Метаданные();
	
	СвойствоОбъектаИзСтруктуры(Объект,
							   СтруктураОбъекта,
							   "ПометкаУдаления",
							   ,
							   СписокСвойств,
							   ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект,
							   СтруктураОбъекта,
							   "Дата",
							   ,
							   СписокСвойств,
							   ИсключаяСвойства);
	
	Если МетаОбъект.ДлинаНомера > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "Номер",
								   ,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЕсли;
	
	СвойствоОбъектаИзСтруктуры(Объект,
							   СтруктураОбъекта,
							   "Стартован",
							   ,
							   СписокСвойств,
							   ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект,
							   СтруктураОбъекта,
							   "Завершен",
							   ,
							   СписокСвойств,
							   ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект,
							   СтруктураОбъекта,
							   "ВедущаяЗадача",
							   ПолучатьБитыеСсылки,
							   СписокСвойств,
							   ИсключаяСвойства);
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   ТекРеквизит.Имя,
								   ПолучатьБитыеСсылки,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаИзСтруктуры(Объект,
							 СтруктураОбъекта,
							 ТекТЧ.Имя,
							 ПолучатьБитыеСсылки,
							 СписокСвойств,
							 ИсключаяСвойства);
	КонецЦикла;
	
КонецПроцедуры // БизнесПроцессИзСтруктуры()

// Преобразует задачу в структуру
//
// Параметры:
//  Объект				- Объект, ЛюбаяСсылка		- Преобразуемый объект
//  СписокСвойств		- Строка, Массив(Строка)	- Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	- Строка, Массив(Строка)	- Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура				- результат преобразования
//		Ссылка			- Структура		- Описание ссылки на объект
//			Тип 						- Строка		- Текстовое описание типа объекта
//			Ид                          - Строка		- Уникальный идентификатор ссылки
//			ИдПолный					- Строка		- Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//			Предопределенный			- Булево		- Истина - предопределенное значение; Ложь - в противном случае
//			ИмяПредопределенныхДанных	- Строка		- Имя предопределенного значения
//			Представление				- Строка		- Стандатрное строковое представление объекта
//			<имя поля>					- Произвольный	- Дополнительные поля добавленные при выгрузке
//		__ТЧ			- Массив		- Массив табличных частей объекта
//		<имя поля>						- Произвольный	- Значения реквизитов объекта
//
Функция ЗадачаВСтруктуру(Объект, СписокСвойств = Неопределено, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = Объект.Метаданные();
	
	Если НЕ ТипЗнч(Объект) = Тип(СтрШаблонВнутр("ЗадачаОбъект.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("ЗадачаОбъект.%1", МетаОбъект.Имя));

	Если Объект.Ссылка.Пустая() Тогда
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.ПолучитьСсылкуНового()));
	Иначе
		СтруктураОбъекта.Вставить("Ссылка", ЗначениеВСтруктуру(Объект.Ссылка));
	КонецЕсли;
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ПометкаУдаления", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Дата", СписокСвойств, ИсключаяСвойства);
	
	СтруктураОбъекта.Вставить("Номер", Неопределено);
	Если МетаОбъект.ДлинаНомера > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Номер", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("Наименование", Неопределено);
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Наименование", СписокСвойств, ИсключаяСвойства);
	КонецЕсли;
	
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "БизнесПроцесс", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "Выполнена", СписокСвойств, ИсключаяСвойства);
	СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, "ТочкаМаршрута", СписокСвойств, ИсключаяСвойства);
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаВСтруктуру(СтруктураОбъекта, Объект, ТекТЧ.Имя, СписокСвойств, ИсключаяСвойства);
	КонецЦикла;
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ЗадачаВСтруктуру()

// Заполняет задачу из структуры
//
// Параметры:
//  Объект               - Объект                    - Заполняемый объект
//  СтруктураОбъекта     - Структура                      - Данные для заполнения объекта
//        Ссылка                   - Структура                - Описание ссылки на объект
//            Тип                         - Строка                - Текстовое описание типа объекта
//            Ид                          - Строка                - Уникальный идентификатор ссылки
//            ИдПолный                    - Строка                - Преставление ссылки на объект, полученное функцией ЗначениеВСтрокуВнутр
//            Предопределенный            - Булево                - Истина - предопределенное значение; Ложь - в противном случае
//            ИмяПредопределенныхДанных   - Строка                - Имя предопределенного значения
//            Представление               - Строка                - Стандатрное строковое представление объекта
//            <имя поля>                  - Произвольный          - Дополнительные поля добавленные при выгрузке
//        __ТЧ                    - Массив                    - Массив табличных частей объекта
//        <имя поля>              - Произвольный              - Значения реквизитов объекта
//  ПолучатьБитыеСсылки  - Булево                   - Истина - если объект по ссылке не существует,
//                                                    будет возвращена битая ссылка;
//                                                    Ложь - будет возвращена пустая ссылка
//  СписокСвойств       - Строка, Массив(Строка)    - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)    - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ЗадачаИзСтруктуры(Объект
	                      , СтруктураОбъекта
	                      , ПолучатьБитыеСсылки = Ложь
	                      , СписокСвойств = Неопределено
	                      , ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = Объект.Метаданные();
	
	СвойствоОбъектаИзСтруктуры(Объект,
							   СтруктураОбъекта,
							   "ПометкаУдаления",
							   ,
							   СписокСвойств,
							   ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект,
							   СтруктураОбъекта,
							   "Дата",
							   СписокСвойств,
							   ИсключаяСвойства);
	
	Если МетаОбъект.ДлинаНомера > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "Номер",
								   ,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЕсли;
	
	Если МетаОбъект.ДлинаНаименования > 0 Тогда
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   "Наименование",
								   ,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЕсли;
	
	СвойствоОбъектаИзСтруктуры(Объект,
							   СтруктураОбъекта,
							   "БизнесПроцесс",
							   ПолучатьБитыеСсылки,
							   СписокСвойств,
							   ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект,
							   СтруктураОбъекта,
							   "Выполнена",
							   ,
							   СписокСвойств,
							   ИсключаяСвойства);
	СвойствоОбъектаИзСтруктуры(Объект,
							   СтруктураОбъекта,
							   "ТочкаМаршрута",
							   ПолучатьБитыеСсылки,
							   СписокСвойств,
							   ИсключаяСвойства);
	
	Для Каждого ТекРеквизит Из МетаОбъект.Реквизиты Цикл
		СвойствоОбъектаИзСтруктуры(Объект,
								   СтруктураОбъекта,
								   ТекРеквизит.Имя,
								   ПолучатьБитыеСсылки,
								   СписокСвойств,
								   ИсключаяСвойства);
	КонецЦикла;
	
	Для Каждого ТекТЧ Из МетаОбъект.ТабличныеЧасти Цикл
		ТЧОбъектаИзСтруктуры(Объект,
							 СтруктураОбъекта,
							 ТекТЧ.Имя,
							 ПолучатьБитыеСсылки,
							 СписокСвойств,
							 ИсключаяСвойства);
	КонецЦикла;
	
КонецПроцедуры // ЗадачаИзСтруктуры()

// Преобразует набор записей регистра сведений в структуру
//
// Параметры:
//  НаборЗаписей        - РегистрСведенийНаборЗаписей    - набор записей регистра сведений для преобразования
//  СписокСвойств       - Строка, Массив(Строка)         - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)         - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура       - результат преобразования
//		Отбор          - Структура            - Описание отбора записей регистра
//			<имя поля>     - Произвольный          - Значение отбора
//		Записи         - Массив(Структура)    - Массив записей регистра
//			<имя поля>     - Произвольный          - Значения измерений, ресурсов и реквизитов записи регистра
//
Функция НаборЗаписейРегистраСведенийВСтруктуру(НаборЗаписей
											 , СписокСвойств = Неопределено
											 , ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = НаборЗаписей.Метаданные();
	
	Если НЕ ТипЗнч(НаборЗаписей) = Тип(СтрШаблонВнутр("РегистрСведенийНаборЗаписей.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("РегистрСведенийНаборЗаписей.%1", МетаОбъект.Имя));

	СтруктураОбъекта.Вставить("Отбор", Новый Структура());
	
	Если МетаОбъект.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
		СтруктураОбъекта.Отбор.Вставить("Регистратор", ЗначениеВСтруктуру(НаборЗаписей.Отбор.Регистратор.Значение));
	Иначе
		Если НЕ МетаОбъект.ПериодичностьРегистраСведений =
				Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
			СтруктураОбъекта.Отбор.Вставить("Период", НаборЗаписей.Отбор.Период.Значение);
		КонецЕсли;
		
		Для Каждого ТекЭлемент Из НаборЗаписей.Отбор Цикл
			Если НЕ ИспользоватьСвойство(ТекЭлемент.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураОбъекта.Отбор.Вставить(ТекЭлемент.Имя, ЗначениеВСтруктуру(ТекЭлемент.Значение));
		КонецЦикла;
	КонецЕсли;
	
	МассивСтрок = Новый Массив();
	
	НомерСтроки = 1;
	
	//@skip-warning
	Для Каждого ТекСтрока Из НаборЗаписей Цикл
		
		СтруктураСтроки = Новый Структура();
		
		Если МетаОбъект.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
			СтруктураСтроки.Вставить("Регистратор", ЗначениеВСтруктуру(ТекСтрока.Регистратор));
			Если ИспользоватьСвойство("НомерСтроки", СписокСвойств, ИсключаяСвойства) Тогда
				СтруктураСтроки.Вставить("НомерСтроки",
				                         ?(ТекСтрока.НомерСтроки = 0, НомерСтроки, ТекСтрока.НомерСтроки));
			КонецЕсли;
			СтруктураСтроки.Вставить("Активность", ТекСтрока.Активность);
		КонецЕсли;
		
		Если НЕ МетаОбъект.ПериодичностьРегистраСведений =
				Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
			СтруктураСтроки.Вставить("Период", ТекСтрока.Период);
		КонецЕсли;
		
		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;
		
		МассивСтрок.Добавить(СтруктураСтроки);
		
		НомерСтроки = НомерСтроки + 1;
	КонецЦикла;

	СтруктураОбъекта.Вставить("Записи", МассивСтрок);
	
	Возврат СтруктураОбъекта;
	
КонецФункции // НаборЗаписейРегистраСведенийВСтруктуру()

// Заполняет набор записей регистра сведений из структуры
//
// Параметры:
//  НаборЗаписей         - РегистрСведенийНаборЗаписей   - Набор записей регистра для заполнения
//  СтруктураОбъекта     - Структура                     - Данные для заполнения объекта
//		Отбор                - Структура                     - Описание отбора записей регистра
//			<имя поля>           - Произвольный                  - Значение отбора
//		Записи               - Массив(Структура)             - Массив записей регистра
//			<имя поля>           - Произвольный                  - Значения измерений, ресурсов и реквизитов записи регистра
//  ПолучатьБитыеСсылки  - Булево                        - Истина - если объект по ссылке не существует,
//                                                         будет возвращена битая ссылка;
//                                                         Ложь - будет возвращена пустая ссылка
//  СписокСвойств		 - Строка, Массив(Строка)        - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	 - Строка, Массив(Строка)        - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура НаборЗаписейРегистраСведенийИзСтруктуры(НаборЗаписей
	                                            , СтруктураОбъекта
	                                            , ПолучатьБитыеСсылки = Ложь
	                                            , СписокСвойств = Неопределено
	                                            , ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = НаборЗаписей.Метаданные();
	
	Если МетаОбъект.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
		НаборЗаписей.Отбор.Регистратор.Установить(ЗначениеИзСтруктуры(СтруктураОбъекта.Отбор.Регистратор,
		                                                              ПолучатьБитыеСсылки));
	Иначе
		Если НЕ МетаОбъект.ПериодичностьРегистраСведений =
				Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
			НаборЗаписей.Отбор.Период.Установить(ЗначениеИзСтруктуры(СтруктураОбъекта.Отбор.Период,
			                                                         ПолучатьБитыеСсылки));
		КонецЕсли;
		
		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ (СтруктураОбъекта.Отбор.Свойство(ТекПоле.Имя)
			   И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НаборЗаписей.Отбор[ТекПоле.Имя].Установить(ЗначениеИзСтруктуры(СтруктураОбъекта.Отбор[ТекПоле.Имя],
			                                                               ПолучатьБитыеСсылки));
		КонецЦикла;
	КонецЕсли;
		
	НаборЗаписей.Очистить();
	
	Для Каждого ТекЗапись Из СтруктураОбъекта.Записи Цикл
		
		НоваяЗапись = НаборЗаписей.Добавить();
		
		Если МетаОбъект.РежимЗаписи = Метаданные.СвойстваОбъектов.РежимЗаписиРегистра.ПодчинениеРегистратору Тогда
			НоваяЗапись.Регистратор = ЗначениеИзСтруктуры(ТекЗапись.Регистратор, ПолучатьБитыеСсылки);
			НоваяЗапись.Активность = ЗначениеИзСтруктуры(ТекЗапись.Активность);
		КонецЕсли;
		
		Если НЕ МетаОбъект.ПериодичностьРегистраСведений =
				Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
			НоваяЗапись.Период = ЗначениеИзСтруктуры(ТекЗапись.Период);
		КонецЕсли;
		
		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя], ПолучатьБитыеСсылки);
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя], ПолучатьБитыеСсылки);
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя], ПолучатьБитыеСсылки);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры // НаборЗаписейРегистраСведенийИзСтруктуры()

// Преобразует набор записей регистра накопления в структуру
//
// Параметры:
//  НаборЗаписей        - РегистрНакопленияНаборЗаписей    - набор записей регистра накопления для преобразования
//  СписокСвойств       - Строка, Массив(Строка)           - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)           - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура       - результат преобразования
//		Отбор           - Структура            - Описание отбора записей регистра
//			<имя поля>      - Произвольный         - Значение отбора
//		Записи          - Массив(Структура)    - Массив записей регистра
//			<имя поля>      - Произвольный         - Значения измерений, ресурсов и реквизитов записи регистра
//
Функция НаборЗаписейРегистраНакопленияВСтруктуру(НаборЗаписей
											   , СписокСвойств = Неопределено
											   , ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = НаборЗаписей.Метаданные();
	
	Если НЕ ТипЗнч(НаборЗаписей) = Тип(СтрШаблонВнутр("РегистрНакопленияНаборЗаписей.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("РегистрНакопленияНаборЗаписей.%1", МетаОбъект.Имя));

	СтруктураОбъекта.Вставить("Отбор", Новый Структура());
	
	СтруктураОбъекта.Отбор.Вставить("Регистратор", ЗначениеВСтруктуру(НаборЗаписей.Отбор.Регистратор.Значение));
	
	МассивСтрок = Новый Массив();
	
	НомерСтроки = 1;

	//@skip-warning
	Для Каждого ТекСтрока Из НаборЗаписей Цикл
		
		СтруктураСтроки = Новый Структура();
		
		СтруктураСтроки.Вставить("Регистратор", ЗначениеВСтруктуру(ТекСтрока.Регистратор));
		
		Если ИспользоватьСвойство("НомерСтроки", СписокСвойств, ИсключаяСвойства) Тогда
			СтруктураСтроки.Вставить("НомерСтроки", ?(ТекСтрока.НомерСтроки = 0, НомерСтроки, ТекСтрока.НомерСтроки));
		КонецЕсли;
	
		СтруктураСтроки.Вставить("Активность", ТекСтрока.Активность);
		
		Если МетаОбъект.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
			СтруктураСтроки.Вставить("ВидДвижения",
			                         ?(ТекСтрока.ВидДвижения = ВидДвиженияНакопления.Приход, "Приход", "Расход"));
		КонецЕсли;
		
		СтруктураСтроки.Вставить("Период", ТекСтрока.Период);
		
		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;
		
		МассивСтрок.Добавить(СтруктураСтроки);
		
		НомерСтроки = НомерСтроки + 1;
	КонецЦикла;

	СтруктураОбъекта.Вставить("Записи", МассивСтрок);
	
	Возврат СтруктураОбъекта;
	
КонецФункции // НаборЗаписейРегистраНакопленияВСтруктуру()

// Заполняет набор записей регистра накопления из структуры
//
// Параметры:
//  НаборЗаписей         - РегистрСведенийНаборЗаписей   - Набор записей регистра для заполнения
//  СтруктураОбъекта     - Структура                     - Данные для заполнения объекта
//		Отбор                - Структура                     - Описание отбора записей регистра
//			<имя поля>           - Произвольный                  - Значение отбора
//		Записи               - Массив(Структура)             - Массив записей регистра
//			<имя поля>           - Произвольный                  - Значения измерений, ресурсов и реквизитов записи регистра
//  ПолучатьБитыеСсылки  - Булево                        - Истина - если объект по ссылке не существует,
//                                                         будет возвращена битая ссылка;
//                                                         Ложь - будет возвращена пустая ссылка
//  СписокСвойств		 - Строка, Массив(Строка)        - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	 - Строка, Массив(Строка)        - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура НаборЗаписейРегистраНакопленияИзСтруктуры(НаборЗаписей
	                                              , СтруктураОбъекта
	                                              , ПолучатьБитыеСсылки = Ложь
	                                              , СписокСвойств = Неопределено
	                                              , ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = НаборЗаписей.Метаданные();
	
	НаборЗаписей.Отбор.Регистратор.Установить(ЗначениеИзСтруктуры(СтруктураОбъекта.Отбор.Регистратор,
	                                                              ПолучатьБитыеСсылки));
	
	НаборЗаписей.Очистить();
	
	Для Каждого ТекЗапись Из СтруктураОбъекта.Записи Цикл
		
		НоваяЗапись = НаборЗаписей.Добавить();
		
		НоваяЗапись.Регистратор = ЗначениеИзСтруктуры(ТекЗапись.Регистратор, ПолучатьБитыеСсылки);
		
		НоваяЗапись.Активность = ЗначениеИзСтруктуры(ТекЗапись.Активность);
		
		Если МетаОбъект.ВидРегистра = Метаданные.СвойстваОбъектов.ВидРегистраНакопления.Остатки Тогда
			НоваяЗапись.ВидДвижения = Вычислить("ВидДвиженияНакопления." + ТекЗапись.ВидДвижения);
		КонецЕсли;
		
		НоваяЗапись.Период = ЗначениеИзСтруктуры(ТекЗапись.Период);
		
		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя)
			   И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя], ПолучатьБитыеСсылки);
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя)
			   И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя]);
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя)
			   И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя], ПолучатьБитыеСсылки);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры // НаборЗаписейРегистраНакопленияИзСтруктуры()

// Преобразует набор записей регистра бухгалтерии в структуру
//
// Параметры:
//  НаборЗаписей        - РегистрБухгалтерииНаборЗаписей    - набор записей регистра бухгалтерии для преобразования
//  СписокСвойств       - Строка, Массив(Строка)            - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)            - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура       - результат преобразования
//		Отбор           - Структура            - Описание отбора записей регистра
//			<имя поля>      - Произвольный         - Значение отбора
//		Записи          - Массив(Структура)    - Массив записей регистра
//			<имя поля>      - Произвольный         - Значения измерений, ресурсов и реквизитов записи регистра
//
Функция НаборЗаписейРегистраБухгалтерииВСтруктуру(НаборЗаписей
												, СписокСвойств = Неопределено
												, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = НаборЗаписей.Метаданные();
	
	Если НЕ ТипЗнч(НаборЗаписей) = Тип(СтрШаблонВнутр("РегистрБухгалтерииНаборЗаписей.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("РегистрБухгалтерииНаборЗаписей.%1", МетаОбъект.Имя));

	СтруктураОбъекта.Вставить("Отбор", Новый Структура());
	
	СтруктураОбъекта.Отбор.Вставить("Регистратор", ЗначениеВСтруктуру(НаборЗаписей.Отбор.Регистратор.Значение));
	
	МассивСтрок = Новый Массив();
	
	НомерСтроки = 1;

	//@skip-warning
	Для Каждого ТекСтрока Из НаборЗаписей Цикл
		
		СтруктураСтроки = Новый Структура();
		
		СтруктураСтроки.Вставить("Регистратор", ЗначениеВСтруктуру(ТекСтрока.Регистратор));
		
		Если ИспользоватьСвойство("НомерСтроки", СписокСвойств, ИсключаяСвойства) Тогда
			СтруктураСтроки.Вставить("НомерСтроки", ?(ТекСтрока.НомерСтроки = 0, НомерСтроки, ТекСтрока.НомерСтроки));
		КонецЕсли;
	
		СтруктураСтроки.Вставить("Активность", ТекСтрока.Активность);
		
		СтруктураСтроки.Вставить("Период", ТекСтрока.Период);
		
		Если МетаОбъект.ДлинаУточненияПериода > 0
		   И ИспользоватьСвойство("УточнениеПериода", СписокСвойств, ИсключаяСвойства) Тогда
			СтруктураСтроки.Вставить("УточнениеПериода", ТекСтрока.УточнениеПериода);
		КонецЕсли;
		
		Если МетаОбъект.Корреспонденция Тогда
			СтруктураСтроки.Вставить("СчетДт", ЗначениеВСтруктуру(ТекСтрока.СчетДт));
			СтруктураСтроки.Вставить("СчетКт", ЗначениеВСтруктуру(ТекСтрока.СчетКт));
			
			СтруктураСтроки.Вставить("СубконтоДт",
			                         ЗначенияСубконтоЗаписиВСтруктуру(ТекСтрока, "Дт", СписокСвойств, ИсключаяСвойства));
			СтруктураСтроки.Вставить("СубконтоКт",
			                         ЗначенияСубконтоЗаписиВСтруктуру(ТекСтрока, "Кт", СписокСвойств, ИсключаяСвойства));
		Иначе
			СтруктураСтроки.Вставить("ВидДвижения",
			                         ?(ТекСтрока.ВидДвижения = ВидДвиженияБухгалтерии.Дебет, "Дебет", "Кредит"));
			
			СтруктураСтроки.Вставить("Счет", ЗначениеВСтруктуру(ТекСтрока.Счет));
			
			СтруктураСтроки.Вставить("Субконто",
			                         ЗначенияСубконтоЗаписиВСтруктуру(ТекСтрока, "", СписокСвойств, ИсключаяСвойства));
		КонецЕсли;
		
		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			Если МетаОбъект.Корреспонденция И НЕ ТекПоле.Балансовый Тогда
				СтруктураСтроки.Вставить(ТекПоле.Имя + "Дт", ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя + "Дт"]));
				СтруктураСтроки.Вставить(ТекПоле.Имя + "Кт", ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя + "Кт"]));
			Иначе
				СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			Если МетаОбъект.Корреспонденция И НЕ ТекПоле.Балансовый Тогда
				СтруктураСтроки.Вставить(ТекПоле.Имя + "Дт", ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя + "Дт"]));
				СтруктураСтроки.Вставить(ТекПоле.Имя + "Кт", ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя + "Кт"]));
			Иначе
				СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;
		
		МассивСтрок.Добавить(СтруктураСтроки);
		
		НомерСтроки = НомерСтроки + 1;
	КонецЦикла;

	СтруктураОбъекта.Вставить("Записи", МассивСтрок);
	
	Возврат СтруктураОбъекта;
	
КонецФункции // НаборЗаписейРегистраБухгалтерииВСтруктуру()

// Заполняет набор записей регистра бухгалтерии из структуры
//
// Параметры:
//  НаборЗаписей         - РегистрСведенийНаборЗаписей   - Набор записей регистра для заполнения
//  СтруктураОбъекта     - Структура                     - Данные для заполнения объекта
//		Отбор                - Структура                     - Описание отбора записей регистра
//			<имя поля>           - Произвольный                  - Значение отбора
//		Записи               - Массив(Структура)             - Массив записей регистра
//			<имя поля>           - Произвольный                  - Значения измерений, ресурсов и реквизитов записи регистра
//  ПолучатьБитыеСсылки  - Булево                        - Истина - если объект по ссылке не существует,
//                                                         будет возвращена битая ссылка;
//                                                         Ложь - будет возвращена пустая ссылка
//  СписокСвойств		 - Строка, Массив(Строка)        - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	 - Строка, Массив(Строка)        - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура НаборЗаписейРегистраБухгалтерииИзСтруктуры(НаборЗаписей
	                                               , СтруктураОбъекта
	                                               , ПолучатьБитыеСсылки = Ложь
	                                               , СписокСвойств = Неопределено
	                                               , ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = НаборЗаписей.Метаданные();
	
	НаборЗаписей.Отбор.Регистратор.Установить(ЗначениеИзСтруктуры(СтруктураОбъекта.Отбор.Регистратор));
	
	НаборЗаписей.Очистить();
	
	Для Каждого ТекЗапись Из СтруктураОбъекта.Записи Цикл
		
		НоваяЗапись = НаборЗаписей.Добавить();
		
		НоваяЗапись.Регистратор = ЗначениеИзСтруктуры(ТекЗапись.Регистратор, ПолучатьБитыеСсылки);
		
		НоваяЗапись.Активность = ЗначениеИзСтруктуры(ТекЗапись.Активность);
		НоваяЗапись.Период = ЗначениеИзСтруктуры(ТекЗапись.Период);
		
		Если МетаОбъект.ДлинаУточненияПериода > 0
		   И ИспользоватьСвойство("УточнениеПериода", СписокСвойств, ИсключаяСвойства) Тогда
			НоваяЗапись.УточнениеПериода = ЗначениеИзСтруктуры(ТекЗапись.УточнениеПериода);
		КонецЕсли;
		
		Если МетаОбъект.Корреспонденция Тогда
			НоваяЗапись.СчетДт = ЗначениеИзСтруктуры(ТекЗапись.СчетДт, ПолучатьБитыеСсылки);
			НоваяЗапись.СчетКт = ЗначениеИзСтруктуры(ТекЗапись.СчетКт, ПолучатьБитыеСсылки);
			
			ЗначенияСубконтоЗаписиИзСтруктуры(НоваяЗапись,
											  ТекЗапись,
											  "Дт",
											  ПолучатьБитыеСсылки,
											  СписокСвойств,
											  ИсключаяСвойства);
			ЗначенияСубконтоЗаписиИзСтруктуры(НоваяЗапись,
											  ТекЗапись,
											  "Кт",
											  ПолучатьБитыеСсылки,
											  СписокСвойств,
											  ИсключаяСвойства);
		Иначе
			НоваяЗапись.ВидДвижения = Вычислить("ВидДвиженияБухгалтерии." + ТекЗапись.ВидДвижения);
			
			НоваяЗапись.Счет = ЗначениеИзСтруктуры(ТекЗапись.Счет, ПолучатьБитыеСсылки);
			
			ЗначенияСубконтоЗаписиИзСтруктуры(НоваяЗапись,
											  ТекЗапись,
											  "",
											  ПолучатьБитыеСсылки,
											  СписокСвойств,
											  ИсключаяСвойства);
		КонецЕсли;
		
		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если МетаОбъект.Корреспонденция И НЕ ТекПоле.Балансовый Тогда
				ЗаполнитьИзмерениеРегистраБухгалтерии(НоваяЗапись, ТекЗапись, ТекПоле, "Дт",
				                                      ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
				ЗаполнитьИзмерениеРегистраБухгалтерии(НоваяЗапись, ТекЗапись, ТекПоле, "Кт",
				                                      ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
			Иначе
				ЗаполнитьИзмерениеРегистраБухгалтерии(НоваяЗапись, ТекЗапись, ТекПоле, "",
				                                      ПолучатьБитыеСсылки, СписокСвойств, ИсключаяСвойства);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если МетаОбъект.Корреспонденция И НЕ ТекПоле.Балансовый Тогда
				ЗаполнитьРесурсРегистраБухгалтерии(НоваяЗапись, ТекЗапись, ТекПоле, "Дт",
				                                   СписокСвойств, ИсключаяСвойства);
				ЗаполнитьРесурсРегистраБухгалтерии(НоваяЗапись, ТекЗапись, ТекПоле, "Кт",
				                                   СписокСвойств, ИсключаяСвойства);
			Иначе
				ЗаполнитьРесурсРегистраБухгалтерии(НоваяЗапись, ТекЗапись, ТекПоле, "",
				                                   СписокСвойств, ИсключаяСвойства);
			КонецЕсли;
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя)
					И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя], ПолучатьБитыеСсылки);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры // НаборЗаписейРегистраБухгалтерииИзСтруктуры()

// Преобразует набор записей регистра расчета в структуру
//
// Параметры:
//  НаборЗаписей        - РегистрРасчетаНаборЗаписей    - набор записей регистра расчета для преобразования
//  СписокСвойств       - Строка, Массив(Строка)        - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства    - Строка, Массив(Строка)        - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
//   Структура       - результат преобразования
//		Отбор           - Структура            - Описание отбора записей регистра
//			<имя поля>      - Произвольный         - Значение отбора
//		Записи          - Массив(Структура)    - Массив записей регистра
//			<имя поля>      - Произвольный         - Значения измерений, ресурсов и реквизитов записи регистра
//
Функция НаборЗаписейРегистраРасчетаВСтруктуру(НаборЗаписей
                                            , СписокСвойств = Неопределено
											, ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	МетаОбъект = НаборЗаписей.Метаданные();
	
	Если НЕ ТипЗнч(НаборЗаписей) = Тип(СтрШаблонВнутр("РегистрРасчетаНаборЗаписей.%1", МетаОбъект.Имя)) Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", СтрШаблонВнутр("РегистрРасчетаНаборЗаписей.%1", МетаОбъект.Имя));

	СтруктураОбъекта.Вставить("Отбор", Новый Структура());
	
	СтруктураОбъекта.Отбор.Вставить("Регистратор", ЗначениеВСтруктуру(НаборЗаписей.Отбор.Регистратор.Значение));
	
	Для Каждого ТекЭлемент Из НаборЗаписей.Отбор Цикл
		Если НЕ ИспользоватьСвойство(ТекЭлемент.Имя, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		СтруктураОбъекта.Отбор.Вставить(ТекЭлемент.Имя, ЗначениеВСтруктуру(ТекЭлемент.Значение));
	КонецЦикла;
	
	МассивСтрок = Новый Массив();
	
	НомерСтроки = 1;

	//@skip-warning
	Для Каждого ТекСтрока Из НаборЗаписей Цикл
		
		СтруктураСтроки = Новый Структура();
		
		СтруктураСтроки.Вставить("Регистратор", ЗначениеВСтруктуру(ТекСтрока.Регистратор));
		
		Если ИспользоватьСвойство("НомерСтроки", СписокСвойств, ИсключаяСвойства) Тогда
			СтруктураСтроки.Вставить("НомерСтроки", ?(ТекСтрока.НомерСтроки = 0, НомерСтроки, ТекСтрока.НомерСтроки));
		КонецЕсли;
	
		СтруктураСтроки.Вставить("Активность"		, ТекСтрока.Активность);
		
		СтруктураСтроки.Вставить("ВидРасчета"		, ЗначениеВСтруктуру(ТекСтрока.ВидРасчета));
		
		СтруктураСтроки.Вставить("Сторно"			, ТекСтрока.Сторно);
		
		СтруктураСтроки.Вставить("ПериодРегистрации", ТекСтрока.ПериодРегистрации);
		
		Если МетаОбъект.БазовыйПериод Тогда
			СтруктураСтроки.Вставить("БазовыйПериодНачало"	, ТекСтрока.БазовыйПериодНачало);
			СтруктураСтроки.Вставить("БазовыйПериодКонец"	, ТекСтрока.БазовыйПериодКонец);
		КонецЕсли;
		
		Если МетаОбъект.ПериодДействия Тогда
			СтруктураСтроки.Вставить("ПериодДействия"		, ТекСтрока.ПериодДействия);
			СтруктураСтроки.Вставить("ПериодДействияНачало"	, ТекСтрока.ПериодДействияНачало);
			СтруктураСтроки.Вставить("ПериодДействияКонец"	, ТекСтрока.ПериодДействияКонец);
			
			МассивПериодов = Новый Массив();
			
			Для Каждого ТекПериод Из ТекСтрока.ФактическийПериодДействия Цикл
				МассивПериодов.Добавить(Новый Структура("ДатаНачала, ДатаОкончания",
				                                        ТекПериод.ДатаНачала, ТекПериод.ДатаОкончания));
			КонецЦикла;
			СтруктураСтроки.Вставить("ФактическийПериодДействия", МассивПериодов);
		КонецЕсли;
		
		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства) Тогда
				Продолжить;
			КонецЕсли;
			СтруктураСтроки.Вставить(ТекПоле.Имя, ЗначениеВСтруктуру(ТекСтрока[ТекПоле.Имя]));
		КонецЦикла;
		
		МассивСтрок.Добавить(СтруктураСтроки);
		
		НомерСтроки = НомерСтроки + 1;
	КонецЦикла;

	СтруктураОбъекта.Вставить("Записи", МассивСтрок);
	
	Возврат СтруктураОбъекта;
	
КонецФункции // НаборЗаписейРегистраРасчетаВСтруктуру()

// Заполняет набор записей регистра расчета из структуры
//
// Параметры:
//  НаборЗаписей         - РегистрСведенийНаборЗаписей   - Набор записей регистра для заполнения
//  СтруктураОбъекта     - Структура                     - Данные для заполнения объекта
//		Отбор                - Структура                     - Описание отбора записей регистра
//			<имя поля>           - Произвольный                  - Значение отбора
//		Записи               - Массив(Структура)             - Массив записей регистра
//			<имя поля>           - Произвольный                  - Значения измерений, ресурсов и реквизитов записи регистра
//  ПолучатьБитыеСсылки  - Булево                        - Истина - если объект по ссылке не существует,
//                                                         будет возвращена битая ссылка;
//                                                         Ложь - будет возвращена пустая ссылка
//  СписокСвойств		 - Строка, Массив(Строка)        - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	 - Строка, Массив(Строка)        - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура НаборЗаписейРегистраРасчетаИзСтруктуры(НаборЗаписей
	                                           , СтруктураОбъекта
	                                           , ПолучатьБитыеСсылки = Ложь
	                                           , СписокСвойств = Неопределено
	                                           , ИсключаяСвойства = Неопределено) Экспорт
	
	МетаОбъект = НаборЗаписей.Метаданные();
	
	НаборЗаписей.Отбор.Регистратор.Установить(ЗначениеИзСтруктуры(СтруктураОбъекта.Отбор.Регистратор));
	
	Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
		Если НЕ (СтруктураОбъекта.Отбор.Свойство(ТекПоле.Имя)
			     И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
			Продолжить;
		КонецЕсли;
		НаборЗаписей.Отбор[ТекПоле.Имя].Установить(ЗначениеИзСтруктуры(СтруктураОбъекта.Отбор[ТекПоле.Имя],
		                                                               ПолучатьБитыеСсылки));
	КонецЦикла;
	
	НаборЗаписей.Очистить();
	
	Для Каждого ТекЗапись Из СтруктураОбъекта.Записи Цикл
		
		НоваяЗапись = НаборЗаписей.Добавить();
		
		НоваяЗапись.Регистратор = ЗначениеИзСтруктуры(ТекЗапись.Регистратор, ПолучатьБитыеСсылки);
		
		НоваяЗапись.Активность 			= ЗначениеИзСтруктуры(ТекЗапись.Активность);
		
		НоваяЗапись.ВидРасчета			= ЗначениеИзСтруктуры(ТекЗапись.ВидРасчета, ПолучатьБитыеСсылки);
		
		НоваяЗапись.Сторно				= ЗначениеИзСтруктуры(ТекЗапись.Сторно);
		
		НоваяЗапись.ПериодРегистрации	= ЗначениеИзСтруктуры(ТекЗапись.ПериодРегистрации);
		
		Если МетаОбъект.БазовыйПериод Тогда
			НоваяЗапись.БазовыйПериодНачало	= ЗначениеИзСтруктуры(ТекЗапись.БазовыйПериодНачало);
			НоваяЗапись.БазовыйПериодКонец	= ЗначениеИзСтруктуры(ТекЗапись.БазовыйПериодКонец);
		КонецЕсли;
		
		Если МетаОбъект.ПериодДействия Тогда
			НоваяЗапись.ПериодДействияНачало	= ЗначениеИзСтруктуры(ТекЗапись.ПериодДействияНачало);
			НоваяЗапись.ПериодДействияКонец		= ЗначениеИзСтруктуры(ТекЗапись.ПериодДействияКонец);
		КонецЕсли;
		
		Для Каждого ТекПоле Из МетаОбъект.Измерения Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя], ПолучатьБитыеСсылки);
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Ресурсы Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя]);
		КонецЦикла;
		
		Для Каждого ТекПоле Из МетаОбъект.Реквизиты Цикл
			Если НЕ (ТекЗапись.Свойство(ТекПоле.Имя) И ИспользоватьСвойство(ТекПоле.Имя, СписокСвойств, ИсключаяСвойства)) Тогда
				Продолжить;
			КонецЕсли;
			НоваяЗапись[ТекПоле.Имя] = ЗначениеИзСтруктуры(ТекЗапись[ТекПоле.Имя], ПолучатьБитыеСсылки);
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры // НаборЗаписейРегистраРасчетаИзСтруктуры()

#КонецОбласти // ПреобразованияОбъектовПоВидам

#Область ПреобразованияДанныхФормИнтерфейсныеПроцедуры

// Функция - заполняет и возвращает структуру описания данных формы
// 
// Параметры:
// 	Форма             - УправляемаяФорма        - форма для обработки
//  ТолькоСохраняемые - Булево                  - Истина - сохраняются только значения реквизитов
//                                                с признаком "Сохраняемые данные"
//                                                Ложь - сохраняются значения всех реквизитов
//  СписокСвойств     - Строка, Массив(Строка)  - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства  - Строка, Массив(Строка)  - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
// Возвращаемое значение:
// 	Структура     - структура описания формы
//		*__Тип               - Строка                   - тип данных (ДанныеФормы)
//      *<имя реквизита>     - Структура                - описание и значение реквизита формы
//
Функция ДанныеФормыВСтруктуру(Форма
	                        , ТолькоСохраняемые = Ложь
	                        , СписокСвойств = Неопределено
	                        , ИсключаяСвойства = Неопределено) Экспорт
	
	СтруктураДанных = Новый Структура();

	Если НЕ ТипЗнч(Форма) = Тип("ФормаКлиентскогоПриложения") Тогда
		СтруктураДанных.Вставить("__Тип", "Неопределено");
		Возврат СтруктураДанных;
	КонецЕсли;

	СтруктураДанных.Вставить("__Тип"    , СтрШаблонВнутр("ДанныеФормы.%1", Форма.ИмяФормы));
	
	РеквизитыФормы = Форма.ПолучитьРеквизиты();
	
	Для Каждого ТекРеквизит Из РеквизитыФормы Цикл
		
		Если ТолькоСохраняемые И НЕ ТекРеквизит.СохраняемыеДанные Тогда
			Продолжить;
		КонецЕсли;
		
		Если НЕ ИспользоватьСвойство(ТекРеквизит.Имя, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		
		ОписаниеРеквизита = Новый Структура();
		ОписаниеРеквизита.Вставить("ТипЗначения"      , ЗначениеВСтруктуру(ТекРеквизит.ТипЗначения));
		ОписаниеРеквизита.Вставить("Путь"             , ТекРеквизит.Путь);
		ОписаниеРеквизита.Вставить("Заголовок"        , ТекРеквизит.Заголовок);
		ОписаниеРеквизита.Вставить("СохраняемыеДанные", ТекРеквизит.СохраняемыеДанные);

		ЗначениеДляСохранения = Неопределено;
		
		ТипРеквизита = ТипЗнч(Форма[ТекРеквизит.Имя]);
		
		Если ТипРеквизита = Тип("ДанныеФормыСтруктура")
		 ИЛИ ТипРеквизита = Тип("ДанныеФормыСтруктураСКоллекцией")
		 ИЛИ ТипРеквизита = Тип("ДанныеФормыКоллекция")
		 ИЛИ ТипРеквизита = Тип("ДанныеФормыДерево") Тогда
			ЗначениеДляСохранения = Форма.РеквизитФормыВЗначение(ТекРеквизит.Имя);
		Иначе
			ЗначениеДляСохранения = Форма[ТекРеквизит.Имя];
		КонецЕсли;
		
		ОписаниеРеквизита.Вставить("Значение", ЗначениеВСтруктуру(ЗначениеДляСохранения));
		
		СтруктураДанных.Вставить(ТекРеквизит.Имя, ОписаниеРеквизита);
	КонецЦикла;
	
	Возврат СтруктураДанных;
	
КонецФункции // ДанныеФормыВСтруктуру()

// Заполняет значения данных формы из структуры
//
// Параметры:
//  Форма               - УправляемаяФорма         - форма для заполнения данных
//  СтруктураДанных     - Структура                - данные для заполнения формы
//		*__Тип               - Строка                   - тип данных (ДанныеФормы)
//      *<имя реквизита>     - Структура                - описание и значение реквизита формы
//  ПроверятьИмяФормы   - Булево                   - Истина - если имя формы не соответствует сохраненным данным,
//                                                   то будет выдано исключение;
//                                                   Ложь - имя формы не проверяется
//  СоздаватьРеквизиты  - Булево                   - Истина - если реквизит отсутствует в форме,
//                                                   то будет создан новый;
//                                                   Ложь - новые реквизиты не создаются
//  СписокСвойств		 - Строка, Массив(Строка)  - Список допустимых свойств (если пустой, то допустимы все свойства)
//  ИсключаяСвойства	 - Строка, Массив(Строка)  - Список исключаемых свойств (если пустой, то допустимы все свойства)
//
Процедура ДанныеФормыИзСтруктуры(Форма
	                           , СтруктураДанных
	                           , ПроверятьИмяФормы = Ложь
	                           , СоздаватьРеквизиты = Ложь
	                           , СписокСвойств = Неопределено
	                           , ИсключаяСвойства = Неопределено) Экспорт
	
	Если НЕ ТипЗнч(Форма) = Тип("ФормаКлиентскогоПриложения") Тогда
		ТекстОшибки = СтрШаблонВнутр("Попытка заполнения объекта типа ""%1"" данными для объекта типа ""%2""!",
		                             ТипЗнч(Форма),
		                             Тип("ФормаКлиентскогоПриложения"));
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;

	Если НЕ СтруктураДанных.Свойство("__Тип") Тогда
		ТекстОшибки = "В структуре данных для заполнения служебное поле ""__Тип"", поля структуры:";
		ДополнитьТекстПолямиСтруктуры(ТекстОшибки, СтруктураДанных);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Если НЕ ВРег(Лев(СтруктураДанных.__Тип, СтрДлина("ДанныеФормы"))) = ВРег("ДанныеФормы") Тогда
		ТекстОшибки = СтрШаблонВнутр("Тип данных ""%1"" структуры данных не является данными формы", СтруктураДанных.__Тип);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Если ПроверятьИмяФормы И ВРег(СтруктураДанных.__Тип) = ВРег(СтрШаблонВнутр("ДанныеФормы.%1", Форма.ИмяФормы)) Тогда
		ТекстОшибки = СтрШаблонВнутр("Тип данных ""%1"" структуры данных не является данными формы ""%2""!",
                                     СтруктураДанных.__Тип,
                                     Форма.ИмяФормы);
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	РеквизитыФормы = Форма.ПолучитьРеквизиты();
	
	ИменаРеквизитовФормы = Новый Соответствие();
	
	Для Каждого ТекРеквизит Из РеквизитыФормы Цикл
		ИменаРеквизитовФормы.Вставить(ТекРеквизит.Имя, ТекРеквизит);
	КонецЦикла;
	
	СоздаваемыеРеквизиты = Новый Массив();
	
	Для Каждого ТекРеквизит Из СтруктураДанных Цикл
		Если ВРег(ТекРеквизит.Ключ) = ВРег("__Тип") Тогда
			Продолжить;
		КонецЕсли;

		Если НЕ ИспользоватьСвойство(ТекРеквизит.Ключ, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		
		Если СоздаватьРеквизиты И ИменаРеквизитовФормы.Получить(ТекРеквизит.Ключ) = Неопределено Тогда
			СоздаваемыеРеквизиты.Добавить(Новый РеквизитФормы(ТекРеквизит.Ключ,
			                                                  ЗначениеИзСтруктуры(ТекРеквизит.Значение.ТипЗначения),
			                                                  ТекРеквизит.Значение.Путь,
			                                                  ТекРеквизит.Значение.Заголовок,
			                                                  ТекРеквизит.Значение.СохраняемыеДанные));               
		КонецЕсли;
	КонецЦикла;
	
	Если СоздаваемыеРеквизиты.Количество() > 0 Тогда
		Форма.ИзменитьРеквизиты(СоздаваемыеРеквизиты);
	КонецЕсли;
	
	Для Каждого ТекРеквизит Из СтруктураДанных Цикл
		Если ВРег(ТекРеквизит.Ключ) = ВРег("__Тип") Тогда
			Продолжить;
		КонецЕсли;

		Если НЕ ИспользоватьСвойство(ТекРеквизит.Ключ, СписокСвойств, ИсключаяСвойства) Тогда
			Продолжить;
		КонецЕсли;
		
		РеквизитФормы = ИменаРеквизитовФормы.Получить(ТекРеквизит.Ключ);
		
		Если РеквизитФормы = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ТипРеквизита = ТипЗнч(Форма[ТекРеквизит.Ключ]);
		
		Если ТипРеквизита = Тип("ДанныеФормыСтруктура")
		 ИЛИ ТипРеквизита = Тип("ДанныеФормыСтруктураСКоллекцией")
		 ИЛИ ТипРеквизита = Тип("ДанныеФормыКоллекция")
		 ИЛИ ТипРеквизита = Тип("ДанныеФормыДерево") Тогда
			Если ЭтоОбъект(ТекРеквизит.Значение.Значение) Тогда
				ЗначениеДляЗаполнения = Форма.РеквизитФормыВЗначение(ТекРеквизит.Ключ);
				ЗаполнитьОбъектИзСтруктуры(ЗначениеДляЗаполнения, ТекРеквизит.Значение.Значение, Истина);
			ИначеЕсли ЭтоНаборЗаписейРегистра(ТекРеквизит.Значение.Значение) Тогда
				ЗначениеДляЗаполнения = Форма.РеквизитФормыВЗначение(ТекРеквизит.Ключ);
				ЗаполнитьНаборЗаписейРегистраИзСтруктуры(ЗначениеДляЗаполнения, ТекРеквизит.Значение.Значение, Истина);
			Иначе
				ЗначениеДляЗаполнения = ЗначениеИзСтруктуры(ТекРеквизит.Значение.Значение);
			КонецЕсли;
			Форма.ЗначениеВРеквизитФормы(ЗначениеДляЗаполнения, ТекРеквизит.Ключ);
		Иначе
			Форма[ТекРеквизит.Ключ] = ЗначениеИзСтруктуры(ТекРеквизит.Значение.Значение);
		КонецЕсли;
		
	КонецЦикла;
	 
КонецПроцедуры // ДанныеФормыИзСтруктуры()

#КонецОбласти // ПреобразованияДанныхФормИнтерфейсныеПроцедуры

#Область ПреобразованияСКДИнтерфейсныеПроцедуры

// Функция - заполняет и возвращает структуру описания объекта СКД
// НастройкиКомпоновкиДанных
// 
// Параметры:
// 	Объект        - НастройкиКомпоновкиДанных - объект СКД для обработки
//
// Возвращаемое значение:
// 	Структура     - структура описания объекта
//
Функция НастройкиСКДВСтруктуру(Объект) Экспорт
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("НастройкиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "НастройкиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Выбор"                 , ЗначениеСКДВСтруктуру(Объект.Выбор));
	СтруктураОбъекта.Вставить("ДополнительныеСвойства", ЗначениеВСтруктуру(Объект.ДополнительныеСвойства));
	СтруктураОбъекта.Вставить("Отбор"                 , ЗначениеСКДВСтруктуру(Объект.Отбор));
	СтруктураОбъекта.Вставить("ПараметрыВывода"       , ЗначениеСКДВСтруктуру(Объект.ПараметрыВывода));
	СтруктураОбъекта.Вставить("ПараметрыДанных"       , ЗначениеСКДВСтруктуру(Объект.ПараметрыДанных));
	СтруктураОбъекта.Вставить("ПользовательскиеПоля"  , ЗначениеСКДВСтруктуру(Объект.ПользовательскиеПоля));
	СтруктураОбъекта.Вставить("Порядок"               , ЗначениеСКДВСтруктуру(Объект.Порядок));
	СтруктураОбъекта.Вставить("Родитель"              , Неопределено); // TODO: Разбраться с родителем
	СтруктураОбъекта.Вставить("Структура"             , КоллекцияСКДВМассив(Объект.Структура));
	СтруктураОбъекта.Вставить("УсловноеОформление"    , ЗначениеСКДВСтруктуру(Объект.УсловноеОформление));
	
	Возврат СтруктураОбъекта;
	
КонецФункции // НастройкиСКДВСтруктуру()

// Процедура - заполняет объект СКД НастройкиКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - НастройкиКомпоновкиДанных     - заполняемый объект
// 	СтруктураОбъекта   - Структура                     - данные для заполнения объекта
//
Процедура НастройкиСКДИзСтруктуры(Объект, СтруктураОбъекта) Экспорт
	
	Если НЕ ТипЗнч(Объект) = Тип("НастройкиКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Выбор", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Отбор", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПараметрыВывода", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПараметрыДанных", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПользовательскиеПоля", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Порядок", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "УсловноеОформление", Истина);

	Если СтруктураОбъекта.Свойство("ДополнительныеСвойства") Тогда
		Для Каждого ТекЭлемент Из СтруктураОбъекта.ДополнительныеСвойства Цикл
			Объект.ДополнительныеСвойства.Вставить(ТекЭлемент.Ключ, ЗначениеИзСтруктуры(ТекЭлемент.Значение));
		КонецЦикла;
	КонецЕсли;

	// TODO: Разобраться с родителем
	
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Структура", Истина);

КонецПроцедуры // НастройкиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// СхемаКомпоновкиДанных
// 
// Параметры:
// 	Объект        - СхемаКомпоновкиДанных   - объект СКД для обработки
//
// Возвращаемое значение:
// 	Структура     - структура описания объекта
//
Функция СКДВСтруктуру(Объект) Экспорт
	
	СтруктураОбъекта = Новый Структура();

	Если НЕ ТипЗнч(Объект) = Тип("СхемаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "СхемаКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("ИсточникиДанных"     , КоллекцияСКДВМассив(Объект.ИсточникиДанных));
	СтруктураОбъекта.Вставить("НаборыДанных"        , КоллекцияСКДВМассив(Объект.НаборыДанных));
	СтруктураОбъекта.Вставить("СвязиНаборовДанных"  , КоллекцияСКДВМассив(Объект.СвязиНаборовДанных));
	СтруктураОбъекта.Вставить("ВычисляемыеПоля"     , КоллекцияСКДВМассив(Объект.ВычисляемыеПоля));
	СтруктураОбъекта.Вставить("Параметры"           , КоллекцияСКДВМассив(Объект.Параметры));
	СтруктураОбъекта.Вставить("ПоляИтога"           , КоллекцияСКДВМассив(Объект.ПоляИтога));
	СтруктураОбъекта.Вставить("ВариантыНастроек"    , КоллекцияСКДВМассив(Объект.ВариантыНастроек));
	СтруктураОбъекта.Вставить("НастройкиПоУмолчанию", СтруктураОбъекта.ВариантыНастроек[0].Имя);
	СтруктураОбъекта.Вставить("Макеты"              , КоллекцияСКДВМассив(Объект.Макеты));
	СтруктураОбъекта.Вставить("МакетыГруппировок"   , КоллекцияСКДВМассив(Объект.МакетыГруппировок));
	СтруктураОбъекта.Вставить("МакетыЗаголовковГруппировок",
	                          КоллекцияСКДВМассив(Объект.МакетыЗаголовковГруппировок));
	СтруктураОбъекта.Вставить("МакетыПолей"         , КоллекцияСКДВМассив(Объект.МакетыПолей));
	СтруктураОбъекта.Вставить("МакетыПолейИтога"    , КоллекцияСКДВМассив(Объект.МакетыПолейИтога));
	СтруктураОбъекта.Вставить("ВложенныеСхемыКомпоновкиДанных",
	                          КоллекцияСКДВМассив(Объект.ВложенныеСхемыКомпоновкиДанных));
	
	Возврат СтруктураОбъекта;
	
КонецФункции // СКДВСтруктуру()

// Процедура - заполняет объект СКД СхемаКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - СхемаКомпоновкиДанных     - заполняемый объект
// 	СтруктураОбъекта   - Структура                 - данные для заполнения объекта
//
Процедура СКДИзСтруктуры(Объект, СтруктураОбъекта) Экспорт
	
	Если НЕ ТипЗнч(Объект) = Тип("СхемаКомпоновкиДанных") Тогда
		Объект = Новый СхемаКомпоновкиДанных();
	КонецЕсли;
	
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "ИсточникиДанных");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "НаборыДанных", Истина);
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "СвязиНаборовДанных");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "ВычисляемыеПоля");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Параметры");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "ПоляИтога");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Макеты");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "МакетыГруппировок");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "МакетыЗаголовковГруппировок");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "МакетыПолей");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "МакетыПолейИтога");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "ВложенныеСхемыКомпоновкиДанных");
	
	Если СтруктураОбъекта.Свойство("ВариантыНастроек") Тогда
		ЕстьНастройкиПоУмолчанию = Ложь;
		Если СтруктураОбъекта.Свойство("НастройкиПоУмолчанию") И Объект.ВариантыНастроек.Количество() > 0 Тогда
			Для Каждого ТекЭлемент Из СтруктураОбъекта.ВариантыНастроек Цикл
				Если ТекЭлемент.Имя = СтруктураОбъекта.НастройкиПоУмолчанию Тогда
					ЕстьНастройкиПоУмолчанию = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если ЕстьНастройкиПоУмолчанию Тогда
				ЗначениеСКДИзСтруктуры(Объект.ВариантыНастроек[0], ТекЭлемент);
			Иначе
				Объект.ВариантыНастроек.Очистить();
			КонецЕсли;
		Иначе
			Объект.ВариантыНастроек.Очистить();
		КонецЕсли;
		Для Каждого ТекЭлемент Из СтруктураОбъекта.ВариантыНастроек Цикл
			Если ЕстьНастройкиПоУмолчанию И ТекЭлемент.Имя = СтруктураОбъекта.НастройкиПоУмолчанию Тогда
				Продолжить;
			КонецЕсли;
			НовыйЭлемент = Объект.ВариантыНастроек.Добавить();
			ЗначениеСКДИзСтруктуры(НовыйЭлемент, ТекЭлемент);
		КонецЦикла;
	КонецЕсли;
	
КонецПроцедуры // СКДИзСтруктуры()

#КонецОбласти // ПреобразованияСКДИнтерфейсныеПроцедуры

#Область ПреобразованияСКДПроцедурыПреобразованияОбъектов

// Функция - заполняет и возвращает структуру описания объекта СКД
// ВариантНастроекКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ВариантНастроекКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ВариантНастроекСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ВариантНастроекКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ВариантНастроекКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Имя"          , Объект.Имя);
	СтруктураОбъекта.Вставить("Настройки"    , ЗначениеСКДВСтруктуру(Объект.Настройки));
	СтруктураОбъекта.Вставить("Представление", Объект.Представление);

	Возврат СтруктураОбъекта;
	
КонецФункции // ВариантНастроекСКДВСтруктуру()

// Процедура - заполняет объект СКД ВариантНастроекКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ВариантНастроекКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                       - данные для заполнения объекта
//
Процедура ВариантНастроекСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ВариантНастроекКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Настройки", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Представление");
	
КонецПроцедуры // ВариантНастроекСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ВложеннаяСхемаКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ВложеннаяСхемаКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ВложеннаяСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ВложеннаяСхемаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ВложеннаяСхемаКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Заголовок", Объект.Заголовок);
	СтруктураОбъекта.Вставить("Имя"      , Объект.Имя);
	СтруктураОбъекта.Вставить("Настройки", ЗначениеСКДВСтруктуру(Объект.Настройки));
	СтруктураОбъекта.Вставить("Схема"    , ЗначениеСКДВСтруктуру(Объект.Схема));

	Возврат СтруктураОбъекта;
	
КонецФункции // ВложеннаяСКДВСтруктуру()

// Процедура - заполняет объект СКД ВложеннаяСхемаКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ВложеннаяСхемаКомпоновкиДанных  - заполняемый объект
// 	СтруктураОбъекта   - Структура                       - данные для заполнения объекта
//
Процедура ВложеннаяСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ВложеннаяСхемаКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Заголовок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Настройки", Истина);

	Если НЕ ТипЗнч(Объект.Схема) = Тип("СхемаКомпоновкиДанных") Тогда
		// @skip-error - в СП написано, что поле имеет свойство "Только чтение",
		// но при добавлении вложенной схемы поле содержит неопределено и присваивание допускается
		Объект.Схема = Новый СхемаКомпоновкиДанных();
	КонецЕсли;
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Схема", Истина);
	
КонецПроцедуры // ВложеннаяСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ВычисляемоеПолеСхемыКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ВычисляемоеПолеСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ВычисляемоеПолеСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ВычисляемоеПолеСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ВычисляемоеПолеСхемыКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Выражение"               , Объект.Выражение);
	СтруктураОбъекта.Вставить("ВыражениеПредставления"  , Объект.ВыражениеПредставления);
	СтруктураОбъекта.Вставить("ВыраженияУпорядочивания" , КоллекцияСКДВМассив(Объект.ВыраженияУпорядочивания));
	СтруктураОбъекта.Вставить("Заголовок"               , Объект.Заголовок);
	СтруктураОбъекта.Вставить("ОграничениеИспользования", ЗначениеСКДВСтруктуру(Объект.ОграничениеИспользования));
	СтруктураОбъекта.Вставить("Оформление"              , ЗначениеСКДВСтруктуру(Объект.Оформление));
	СтруктураОбъекта.Вставить("ПараметрыРедактирования" , ЗначениеСКДВСтруктуру(Объект.ПараметрыРедактирования));
	СтруктураОбъекта.Вставить("ПутьКДанным"             , Объект.ПутьКДанным);
	СтруктураОбъекта.Вставить("ТипЗначения"             , ЗначениеВСтруктуру(Объект.ТипЗначения));

	Возврат СтруктураОбъекта;
	
КонецФункции // ВычисляемоеПолеСКДВСтруктуру()

// Процедура - заполняет объект СКД ВычисляемоеПолеСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ВычисляемоеПолеСхемыКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                            - данные для заполнения объекта
//
Процедура ВычисляемоеПолеСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ВычисляемоеПолеСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Выражение");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ВыражениеПредставления");

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "ВыраженияУпорядочивания");

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Заголовок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ОграничениеИспользования", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Оформление", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПараметрыРедактирования", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПутьКДанным");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ОграничениеИспользования", Истина);

	Если СтруктураОбъекта.Свойство("ТипЗначения") Тогда
		Объект.ТипЗначения = ЗначениеИзСтруктуры(СтруктураОбъекта.ТипЗначения);
	КонецЕсли;

КонецПроцедуры // ВычисляемоеПолеСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ИсточникДанныхСхемыКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ИсточникДанныхСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ИсточникДанныхСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ИсточникДанныхСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ИсточникДанныхСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Имя"               , Объект.Имя);
	СтруктураОбъекта.Вставить("СтрокаСоединения"  , Объект.СтрокаСоединения);
	СтруктураОбъекта.Вставить("ТипИсточникаДанных", Объект.ТипИсточникаДанных);

	Возврат СтруктураОбъекта;
	
КонецФункции // ИсточникДанныхСКДВСтруктуру()

// Процедура - заполняет объект СКД ИсточникДанныхСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ИсточникДанныхСхемыКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                           - данные для заполнения объекта
//
Процедура ИсточникДанныхСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ИсточникДанныхСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "СтрокаСоединения");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ТипИсточникаДанных");
	
КонецПроцедуры // ИсточникДанныхСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ОписаниеМакетаСхемыКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ОписаниеМакетаСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ОписаниеМакетаСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ОписаниеМакетаСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ОписаниеМакетаСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Имя"    , Объект.Имя);

	Если ТипЗнч(Объект.Макет) = Тип("МакетОбластиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("Макет" , КоллекцияСКДВМассив(Объект.Макет));
	КонецЕсли;
	
	СтруктураОбъекта.Вставить("Параметры" , КоллекцияСКДВМассив(Объект.Параметры));

	Возврат СтруктураОбъекта;
	
КонецФункции // ОписаниеМакетаСКДВСтруктуру()

// Процедура - заполняет объект СКД ОписаниеМакетаСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ОписаниеМакетаСхемыКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                           - данные для заполнения объекта
//
Процедура ОписаниеМакетаСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ОписаниеМакетаСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");

	Если СтруктураОбъекта.Свойство("Макет") Тогда
		Для Каждого ТекЭлемент Из СтруктураОбъекта.Макет Цикл
			Если НЕ ТипЗнч(Объект.Макет) = Тип("МакетОбластиКомпоновкиДанных") Тогда
				Объект.Макет = Новый МакетОбластиКомпоновкиДанных();
			КонецЕсли;
			НовыйЭлемент = Объект.Макет.Добавить(Тип(ТекЭлемент.__Тип));
			ЗначениеСКДИзСтруктуры(НовыйЭлемент, ТекЭлемент);
		КонецЦикла;
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Параметры", Истина);

КонецПроцедуры // ОписаниеМакетаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// МакетГруппировкиСхемыКомпоновкиДанных
// 
// Параметры:
// 	Объект             - МакетГруппировкиСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция МакетГруппировкиСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("МакетГруппировкиСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "МакетГруппировкиСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ИмяГруппировки" , Объект.ИмяГруппировки);
	СтруктураОбъекта.Вставить("Макет"          , Объект.Макет);
	СтруктураОбъекта.Вставить("ПоляГруппировки", КоллекцияСКДВМассив(Объект.ПоляГруппировки));
	СтруктураОбъекта.Вставить("ТипМакета"      , ПеречислениеСКДВСтроку(Объект.ТипМакета));
	
	Возврат СтруктураОбъекта;
	
КонецФункции // МакетГруппировкиСКДВСтруктуру()

// Процедура - заполняет объект СКД МакетГруппировкиСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - МакетГруппировкиСхемыКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                             - данные для заполнения объекта
//
Процедура МакетГруппировкиСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("МакетГруппировкиСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИмяГруппировки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Макет");

	Если СтруктураОбъекта.Свойство("ПоляГруппировки") Тогда
		Для Каждого ТекЭлемент Из СтруктураОбъекта.ПоляГруппировки Цикл
			Объект.ПоляГруппировки.Добавить(Новый ПолеКомпоновкиДанных(ТекЭлемент.Имя));
		КонецЦикла;
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ТипМакета") Тогда
		Объект.ТипМакета = ТипМакетаОбластиКомпоновкиДанных[СтруктураОбъекта.ТипМакета];
	КонецЕсли;

КонецПроцедуры // МакетГруппировкиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// МакетПоляСхемыКомпоновкиДанных
// 
// Параметры:
// 	Объект             - МакетПоляСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция МакетПоляСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("МакетПоляСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "МакетПоляСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Макет", Объект.Макет);
	СтруктураОбъекта.Вставить("Поле" , Объект.Поле);

	Возврат СтруктураОбъекта;
	
КонецФункции // МакетПоляСКДВСтруктуру()

// Процедура - заполняет объект СКД МакетПоляСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - МакетПоляСхемыКомпоновкиДанных  - заполняемый объект
// 	СтруктураОбъекта   - Структура                       - данные для заполнения объекта
//
Процедура МакетПоляСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("МакетПоляСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Макет");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Поле");

КонецПроцедуры // МакетПоляСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// МакетПолейИтогаСхемыКомпоновкиДанных
// 
// Параметры:
// 	Объект             - МакетПолейИтогаСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция МакетПолейИтогаСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("МакетПолейИтогаСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "МакетПолейИтогаСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ИмяГруппировки1" , Объект.ИмяГруппировки1);
	СтруктураОбъекта.Вставить("ИмяГруппировки2" , Объект.ИмяГруппировки2);
	СтруктураОбъекта.Вставить("Макет"           , Объект.Макет);
	СтруктураОбъекта.Вставить("ПоляГруппировки1", КоллекцияСКДВМассив(Объект.ПоляГруппировки1));
	СтруктураОбъекта.Вставить("ПоляГруппировки2", КоллекцияСКДВМассив(Объект.ПоляГруппировки2));
	СтруктураОбъекта.Вставить("ТипМакета1"      , ПеречислениеСКДВСтроку(Объект.ТипМакета1));
	СтруктураОбъекта.Вставить("ТипМакета2"      , ПеречислениеСКДВСтроку(Объект.ТипМакета2));

	Возврат СтруктураОбъекта;
	
КонецФункции // МакетПолейИтогаСКДВСтруктуру()

// Процедура - заполняет объект СКД МакетПолейИтогаСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - МакетПолейИтогаСхемыКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                            - данные для заполнения объекта
//
Процедура МакетПолейИтогаСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("МакетПолейИтогаСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИмяГруппировки1");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИмяГруппировки2");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Макет");

	Если СтруктураОбъекта.Свойство("ПоляГруппировки1") Тогда
		Для Каждого ТекЭлемент Из СтруктураОбъекта.ПоляГруппировки1 Цикл
			Объект.ПоляГруппировки1.Добавить(Новый ПолеКомпоновкиДанных(ТекЭлемент.Имя));
		КонецЦикла;
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ПоляГруппировки2") Тогда
		Для Каждого ТекЭлемент Из СтруктураОбъекта.ПоляГруппировки2 Цикл
			Объект.ПоляГруппировки2.Добавить(Новый ПолеКомпоновкиДанных(ТекЭлемент.Имя));
		КонецЦикла;
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ТипМакета1") Тогда
		Объект.ТипМакета1 = ТипМакетаОбластиКомпоновкиДанных[СтруктураОбъекта.ТипМакета1];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ТипМакета2") Тогда
		Объект.ТипМакета2 = ТипМакетаОбластиКомпоновкиДанных[СтруктураОбъекта.ТипМакета2];
	КонецЕсли;

КонецПроцедуры // МакетПолейИтогаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// НаборДанныхЗапросСхемыКомпоновкиДанных
// 
// Параметры:
// 	Объект             - НаборДанныхЗапросСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция НаборДанныхЗапросСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("НаборДанныхЗапросСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "НаборДанныхЗапросСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("АвтозаполнениеДоступныхПолей", Объект.АвтозаполнениеДоступныхПолей);
	СтруктураОбъекта.Вставить("Запрос"                      , Объект.Запрос);
	СтруктураОбъекта.Вставить("Имя"                         , Объект.Имя);
	СтруктураОбъекта.Вставить("ИсточникДанных"              , Объект.ИсточникДанных);
	СтруктураОбъекта.Вставить("Поля"                        , КоллекцияСКДВМассив(Объект.Поля));

	Возврат СтруктураОбъекта;
	
КонецФункции // НаборДанныхЗапросСКДВСтруктуру()

// Процедура - заполняет объект СКД НаборДанныхЗапросСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - НаборДанныхЗапросСхемыКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                              - данные для заполнения объекта
//
Процедура НаборДанныхЗапросСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("НаборДанныхЗапросСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "АвтозаполнениеДоступныхПолей");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Запрос");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИсточникДанных");

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Поля", Истина);

КонецПроцедуры // НаборДанныхЗапросСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// НаборДанныхОбъектСхемыКомпоновкиДанных
// 
// Параметры:
// 	Объект             - НаборДанныхОбъектСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция НаборДанныхОбъектСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("НаборДанныхОбъектСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "НаборДанныхОбъектСхемыКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Имя"           , Объект.Имя);
	СтруктураОбъекта.Вставить("ИмяОбъекта"    , Объект.ИмяОбъекта);
	СтруктураОбъекта.Вставить("ИсточникДанных", Объект.ИсточникДанных);
	СтруктураОбъекта.Вставить("Поля"          , КоллекцияСКДВМассив(Объект.Поля));

	Возврат СтруктураОбъекта;
	
КонецФункции // НаборДанныхОбъектСКДВСтруктуру()

// Процедура - заполняет объект СКД НаборДанныхОбъектСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - НаборДанныхОбъектСхемыКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                              - данные для заполнения объекта
//
Процедура НаборДанныхОбъектСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("НаборДанныхОбъектСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИмяОбъекта");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИсточникДанных");

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Поля", Истина);

КонецПроцедуры // НаборДанныхОбъектСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// НаборДанныхОбъединениеСхемыКомпоновкиДанных
// 
// Параметры:
// 	Объект             - НаборДанныхОбъединениеСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция НаборДанныхОбъединениеСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("НаборДанныхОбъединениеСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "НаборДанныхОбъединениеСхемыКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Тип"     , "НаборДанныхОбъединениеСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Имя"     , Объект.Имя);
	СтруктураОбъекта.Вставить("Поля"    , КоллекцияСКДВМассив(Объект.Поля));
	СтруктураОбъекта.Вставить("Элементы", КоллекцияСКДВМассив(Объект.Элементы));
	
	Возврат СтруктураОбъекта;
	
КонецФункции // НаборДанныхОбъединениеСКДВСтруктуру()

// Процедура - заполняет объект СКД НаборДанныхОбъединениеСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - НаборДанныхОбъединениеСхемыКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                                   - данные для заполнения объекта
//
Процедура НаборДанныхОбъединениеСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("НаборДанныхОбъединениеСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Поля", Истина);
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы", Истина);

КонецПроцедуры // НаборДанныхОбъединениеСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПараметрСхемыКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ПараметрСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ПараметрСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ПараметрСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПараметрСхемыКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("ВключатьВДоступныеПоля"        , Объект.ВключатьВДоступныеПоля);
	СтруктураОбъекта.Вставить("Выражение"                     , Объект.Выражение);
	СтруктураОбъекта.Вставить("ДоступенСписокЗначений"        , Объект.ДоступенСписокЗначений);
	СтруктураОбъекта.Вставить("Заголовок"                     , Объект.Заголовок);
	СтруктураОбъекта.Вставить("ЗапрещатьНезаполненныеЗначения", Объект.ЗапрещатьНезаполненныеЗначения);
	СтруктураОбъекта.Вставить("Значение"                      , ЗначениеВСтруктуру(Объект.Значение));
	СтруктураОбъекта.Вставить("Имя"                           , Объект.Имя);
	
	СтруктураОбъекта.Вставить("Использование",
	                          ПеречислениеСКДВСтроку(Объект.Использование));
	
	СтруктураОбъекта.Вставить("ОграничениеИспользования"      , Объект.ОграничениеИспользования);
	СтруктураОбъекта.Вставить("ПараметрФункциональныхОпций"   , Объект.ПараметрФункциональныхОпций);
	
	СтруктураОбъекта.Вставить("ПараметрыРедактирования",
	                          ЗначениеСКДВСтруктуру(Объект.ПараметрыРедактирования));
	                          
	СтруктураОбъекта.Вставить("ТипЗначения"                   , ЗначениеВСтруктуру(Объект.ТипЗначения));

	Возврат СтруктураОбъекта;
	
КонецФункции // ПараметрСКДВСтруктуру()

// Процедура - заполняет объект СКД ПараметрСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ПараметрСхемыКомпоновкиДанных   - заполняемый объект
// 	СтруктураОбъекта   - Структура                       - данные для заполнения объекта
//
Процедура ПараметрСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ПараметрСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ВключатьВДоступныеПоля");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Выражение");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ДоступенСписокЗначений");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Заголовок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ЗапрещатьНезаполненныеЗначения");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ОграничениеИспользования");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПараметрФункциональныхОпций");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПараметрыРедактирования", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ЗапрещатьНезаполненныеЗначения");

	Если СтруктураОбъекта.Свойство("Значение") Тогда
		Объект.Значение = ЗначениеИзСтруктуры(СтруктураОбъекта.Значение);
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("Использование") Тогда
		Объект.Использование = ИспользованиеПараметраКомпоновкиДанных[СтруктураОбъекта.Использование];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ТипЗначения") Тогда
		Объект.ТипЗначения = ЗначениеИзСтруктуры(СтруктураОбъекта.ТипЗначения);
	КонецЕсли;

КонецПроцедуры // ПараметрСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПолеИтогаСхемыКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ПолеИтогаСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ПолеИтогаСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ПолеИтогаСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПолеИтогаСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Выражение"  , Объект.Выражение);
	СтруктураОбъекта.Вставить("ПутьКДанным", Объект.ПутьКДанным);

	МассивЭлементов = Новый Массив();
	Для Каждого ТекЭлемент Из Объект.Группировки Цикл
		// TODO: Проверить тип элемента массива группировок (вроде - Строка)
		МассивЭлементов.Добавить(СокрЛП(ТекЭлемент));
	КонецЦикла;
	СтруктураОбъекта.Вставить("Группировки", МассивЭлементов);
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ПолеИтогаСКДВСтруктуру()

// Процедура - заполняет объект СКД ПолеИтогаСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ПолеИтогаСхемыКомпоновкиДанных  - заполняемый объект
// 	СтруктураОбъекта   - Структура                       - данные для заполнения объекта
//
Процедура ПолеИтогаСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ПолеИтогаСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Выражение");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПутьКДанным");
	
	Если СтруктураОбъекта.Свойство("Группировки") Тогда
		Для Каждого ТекЭлемент Из СтруктураОбъекта.Группировки Цикл
			Объект.Группировки.Добавить(ТекЭлемент);
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры // ПолеИтогаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// СвязьНаборовДанныхСхемыКомпоновкиДанных
// 
// Параметры:
// 	Объект             - СвязьНаборовДанныхСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция СвязьНаборовДанныхСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("СвязьНаборовДанныхСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "СвязьНаборовДанныхСхемыКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("ВыражениеИсточник"       , Объект.ВыражениеИсточник);
	СтруктураОбъекта.Вставить("ВыражениеПриемник"       , Объект.ВыражениеПриемник);
	СтруктураОбъекта.Вставить("НаборДанныхИсточник"     , Объект.НаборДанныхИсточник);
	СтруктураОбъекта.Вставить("НаборДанныхПриемник"     , Объект.НаборДанныхПриемник);
	СтруктураОбъекта.Вставить("НачальноеВыражение"      , Объект.НачальноеВыражение);
	СтруктураОбъекта.Вставить("Обязательная"            , Объект.Обязательная);
	СтруктураОбъекта.Вставить("Параметр"                , Объект.Параметр);
	СтруктураОбъекта.Вставить("РазрешенСписокПараметров", Объект.РазрешенСписокПараметров);
	СтруктураОбъекта.Вставить("УсловиеСвязи"            , Объект.УсловиеСвязи);
	
	Возврат СтруктураОбъекта;
	
КонецФункции // СвязьНаборовДанныхСКДВСтруктуру()

// Процедура - заполняет объект СКД СвязьНаборовДанныхСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - СвязьНаборовДанныхСхемыКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                               - данные для заполнения объекта
//
Процедура СвязьНаборовДанныхСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("СвязьНаборовДанныхСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ВыражениеИсточник");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ВыражениеПриемник");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "НаборДанныхИсточник");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "НаборДанныхПриемник");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "НачальноеВыражение");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Обязательная");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Параметр");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "РазрешенСписокПараметров");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "УсловиеСвязи");

КонецПроцедуры // СвязьНаборовДанныхСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ВыражениеУпорядочиванияКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ВыражениеУпорядочиванияКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ВыражениеУпорядочиванияСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ВыражениеУпорядочиванияКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ВыражениеУпорядочиванияКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Автоупорядочивание", Объект.Автоупорядочивание);
	СтруктураОбъекта.Вставить("Выражение"         , Объект.Выражение);
	СтруктураОбъекта.Вставить("ТипУпорядочивания",
	                          ПеречислениеСКДВСтроку(Объект.ТипУпорядочивания));

	Возврат СтруктураОбъекта;
	
КонецФункции // ВыражениеУпорядочиванияСКДВСтруктуру()

// Процедура - заполняет объект СКД ВыражениеУпорядочиванияКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ВыражениеУпорядочиванияКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                               - данные для заполнения объекта
//
Процедура ВыражениеУпорядочиванияСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ВыражениеУпорядочиванияКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Автоупорядочивание");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Выражение");

	Если СтруктураОбъекта.Свойство("ТипУпорядочивания") Тогда
		Объект.ТипУпорядочивания = НаправлениеСортировкиКомпоновкиДанных[СтруктураОбъекта.ТипУпорядочивания];
	КонецЕсли;

КонецПроцедуры // ВыражениеУпорядочиванияСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ОграничениеИспользованияПоляСхемыКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ОграничениеИспользованияПоляСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ОграничениеИспользованияПоляСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ОграничениеИспользованияПоляСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ОграничениеИспользованияПоляСхемыКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Группировка", Объект.Группировка);
	СтруктураОбъекта.Вставить("Поле"       , Объект.Поле);
	СтруктураОбъекта.Вставить("Порядок"    , Объект.Порядок);
	СтруктураОбъекта.Вставить("Условие"    , Объект.Условие);

	Возврат СтруктураОбъекта;
	
КонецФункции // ОграничениеИспользованияПоляСКДВСтруктуру()

// Процедура - заполняет объект СКД ОграничениеИспользованияПоляСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ОграничениеИспользованияПоляСхемыКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                                         - данные для заполнения объекта
//
Процедура ОграничениеИспользованияПоляСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ОграничениеИспользованияПоляСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Группировка");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Поле");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Порядок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Условие");

КонецПроцедуры // ОграничениеИспользованияПоляСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ОформлениеКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ОформлениеКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ОформлениеСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ОформлениеКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ОформлениеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Элементы", КоллекцияСКДВМассив(Объект.Элементы));
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ОформлениеСКДВСтруктуру()

// Процедура - заполняет объект СКД ОформлениеКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ОформлениеКомпоновкиДанных   - заполняемый объект
// 	СтруктураОбъекта   - Структура                    - данные для заполнения объекта
//
Процедура ОформлениеСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ОформлениеКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	ЗначенияПараметровОбъектаСКДИзСтруктуры(Объект, Объект, СтруктураОбъекта);

КонецПроцедуры // ОформлениеСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ЗначениеПараметраНастроекКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ЗначениеПараметраНастроекКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ЗначениеПараметраНастроекСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ЗначениеПараметраНастроекКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ЗначениеПараметраНастроекКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"     , "ЗначениеПараметраНастроекКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Значение"     , ЗначениеВСтруктуру(Объект.Значение));
	СтруктураОбъекта.Вставить("Использование", Объект.Использование);
	СтруктураОбъекта.Вставить("Параметр"     , СокрЛП(Объект.Параметр));

	СтруктураОбъекта.Вставить("ЗначенияВложенныхПараметров",
	                          КоллекцияСКДВМассив(Объект.ЗначенияВложенныхПараметров));
	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));
	
	// TODO: Проверить как работает родитель
	Возврат СтруктураОбъекта;
	
КонецФункции // ЗначениеПараметраНастроекСКДВСтруктуру()

// Процедура - заполняет объект СКД ЗначениеПараметраНастроекКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ЗначениеПараметраНастроекКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                                 - данные для заполнения объекта
//
Процедура ЗначениеПараметраНастроекСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ЗначениеПараметраНастроекКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	Если СтруктураОбъекта.Свойство("Значение") Тогда
		Объект.Значение = ЗначениеИзСтруктуры(СтруктураОбъекта.Значение);
	КонецЕсли;
	
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "ЗначенияВложенныхПараметров");

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");
	
	Если СтруктураОбъекта.Свойство("Параметр") Тогда
		Объект.Параметр = Новый ПараметрКомпоновкиДанных(СтруктураОбъекта.Параметр);
	КонецЕсли;
	
	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения =
			РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;
	
КонецПроцедуры // ЗначениеПараметраНастроекСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ЗначениеПараметраКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ЗначениеПараметраКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ЗначениеПараметраСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ЗначениеПараметраКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ЗначениеПараметраКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"     , "ЗначениеПараметраКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Значение"     , ЗначениеВСтруктуру(Объект.Значение));
	СтруктураОбъекта.Вставить("Использование", Объект.Использование);
	СтруктураОбъекта.Вставить("Параметр"     , СокрЛП(Объект.Параметр));
	
	СтруктураОбъекта.Вставить("ЗначенияВложенныхПараметров",
	                          КоллекцияСКДВМассив(Объект.ЗначенияВложенныхПараметров));

	// TODO: Проверить как работает родитель
	Возврат СтруктураОбъекта;
	
КонецФункции // ЗначениеПараметраСКДВСтруктуру()

// Процедура - заполняет объект СКД ЗначениеПараметраКомпоновкиДанных из структуры описания объекта
// 
// Параметры:
// 	Объект             - ЗначениеПараметраКомпоновкиДанных  - заполняемый объект
// 	СтруктураОбъекта   - Структура                          - данные для заполнения объекта
//
Процедура ЗначениеПараметраСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ЗначениеПараметраКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	Если СтруктураОбъекта.Свойство("Значение") Тогда
		ВремЗначение = ЗначениеИзСтруктуры(СтруктураОбъекта.Значение);
		// Обработка случая пустого значения несериализуемого типа
		Если НЕ ВремЗначение = Неопределено ИЛИ ТипЗнч(Объект.Значение) = Тип("Неопределено") Тогда
			Объект.Значение = ВремЗначение;
		КонецЕсли;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "ЗначенияВложенныхПараметров");

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	
	Если СтруктураОбъекта.Свойство("Параметр") Тогда
		Объект.Параметр = Новый ПараметрКомпоновкиДанных(СтруктураОбъекта.Параметр);
	КонецЕсли;
	
КонецПроцедуры // ЗначениеПараметраСКДИзСтруктуры()

// Процедура - заполняет коллекцию объектов СКД ЗначениеПараметраНастроекКомпоновкиДанных,
// ЗначениеПараметраКомпоновкиДанных из структуры описания объекта
// 
// Параметры:
// 	ОбъектВладелец           - ОбъектСКД        - объект верхнего уровня, содержащий заполняемые коллекции,
//                                                для проверки доступных параметров
// 	Объект                   - ОбъектСКД        - объект, содержащий заполняемую коллекцию
// 	СтруктураОбъекта         - Структура        - данные для заполнения коллекции
// 	ИмяКоллекцииПараметров   - Строка           - имя заполняемой коллекции
//
Процедура ЗначенияПараметровОбъектаСКДИзСтруктуры(ОбъектВладелец,
                                                  Объект,
                                                  СтруктураОбъекта,
                                                  ИмяКоллекцииПараметров = "Элементы")
	
	Если НЕ СтруктураОбъекта.Свойство(ИмяКоллекцииПараметров) Тогда
		Возврат;
	КонецЕсли;
	
	Для Каждого ТекЭлемент Из СтруктураОбъекта[ИмяКоллекцииПараметров] Цикл
		Если ОбъектВладелец.ДоступныеПараметры = Неопределено Тогда
			НовыйЭлемент = Объект[ИмяКоллекцииПараметров].Добавить();
			ЗначениеСКДИзСтруктуры(НовыйЭлемент, ТекЭлемент);
		Иначе	
			ТекПараметр = ОбъектВладелец.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных(ТекЭлемент.Параметр));
			ВремЗначение = ЗначениеИзСтруктуры(ТекЭлемент.Значение);
			// Обработка случая пустого значения несериализуемого типа
			Если НЕ ВремЗначение = Неопределено ИЛИ ТипЗнч(ТекПараметр.Значение) = Тип("Неопределено") Тогда
				ТекПараметр.Значение = ВремЗначение;
			КонецЕсли;
			ЗначенияПараметровОбъектаСКДИзСтруктуры(ОбъектВладелец, ТекПараметр, ТекЭлемент, "ЗначенияВложенныхПараметров");
			ТекПараметр.Использование = ТекЭлемент.Использование;
			Если ТипЗнч(ТекПараметр) = Тип("ЗначениеПараметраНастроекКомпоновкиДанных") Тогда
				ТекПараметр.ИдентификаторПользовательскойНастройки = ТекЭлемент.ИдентификаторПользовательскойНастройки;
				ТекПараметр.ПредставлениеПользовательскойНастройки = ТекЭлемент.ПредставлениеПользовательскойНастройки;
				ТекПараметр.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[ТекЭлемент.РежимОтображения];
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
			
КонецПроцедуры // ЗначенияПараметровОбъектаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПараметрыРедактированияКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ПараметрыРедактированияКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ПараметрыРедактированияСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ПараметрыРедактированияКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПараметрыРедактированияКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Элементы", КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;
	
КонецФункции // ПараметрыРедактированияСКДВСтруктуру()

// Процедура - заполняет объект СКД ПараметрыРедактированияКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ПараметрыРедактированияКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                               - данные для заполнения объекта
//
Процедура ПараметрыРедактированияСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ПараметрыРедактированияКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	ЗначенияПараметровОбъектаСКДИзСтруктуры(Объект, Объект, СтруктураОбъекта);

КонецПроцедуры // ПараметрыРедактированияСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// СтрокаТаблицыОбластиКомпоновкиДанных
// 
// Параметры:
// 	Объект             - СтрокаТаблицыОбластиКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция СтрокаТаблицыОбластиСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("СтрокаТаблицыОбластиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "СтрокаТаблицыОбластиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ИдентификаторТаблицы", Объект.ИдентификаторТаблицы);
	СтруктураОбъекта.Вставить("Ячейки"              , КоллекцияСКДВМассив(Объект.Ячейки));

	Возврат СтруктураОбъекта;
	
КонецФункции // СтрокаТаблицыОбластиСКДВСтруктуру()

// Процедура - заполняет объект СКД СтрокаТаблицыОбластиКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - СтрокаТаблицыОбластиКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                            - данные для заполнения объекта
//
Процедура СтрокаТаблицыОбластиСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("СтрокаТаблицыОбластиКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторТаблицы");
	
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Ячейки");

КонецПроцедуры // СтрокаТаблицыОбластиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ЯчейкаТаблицыОбластиКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ЯчейкаТаблицыОбластиКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ЯчейкаТаблицыОбластиСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ЯчейкаТаблицыОбластиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ЯчейкаТаблицыОбластиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Оформление", ЗначениеСКДВСтруктуру(Объект.Оформление));
	СтруктураОбъекта.Вставить("Элементы"  , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;
	
КонецФункции // ЯчейкаТаблицыОбластиСКДВСтруктуру()

// Процедура - заполняет объект СКД ЯчейкаТаблицыОбластиКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ЯчейкаТаблицыОбластиКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                            - данные для заполнения объекта
//
Процедура ЯчейкаТаблицыОбластиСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ЯчейкаТаблицыОбластиКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Оформление", Истина);

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы", Истина);

КонецПроцедуры // ЯчейкаТаблицыОбластиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ОформлениеЯчейкиТаблицыОбластиКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ОформлениеЯчейкиТаблицыОбластиКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ОформлениеЯчейкиТаблицыОбластиСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ОформлениеЯчейкиТаблицыОбластиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ОформлениеЯчейкиТаблицыОбластиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Элементы"  , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;
	
КонецФункции // ОформлениеЯчейкиТаблицыОбластиСКДВСтруктуру()

// Процедура - заполняет объект СКД ОформлениеЯчейкиТаблицыОбластиКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ОформлениеЯчейкиТаблицыОбластиКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                                      - данные для заполнения объекта
//
Процедура ОформлениеЯчейкиТаблицыОбластиСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ОформлениеЯчейкиТаблицыОбластиКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	ЗначенияПараметровОбъектаСКДИзСтруктуры(Объект, Объект, СтруктураОбъекта);

КонецПроцедуры // ОформлениеЯчейкиТаблицыОбластиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ОформлениеПоляОбластиКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ОформлениеПоляОбластиКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ОформлениеПоляОбластиСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ОформлениеПоляОбластиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ОформлениеПоляОбластиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Элементы"  , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;
	
КонецФункции // ОформлениеПоляОбластиСКДВСтруктуру()

// Процедура - заполняет объект СКД ОформлениеПоляОбластиКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ОформлениеПоляОбластиКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                             - данные для заполнения объекта
//
Процедура ОформлениеПоляОбластиСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ОформлениеПоляОбластиКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	ЗначенияПараметровОбъектаСКДИзСтруктуры(Объект, Объект, СтруктураОбъекта);

КонецПроцедуры // ОформлениеПоляОбластиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПараметрОбластиВыражениеКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ПараметрОбластиВыражениеКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ПараметрОбластиВыражениеСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ПараметрОбластиВыражениеКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПараметрОбластиВыражениеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"      , "ПараметрОбластиВыражениеКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Имя"      , Объект.Имя);
	СтруктураОбъекта.Вставить("Выражение", Объект.Выражение);

	Возврат СтруктураОбъекта;
	
КонецФункции // ПараметрОбластиВыражениеСКДВСтруктуру()

// Процедура - заполняет объект СКД ПараметрОбластиВыражениеКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ПараметрОбластиВыражениеКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                                - данные для заполнения объекта
//
Процедура ПараметрОбластиВыражениеСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ПараметрОбластиВыражениеКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Выражение");
	
КонецПроцедуры // ПараметрОбластиВыражениеСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПараметрОбластиРасшифровкаКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ПараметрОбластиРасшифровкаКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ПараметрОбластиРасшифровкаСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ПараметрОбластиРасшифровкаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПараметрОбластиРасшифровкаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Имя"           , Объект.Имя);
	СтруктураОбъекта.Вставить("ВыраженияПолей", КоллекцияСКДВМассив(Объект.ВыраженияПолей));

	СтруктураОбъекта.Вставить("ОсновноеДействие",
	                          ПеречислениеСКДВСтроку(Объект.ОсновноеДействие));

	Возврат СтруктураОбъекта;
	
КонецФункции // ПараметрОбластиРасшифровкаСКДВСтруктуру()

// Процедура - заполняет объект СКД ПараметрОбластиРасшифровкаКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ПараметрОбластиРасшифровкаКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                                  - данные для заполнения объекта
//
Процедура ПараметрОбластиРасшифровкаСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ПараметрОбластиРасшифровкаКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "ВыраженияПолей");
	
	Если СтруктураОбъекта.Свойство("ОсновноеДействие") Тогда
		Объект.ОсновноеДействие = ДействиеОбработкиРасшифровкиКомпоновкиДанных[СтруктураОбъекта.ОсновноеДействие];
	КонецЕсли;
	
КонецПроцедуры // ПараметрОбластиРасшифровкаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ВыражениеПоляПараметраОбластиРасшифровкаКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ВыражениеПоляПараметраОбластиРасшифровкаКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ВыражениеПоляПараметраРасшифровкиСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ВыражениеПоляПараметраОбластиРасшифровкаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ВыражениеПоляПараметраОбластиРасшифровкаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Выражение", Объект.Выражение);
	СтруктураОбъекта.Вставить("Поле"     , Объект.Поле);

	Возврат СтруктураОбъекта;
	
КонецФункции // ВыражениеПоляПараметраРасшифровкиСКДВСтруктуру()

// Процедура - заполняет объект СКД ВыражениеПоляПараметраОбластиРасшифровкаКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ВыражениеПоляПараметраОбластиРасшифровкаКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                                                - данные для заполнения объекта
//
Процедура ВыражениеПоляПараметраРасшифровкиСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ВыражениеПоляПараметраОбластиРасшифровкаКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Выражение");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Поле");
	
КонецПроцедуры // ВыражениеПоляПараметраРасшифровкиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПолеОбластиКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ПолеОбластиКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ПолеОбластиСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ПолеОбластиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПолеОбластиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"       , "ПолеОбластиКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Значение"  , ЗначениеВСтруктуру(Объект.Значение));
	СтруктураОбъекта.Вставить("Оформление", ЗначениеСКДВСтруктуру(Объект.Оформление));

	Возврат СтруктураОбъекта;
	
КонецФункции // ПолеОбластиСКДВСтруктуру()

// Процедура - заполняет объект СКД ПолеОбластиКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ПолеОбластиКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                   - данные для заполнения объекта
//
Процедура ПолеОбластиСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ПолеОбластиКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	Если СтруктураОбъекта.Свойство("Значение") Тогда
		Объект.Значение = ЗначениеИзСтруктуры(СтруктураОбъекта.Значение);
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Оформление", Истина);
	
КонецПроцедуры // ПолеОбластиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПолеНабораДанныхСхемыКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ПолеНабораДанныхСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ПолеНабораДанныхПолеСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ПолеНабораДанныхСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПолеНабораДанныхСхемыКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Тип"      , "ПолеНабораДанныхСхемыКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("ВыражениеПредставления"     , Объект.ВыражениеПредставления);
	СтруктураОбъекта.Вставить("ВыраженияУпорядочивания"    , КоллекцияСКДВМассив(Объект.ВыраженияУпорядочивания));
	СтруктураОбъекта.Вставить("Заголовок"                  , Объект.Заголовок);
	СтруктураОбъекта.Вставить("НаборДанныхПроверкиИерархии", Объект.НаборДанныхПроверкиИерархии);
	
	СтруктураОбъекта.Вставить("ОграничениеИспользования",
	                          ЗначениеСКДВСтруктуру(Объект.ОграничениеИспользования));
	СтруктураОбъекта.Вставить("ОграничениеИспользованияРеквизитов",
	                          ЗначениеСКДВСтруктуру(Объект.ОграничениеИспользованияРеквизитов));
	                          
	СтруктураОбъекта.Вставить("Оформление", ЗначениеСКДВСтруктуру(Объект.Оформление));
	СтруктураОбъекта.Вставить("ПараметрНабораДанныхПроверкиИерархии", Объект.ПараметрНабораДанныхПроверкиИерархии);
	
	СтруктураОбъекта.Вставить("ПараметрыРедактирования",
	                          ЗначениеСКДВСтруктуру(Объект.ПараметрыРедактирования));
	                          
	СтруктураОбъекта.Вставить("Поле"       , Объект.Поле);
	СтруктураОбъекта.Вставить("ПутьКДанным", Объект.ПутьКДанным);
	СтруктураОбъекта.Вставить("Роль"       , ЗначениеСКДВСтруктуру(Объект.Роль));
	СтруктураОбъекта.Вставить("ТипЗначения", ЗначениеВСтруктуру(Объект.ТипЗначения));
	 
	Возврат СтруктураОбъекта;
	
КонецФункции // ПолеНабораДанныхПолеСКДВСтруктуру()

// Процедура - заполняет объект СКД ПолеНабораДанныхСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ПолеНабораДанныхСхемыКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                             - данные для заполнения объекта
//
Процедура ПолеНабораДанныхПолеСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ПолеНабораДанныхСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ВыражениеПредставления");

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "ВыраженияУпорядочивания");

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Заголовок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "НаборДанныхПроверкиИерархии");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ОграничениеИспользования", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ОграничениеИспользованияРеквизитов", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Оформление", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПараметрНабораДанныхПроверкиИерархии");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПараметрыРедактирования", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Поле");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПутьКДанным");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Роль", Истина);

	Если СтруктураОбъекта.Свойство("ТипЗначения") Тогда
		Объект.ТипЗначения = ЗначениеИзСтруктуры(СтруктураОбъекта.ТипЗначения);
	КонецЕсли;

КонецПроцедуры // ПолеНабораДанныхПолеСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПапкаПолейНабораДанныхСхемыКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ПапкаПолейНабораДанныхСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ПолеНабораДанныхПапкаСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ПапкаПолейНабораДанныхСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПапкаПолейНабораДанныхСхемыКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Тип"      , "ПапкаПолейНабораДанныхСхемыКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Заголовок", Объект.Заголовок);
	
	СтруктураОбъекта.Вставить("ОграничениеИспользования",
	                          ЗначениеСКДВСтруктуру(Объект.ОграничениеИспользования));

	СтруктураОбъекта.Вставить("ПутьКДанным", Объект.ПутьКДанным);
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ПолеНабораДанныхПапкаСКДВСтруктуру()

// Процедура - заполняет объект СКД ПапкаПолейНабораДанныхСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ПапкаПолейНабораДанныхСхемыКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                                   - данные для заполнения объекта
//
Процедура ПолеНабораДанныхПапкаСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ПапкаПолейНабораДанныхСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Заголовок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ОграничениеИспользования", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПутьКДанным");

КонецПроцедуры // ПолеНабораДанныхПапкаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ВложенныйНаборДанныхСхемыКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ВложенныйНаборДанныхСхемыКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ПолеНабораДанныхВложенныйНаборСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ВложенныйНаборДанныхСхемыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ВложенныйНаборДанныхСхемыКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Тип"        , "ВложенныйНаборДанныхСхемыКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Заголовок"  , Объект.Заголовок);
	СтруктураОбъекта.Вставить("Поле"       , Объект.Поле);
	СтруктураОбъекта.Вставить("ПутьКДанным", Объект.ПутьКДанным);
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ПолеНабораДанныхВложенныйНаборСКДВСтруктуру()

// Процедура - заполняет объект СКД ВложенныйНаборДанныхСхемыКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ВложенныйНаборДанныхСхемыКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                                 - данные для заполнения объекта
//
Процедура ПолеНабораДанныхВложенныйНаборСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ВложенныйНаборДанныхСхемыКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Заголовок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Поле");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПутьКДанным");

КонецПроцедуры // ПолеНабораДанныхВложенныйНаборСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ВыбранныеПоляКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ВыбранныеПоляКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ВыбранныеПоляСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ВыбранныеПоляКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ВыбранныеПоляКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));
	                          
	СтруктураОбъекта.Вставить("Элементы"    , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;
	
КонецФункции // ВыбранныеПоляСКДВСтруктуру()

// Процедура - заполняет объект СКД ВыбранныеПоляКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ВыбранныеПоляКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                     - данные для заполнения объекта
//
Процедура ВыбранныеПоляСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ВыбранныеПоляКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения =
			РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы", Истина);

КонецПроцедуры // ВыбранныеПоляСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ГруппаВыбранныхПолейКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ГруппаВыбранныхПолейКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ГруппаВыбранныхПолейСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ГруппаВыбранныхПолейКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ГруппаВыбранныхПолейКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"             , "ГруппаВыбранныхПолейКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Заголовок"       , Объект.Заголовок);
	СтруктураОбъекта.Вставить("Использование"   , Объект.Использование);
	СтруктураОбъекта.Вставить("Поле"            , ЗначениеСКДВСтруктуру(Объект.Поле));
	СтруктураОбъекта.Вставить("Расположение"    , ПеречислениеСКДВСтроку(Объект.Расположение));
	СтруктураОбъекта.Вставить("Элементы"        , КоллекцияСКДВМассив(Объект.Элементы));
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));
	// TODO: проверить родителя

	Возврат СтруктураОбъекта;
	
КонецФункции // ГруппаВыбранныхПолейСКДВСтруктуру()

// Процедура - заполняет объект СКД ГруппаВыбранныхПолейКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ГруппаВыбранныхПолейКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                            - данные для заполнения объекта
//
Процедура ГруппаВыбранныхПолейСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ГруппаВыбранныхПолейКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Заголовок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");

	Если СтруктураОбъекта.Свойство("Поле") Тогда
		Объект.Поле = Новый ПолеКомпоновкиДанных(СтруктураОбъекта.Поле.Имя);
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("Расположение") Тогда
		Объект.Расположение = РасположениеПоляКомпоновкиДанных[СтруктураОбъекта.Расположение];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения =
			РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;
	// TODO: проверить родителя

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы", Истина);
	
КонецПроцедуры // ГруппаВыбранныхПолейСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// АвтоВыбранноеПолеКомпоновкиДанных
// 
// Параметры:
// 	Объект             - АвтоВыбранноеПолеКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция АвтоВыбранноеПолеСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "АвтоВыбранноеПолеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"          , "АвтоВыбранноеПолеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Использование", Объект.Использование);
	// TODO: проверить родителя
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ВыбранноеПолеСКДВСтруктуру()

// Процедура - заполняет объект СКД АвтоВыбранноеПолеКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - АвтоВыбранноеПолеКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                         - данные для заполнения объекта
//
Процедура АвтоВыбранноеПолеСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	// TODO: проверить родителя

КонецПроцедуры // АвтоВыбранноеПолеСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ВыбранноеПолеКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ВыбранноеПолеКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ВыбранноеПолеСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ВыбранноеПолеКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ВыбранноеПолеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"             , "ВыбранноеПолеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Заголовок"       , Объект.Заголовок);
	СтруктураОбъекта.Вставить("Использование"   , Объект.Использование);
	СтруктураОбъекта.Вставить("Поле"            , ЗначениеСКДВСтруктуру(Объект.Поле));
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));
	// TODO: проверить родителя

	Возврат СтруктураОбъекта;
	
КонецФункции // ВыбранноеПолеСКДВСтруктуру()

// Процедура - заполняет объект СКД ВыбранноеПолеКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ВыбранноеПолеКомпоновкиДанных         - заполняемый объект
// 	СтруктураОбъекта   - Структура                             - данные для заполнения объекта
//
Процедура ВыбранноеПолеСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ВыбранноеПолеКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Заголовок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");

	Если СтруктураОбъекта.Свойство("Поле") Тогда
		Объект.Поле = Новый ПолеКомпоновкиДанных(СтруктураОбъекта.Поле.Имя);
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения =
			РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;
	// TODO: проверить родителя

КонецПроцедуры // ВыбранноеПолеСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// РольПоляНабораДанныхКомпоновкиДанных
// 
// Параметры:
// 	Объект             - РольПоляНабораДанныхКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция РольПоляНабораДанныхСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("РольПоляНабораДанныхКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "РольПоляНабораДанныхКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ВыражениеВидаСчета"      , Объект.ВыражениеВидаСчета);
	СтруктураОбъекта.Вставить("ГруппаОстатка"           , Объект.ГруппаОстатка);
	СтруктураОбъекта.Вставить("ИгнорироватьЗначенияNULL", Объект.ИгнорироватьЗначенияNULL);
	СтруктураОбъекта.Вставить("Измерение"               , Объект.Измерение);
	СтруктураОбъекта.Вставить("НомерПериода"            , Объект.НомерПериода);
	СтруктураОбъекта.Вставить("Обязательное"            , Объект.Обязательное);
	СтруктураОбъекта.Вставить("Остаток"                 , Объект.Остаток);
	СтруктураОбъекта.Вставить("ПолеСчета"               , Объект.ПолеСчета);
	СтруктураОбъекта.Вставить("РеквизитИзмерения"       , Объект.РеквизитИзмерения);
	СтруктураОбъекта.Вставить("РодительскоеИзмерение"   , Объект.РодительскоеИзмерение);
	СтруктураОбъекта.Вставить("Счет"                    , Объект.Счет);
	СтруктураОбъекта.Вставить("ТипБухгалтерскогоОстатка",
	                          ПеречислениеСКДВСтроку(Объект.ТипБухгалтерскогоОстатка));
	СтруктураОбъекта.Вставить("ТипОстатка"    , ПеречислениеСКДВСтроку(Объект.ТипОстатка));
	СтруктураОбъекта.Вставить("ТипПериода"    , ПеречислениеСКДВСтроку(Объект.ТипПериода));
	
	Возврат СтруктураОбъекта;

КонецФункции // РольПоляНабораДанныхСКДВСтруктуру()

// Процедура - заполняет объект СКД РольПоляНабораДанныхКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - РольПоляНабораДанныхКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                            - данные для заполнения объекта
//
Процедура РольПоляНабораДанныхСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("РольПоляНабораДанныхКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ВыражениеВидаСчета");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ГруппаОстатка");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИгнорироватьЗначенияNULL");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Измерение");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "НомерПериода");
	//@skip-error - в СП свойство указано как "Только чтение", но на самом деле свойство записывается
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Обязательное");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Остаток");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПолеСчета");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "РеквизитИзмерения");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "РодительскоеИзмерение");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Счет");

	Если СтруктураОбъекта.Свойство("ТипБухгалтерскогоОстатка") Тогда
		Объект.ТипБухгалтерскогоОстатка =
			ТипБухгалтерскогоОстаткаКомпоновкиДанных[СтруктураОбъекта.ТипБухгалтерскогоОстатка];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ТипОстатка") Тогда
		Объект.ТипОстатка = ТипОстаткаКомпоновкиДанных[СтруктураОбъекта.ТипОстатка];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ТипПериода") Тогда
		Объект.ТипПериода = ТипПериодаКомпоновкиДанных[СтруктураОбъекта.ТипПериода];
	КонецЕсли;

КонецПроцедуры // РольПоляНабораДанныхСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ГруппаЭлементовОтбораКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ГруппаЭлементовОтбораКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ГруппаЭлементовОтбораСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ГруппаЭлементовОтбораКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("Использование"   , Объект.Использование);
	СтруктураОбъекта.Вставить("Представление"   , Объект.Представление);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);
	СтруктураОбъекта.Вставить("Применение",
	                          ПеречислениеСКДВСтроку(Объект.Применение));
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));
	// TODO: проверить родителя
	СтруктураОбъекта.Вставить("ТипГруппы",
	                          ПеречислениеСКДВСтроку(Объект.ТипГруппы));

	СтруктураОбъекта.Вставить("Элементы"    , КоллекцияСКДВМассив(Объект.Элементы));
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ГруппаЭлементовОтбораСКДВСтруктуру()

// Процедура - заполняет объект СКД ГруппаЭлементовОтбораКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ГруппаЭлементовОтбораКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                             - данные для заполнения объекта
//
Процедура ГруппаЭлементовОтбораСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Представление");

	Если СтруктураОбъекта.Свойство("Применение") Тогда
		Объект.Применение = ТипПримененияОтбораКомпоновкиДанных[СтруктураОбъекта.Применение];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ТипГруппы") Тогда
		Объект.ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных[СтруктураОбъекта.ТипГруппы];
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы", Истина);
	
КонецПроцедуры // ГруппаЭлементовОтбораСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ЭлементОтбораКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ЭлементОтбораКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ЭлементОтбораСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ЭлементОтбораКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("Использование"   , Объект.Использование);
	СтруктураОбъекта.Вставить("ЛевоеЗначение"   , ЗначениеСКДВСтруктуру(Объект.ЛевоеЗначение));
	СтруктураОбъекта.Вставить("ПравоеЗначение"  , ЗначениеВСтруктуру(Объект.ПравоеЗначение));
	СтруктураОбъекта.Вставить("Представление"   , Объект.Представление);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);
	СтруктураОбъекта.Вставить("Применение",
	                          ПеречислениеСКДВСтроку(Объект.Применение));
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));
	// TODO: проверить родителя

	Возврат СтруктураОбъекта;
	
КонецФункции // ЭлементОтбораСКДВСтруктуру()

// Процедура - заполняет объект СКД ЭлементОтбораКомпоновкиДанных из структуры описания объекта
// 
// Параметры:
// 	Объект             - ЭлементОтбораКомпоновкиДанных   - заполняемый объект
// 	СтруктураОбъекта   - Структура                       - данные для заполнения объекта
//
Процедура ЭлементОтбораСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Представление");

	Если СтруктураОбъекта.Свойство("ЛевоеЗначение") Тогда
		Объект.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(СтруктураОбъекта.ЛевоеЗначение.Имя);
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ПравоеЗначение") Тогда
		Объект.ПравоеЗначение = ЗначениеИзСтруктуры(СтруктураОбъекта.ПравоеЗначение);
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("Применение") Тогда
		Объект.Применение = ТипПримененияОтбораКомпоновкиДанных[СтруктураОбъекта.Применение];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

КонецПроцедуры // ЭлементОтбораСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ОтборКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ОтборКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ОтборСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ОтборКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ОтборКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));

	СтруктураОбъекта.Вставить("Элементы"    , КоллекцияСКДВМассив(Объект.Элементы));
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ОтборСКДВСтруктуру()

// Процедура - заполняет объект СКД ОтборКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ОтборКомпоновкиДанных   - заполняемый объект
// 	СтруктураОбъекта   - Структура               - данные для заполнения объекта
//
Процедура ОтборСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ОтборКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы", Истина);
	
КонецПроцедуры // ОтборСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ЗначенияПараметровВыводаКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ЗначенияПараметровВыводаКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ЗначенияПараметровВыводаСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ЗначенияПараметровВыводаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ЗначенияПараметровВыводаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Элементы"    , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;
	
КонецФункции // ЗначенияПараметровВыводаСКДВСтруктуру()

// Процедура - заполняет объект СКД ЗначенияПараметровВыводаКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ЗначенияПараметровВыводаКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                                - данные для заполнения объекта
//
Процедура ЗначенияПараметровВыводаСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ЗначенияПараметровВыводаКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	ЗначенияПараметровОбъектаСКДИзСтруктуры(Объект, Объект, СтруктураОбъекта);
	
КонецПроцедуры // ЗначенияПараметровВыводаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ЗначенияПараметровДанныхКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ЗначенияПараметровДанныхКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ЗначенияПараметровДанныхСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ЗначенияПараметровДанныхКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ЗначенияПараметровДанныхКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Элементы"    , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;
	
КонецФункции // ЗначенияПараметровДанныхСКДВСтруктуру()

// Процедура - заполняет объект СКД ЗначенияПараметровДанныхКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ЗначенияПараметровДанныхКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                                - данные для заполнения объекта
//
Процедура ЗначенияПараметровДанныхСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ЗначенияПараметровДанныхКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	ЗначенияПараметровОбъектаСКДИзСтруктуры(Объект, Объект, СтруктураОбъекта);
	
КонецПроцедуры // ЗначенияПараметровДанныхСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПользовательскоеПолеВыражениеКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ПользовательскоеПолеВыражениеКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ПользовательскоеПолеВыражениеСКДВСтруктуру(Объект)

	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ПользовательскоеПолеВыражениеКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПользовательскоеПолеВыражениеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"          , "ПользовательскоеПолеВыражениеКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Заголовок"    , Объект.Заголовок);
	СтруктураОбъекта.Вставить("Использование", Объект.Использование);
	СтруктураОбъекта.Вставить("ПутьКДанным"  , Объект.ПутьКДанным);
	
	СтруктураОбъекта.Вставить("ВыражениеДетальныхЗаписей", Объект.ПолучитьВыражениеДетальныхЗаписей());
	СтруктураОбъекта.Вставить("ВыражениеИтоговыхЗаписей" , Объект.ПолучитьВыражениеИтоговыхЗаписей());
	СтруктураОбъекта.Вставить("ПредставлениеВыраженияДетальныхЗаписей",
	                          Объект.ПолучитьПредставлениеВыраженияДетальныхЗаписей());
	СтруктураОбъекта.Вставить("ПредставлениеВыраженияИтоговыхЗаписей" ,
	                          Объект.ПолучитьПредставлениеВыраженияИтоговыхЗаписей());
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ПользовательскоеПолеВыражениеСКДВСтруктуру()

// Процедура - заполняет объект СКД ПользовательскоеПолеВыражениеКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ПользовательскоеПолеВыражениеКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                                     - данные для заполнения объекта
//
Процедура ПользовательскоеПолеВыражениеСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ПользовательскоеПолеВыражениеКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Заголовок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");

	ВыражениеДетальныхЗаписей = "";
	Если СтруктураОбъекта.Свойство("ВыражениеДетальныхЗаписей") Тогда
		ВыражениеДетальныхЗаписей = СтруктураОбъекта.ВыражениеДетальныхЗаписей;
	КонецЕсли;

	ВыражениеИтоговыхЗаписей = "";
	Если СтруктураОбъекта.Свойство("ВыражениеИтоговыхЗаписей") Тогда
		ВыражениеИтоговыхЗаписей = СтруктураОбъекта.ВыражениеИтоговыхЗаписей;
	КонецЕсли;
	
	Объект.УстановитьВыражения(ВыражениеДетальныхЗаписей, ВыражениеИтоговыхЗаписей);
	
	ПредставлениеВыраженияДетальныхЗаписей = "";
	Если СтруктураОбъекта.Свойство("ПредставлениеВыраженияДетальныхЗаписей") Тогда
		ПредставлениеВыраженияДетальныхЗаписей = СтруктураОбъекта.ПредставлениеВыраженияДетальныхЗаписей;
	КонецЕсли;

	ПредставлениеВыраженияИтоговыхЗаписей = "";
	Если СтруктураОбъекта.Свойство("ПредставлениеВыраженияИтоговыхЗаписей") Тогда
		ПредставлениеВыраженияИтоговыхЗаписей = СтруктураОбъекта.ПредставлениеВыраженияИтоговыхЗаписей;
	КонецЕсли;
	
	Объект.УстановитьПредставлениеВыражений(ПредставлениеВыраженияДетальныхЗаписей,
	                                        ПредставлениеВыраженияИтоговыхЗаписей);
	
КонецПроцедуры // ПользовательскоеПолеВыражениеСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПользовательскоеПолеВыборКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ПользовательскоеПолеВыборКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ПользовательскоеПолеВыборСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ПользовательскоеПолеВыборКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПользовательскоеПолеВыборКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"          , "ПользовательскоеПолеВыборКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Заголовок"    , Объект.Заголовок);
	СтруктураОбъекта.Вставить("Использование", Объект.Использование);
	СтруктураОбъекта.Вставить("ПутьКДанным"  , Объект.ПутьКДанным);

	СтруктураОбъекта.Вставить("Варианты"     , ЗначениеСКДВСтруктуру(Объект.Варианты));
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ПользовательскоеПолеВыборСКДВСтруктуру()

// Процедура - заполняет объект СКД ПользовательскоеПолеВыборКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ПользовательскоеПолеВыборКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                                 - данные для заполнения объекта
//
Процедура ПользовательскоеПолеВыборСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ПользовательскоеПолеВыборКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Заголовок");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Варианты", Истина);

КонецПроцедуры // ПользовательскоеПолеВыборСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПользовательскиеПоляКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ПользовательскиеПоляКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ПользовательскиеПоляСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ПользовательскиеПоляКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПользовательскиеПоляКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Элементы"    , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;
	
КонецФункции // ПользовательскиеПоляСКДВСтруктуру()

// Процедура - заполняет объект СКД ПользовательскиеПоляКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ПользовательскиеПоляКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                            - данные для заполнения объекта
//
Процедура ПользовательскиеПоляСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ПользовательскиеПоляКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы", Истина);
	
КонецПроцедуры // ПользовательскиеПоляСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ВариантПользовательскогоПоляВыборКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ВариантПользовательскогоПоляВыборКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ВариантПользовательскогоПоляВыбораСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ВариантПользовательскогоПоляВыборКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ВариантПользовательскогоПоляВыборКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Значение"     , ЗначениеВСтруктуру(Объект.Значение));
	СтруктураОбъекта.Вставить("Использование", Объект.Использование);
	СтруктураОбъекта.Вставить("Представление", Объект.Представление);
	СтруктураОбъекта.Вставить("Отбор"        , ЗначениеСКДВСтруктуру(Объект.Отбор));

	Возврат СтруктураОбъекта;
	
КонецФункции // ВариантПользовательскогоПоляВыбораСКДВСтруктуру()

// Процедура - заполняет объект СКД ВариантПользовательскогоПоляВыборКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ВариантПользовательскогоПоляВыборКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                                         - данные для заполнения объекта
//
Процедура ВариантПользовательскогоПоляВыбораСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ВариантПользовательскогоПоляВыборКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	
	Если СтруктураОбъекта.Свойство("Значение") Тогда
		Объект.Значение = ЗначениеИзСтруктуры(СтруктураОбъекта.Значение);
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Представление");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Отбор", Истина);

КонецПроцедуры // ВариантПользовательскогоПоляВыбораСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ВариантыПользовательскогоПоляВыборКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ВариантыПользовательскогоПоляВыборКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ВариантыПользовательскогоПоляВыбораСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ВариантыПользовательскогоПоляВыборКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ВариантыПользовательскогоПоляВыборКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Элементы"    , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;
	
КонецФункции // ВариантыПользовательскогоПоляВыбораСКДВСтруктуру()

// Процедура - заполняет объект СКД ВариантыПользовательскогоПоляВыборКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ВариантыПользовательскогоПоляВыборКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                                          - данные для заполнения объекта
//
Процедура ВариантыПользовательскогоПоляВыбораСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ВариантыПользовательскогоПоляВыборКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы");
	
КонецПроцедуры // ВариантыПользовательскогоПоляВыбораСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// АвтоЭлементПорядкаКомпоновкиДанных
// 
// Параметры:
// 	Объект             - АвтоЭлементПорядкаКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция АвтоЭлементПорядкаСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("АвтоЭлементПорядкаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "АвтоЭлементПорядкаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"   , "АвтоЭлементПорядкаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Использование"   , Объект.Использование);

	Возврат СтруктураОбъекта;
	
КонецФункции // АвтоЭлементПорядкаСКДВСтруктуру()

// Процедура - заполняет объект СКД АвтоЭлементПорядкаКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - АвтоЭлементПорядкаКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                          - данные для заполнения объекта
//
Процедура АвтоЭлементПорядкаСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("АвтоЭлементПорядкаКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");

КонецПроцедуры // АвтоЭлементПорядкаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ЭлементПорядкаКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ЭлементПорядкаКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ЭлементПорядкаСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ЭлементПорядкаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ЭлементПорядкаКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Тип"   , "ЭлементПорядкаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Использование"   , Объект.Использование);
	СтруктураОбъекта.Вставить("Поле"            , ЗначениеСКДВСтруктуру(Объект.Поле));
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));
	СтруктураОбъекта.Вставить("ТипУпорядочивания",
	                          ПеречислениеСКДВСтроку(Объект.ТипУпорядочивания));

	Возврат СтруктураОбъекта;
	
КонецФункции // ЭлементПорядкаСКДВСтруктуру()

// Процедура - заполняет объекты СКД ЭлементПорядкаКомпоновкиДанных из структуры описания объекта
// 
// Параметры:
// 	Объект             - ЭлементПорядкаКомпоновкиДанных   - заполняемый объект
// 	СтруктураОбъекта   - Структура                        - данные для заполнения объекта
//
Процедура ЭлементПорядкаСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ЭлементПорядкаКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");

	Если СтруктураОбъекта.Свойство("Поле") Тогда
		Объект.Поле = Новый ПолеКомпоновкиДанных(СтруктураОбъекта.Поле.Имя);
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ТипУпорядочивания") Тогда
		Объект.ТипУпорядочивания =  НаправлениеСортировкиКомпоновкиДанных[СтруктураОбъекта.ТипУпорядочивания];
	КонецЕсли;

КонецПроцедуры // ЭлементПорядкаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПорядокКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ПорядокКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ПорядокСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ПорядокКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПорядокКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));

	СтруктураОбъекта.Вставить("Элементы"    , КоллекцияСКДВМассив(Объект.Элементы));

	Возврат СтруктураОбъекта;
	
КонецФункции // ПорядокСКДВСтруктуру()

// Процедура - заполняет объект СКД ПорядокКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ПорядокКомпоновкиДанных   - заполняемый объект
// 	СтруктураОбъекта   - Структура                 - данные для заполнения объекта
//
Процедура ПорядокСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ПорядокКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы", Истина);
	
КонецПроцедуры // ПорядокСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// НастройкиВложенногоОбъектаКомпоновкиДанных
// 
// Параметры:
// 	Объект             - НастройкиВложенногоОбъектаКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция НастройкиВложенногоОбъектаСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "НастройкиВложенногоОбъектаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"                 , "НастройкиВложенногоОбъектаКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Идентификатор"       , Объект.Идентификатор);
	СтруктураОбъекта.Вставить("ИдентификаторОбъекта", Объект.ИдентификаторОбъекта);
	СтруктураОбъекта.Вставить("Имя"                 , Объект.Имя);
	СтруктураОбъекта.Вставить("Использование"       , Объект.Использование);
	
	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));
	// TODO: проверить родителя
	СтруктураОбъекта.Вставить("Настройки", ЗначениеСКДВСтруктуру(Объект.Настройки));
	
	Возврат СтруктураОбъекта;
	
КонецФункции // НастройкиВложенногоОбъектаСКДВСтруктуру()

// Процедура - заполняет объект СКД НастройкиВложенногоОбъектаКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - НастройкиВложенногоОбъектаКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                                  - данные для заполнения объекта
//
Процедура НастройкиВложенногоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");

	Если СтруктураОбъекта.Свойство("ИдентификаторОбъекта") Тогда
		Объект.УстановитьИдентификатор(СтруктураОбъекта.ИдентификаторОбъекта);
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Настройки", Истина);

КонецПроцедуры // НастройкиВложенногоОбъектаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ГруппировкаКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ГруппировкаКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ГруппировкаСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ГруппировкаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ГруппировкаКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Тип"             , "ГруппировкаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Идентификатор"   , Объект.Идентификатор);
	СтруктураОбъекта.Вставить("Имя"             , Объект.Имя);
	СтруктураОбъекта.Вставить("Использование"   , Объект.Использование);
	
	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);

	СтруктураОбъекта.Вставить("Выбор"             , ЗначениеСКДВСтруктуру(Объект.Выбор));
	СтруктураОбъекта.Вставить("Отбор"             , ЗначениеСКДВСтруктуру(Объект.Отбор));
	СтруктураОбъекта.Вставить("ПараметрыВывода"   , ЗначениеСКДВСтруктуру(Объект.ПараметрыВывода));
	СтруктураОбъекта.Вставить("ПоляГруппировки"   , ЗначениеСКДВСтруктуру(Объект.ПоляГруппировки));
	СтруктураОбъекта.Вставить("Порядок"           , ЗначениеСКДВСтруктуру(Объект.Порядок));
	СтруктураОбъекта.Вставить("УсловноеОформление", ЗначениеСКДВСтруктуру(Объект.УсловноеОформление));
	СтруктураОбъекта.Вставить("РежимОтображения"  , ПеречислениеСКДВСтроку(Объект.РежимОтображения));

	// TODO: проверить родителя
	СтруктураОбъекта.Вставить("Состояние",
	                          ПеречислениеСКДВСтроку(Объект.Состояние));
	                          
	СтруктураОбъекта.Вставить("Структура"    , КоллекцияСКДВМассив(Объект.Структура));

 	Возврат СтруктураОбъекта;
	
КонецФункции // ГруппировкаСКДВСтруктуру()

// Процедура - заполняет объект СКД ГруппировкаКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ГруппировкаКомпоновкиДанных   - заполняемый объект
// 	СтруктураОбъекта   - Структура                     - данные для заполнения объекта
//
Процедура ГруппировкаСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ГруппировкаКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Выбор", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Отбор", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПараметрыВывода", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПоляГруппировки", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Порядок", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "УсловноеОформление", Истина);

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("Состояние") Тогда
		Объект.Состояние = СостояниеЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.Состояние];
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Структура", Истина);
	
КонецПроцедуры // ГруппировкаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ТаблицаКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ТаблицаКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ТаблицаСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ТаблицаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ТаблицаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"             , "ТаблицаКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Идентификатор"   , Объект.Идентификатор);
	СтруктураОбъекта.Вставить("Имя"             , Объект.Имя);
	СтруктураОбъекта.Вставить("Использование"   , Объект.Использование);
	
	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);

	СтруктураОбъекта.Вставить("Выбор"             , ЗначениеСКДВСтруктуру(Объект.Выбор));
	СтруктураОбъекта.Вставить("ПараметрыВывода"   , ЗначениеСКДВСтруктуру(Объект.ПараметрыВывода));
	СтруктураОбъекта.Вставить("УсловноеОформление", ЗначениеСКДВСтруктуру(Объект.УсловноеОформление));
	СтруктураОбъекта.Вставить("РежимОтображения"  , ПеречислениеСКДВСтроку(Объект.РежимОтображения));
	// TODO: проверить родителя
	                          
	СтруктураОбъекта.Вставить("Колонки", КоллекцияСКДВМассив(Объект.Колонки));
	СтруктураОбъекта.Вставить("Строки" , КоллекцияСКДВМассив(Объект.Строки));
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ТаблицаСКДВСтруктуру()

// Процедура - заполняет объект СКД ТаблицаКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ТаблицаКомпоновкиДанных   - заполняемый объект
// 	СтруктураОбъекта   - Структура                 - данные для заполнения объекта
//
Процедура ТаблицаСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ТаблицаКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Выбор", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПараметрыВывода", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "УсловноеОформление", Истина);

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Колонки");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Строки");
	
КонецПроцедуры // ТаблицаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ДиаграммаКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ДиаграммаКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ДиаграммаСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ДиаграммаКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ДиаграммаКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"             , "ДиаграммаКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Идентификатор"   , Объект.Идентификатор);
	СтруктураОбъекта.Вставить("Имя"             , Объект.Имя);
	СтруктураОбъекта.Вставить("Использование"   , Объект.Использование);
	
	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);
	                          
	СтруктураОбъекта.Вставить("Выбор"             , ЗначениеСКДВСтруктуру(Объект.Выбор));
	СтруктураОбъекта.Вставить("ПараметрыВывода"   , ЗначениеСКДВСтруктуру(Объект.ПараметрыВывода));
	СтруктураОбъекта.Вставить("УсловноеОформление", ЗначениеСКДВСтруктуру(Объект.УсловноеОформление));
	СтруктураОбъекта.Вставить("РежимОтображения"  , ПеречислениеСКДВСтроку(Объект.РежимОтображения));

	// TODO: проверить родителя
	                          
	СтруктураОбъекта.Вставить("Серии" , КоллекцияСКДВМассив(Объект.Серии));
	СтруктураОбъекта.Вставить("Точки" , КоллекцияСКДВМассив(Объект.Точки));
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ДиаграммаСКДВСтруктуру()

// Процедура - заполняет объект СКД ДиаграммаКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ДиаграммаКомпоновкиДанных   - заполняемый объект
// 	СтруктураОбъекта   - Структура                   - данные для заполнения объекта
//
Процедура ДиаграммаСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ДиаграммаКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Имя");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Выбор", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПараметрыВывода", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "УсловноеОформление", Истина);

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Серии");
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Точки");
	
КонецПроцедуры // ДиаграммаСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// АвтоПолеГруппировкиКомпоновкиДанных
// 
// Параметры:
// 	Объект             - АвтоПолеГруппировкиКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция АвтоПолеГруппировкиСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("АвтоПолеГруппировкиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "АвтоПолеГруппировкиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"          , "АвтоПолеГруппировкиКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Использование", Объект.Использование);
	
	Возврат СтруктураОбъекта;
	
КонецФункции // АвтоПолеГруппировкиСКДВСтруктуру()

// Процедура - заполняет объект СКД АвтоПолеГруппировкиКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - АвтоПолеГруппировкиКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                           - данные для заполнения объекта
//
Процедура АвтоПолеГруппировкиСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("АвтоПолеГруппировкиКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");

КонецПроцедуры // АвтоПолеГруппировкиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПолеГруппировкиКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ПолеГруппировкиКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ПолеГруппировкиСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ПолеГруппировкиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПолеГруппировкиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Тип"           , "ПолеГруппировкиКомпоновкиДанных");
	
	СтруктураОбъекта.Вставить("Использование" , Объект.Использование);
	СтруктураОбъекта.Вставить("НачалоПериода" , ?(ТипЗнч(Объект.НачалоПериода) = Тип("ПолеКомпоновкиДанных"),
	                                              ЗначениеСКДВСтруктуру(Объект.НачалоПериода),
	                                              Объект.НачалоПериода));
	СтруктураОбъекта.Вставить("КонецПериода"  , ?(ТипЗнч(Объект.КонецПериода) = Тип("ПолеКомпоновкиДанных"),
	                                              ЗначениеСКДВСтруктуру(Объект.КонецПериода),
	                                              Объект.КонецПериода));
	СтруктураОбъекта.Вставить("Поле"          , ЗначениеСКДВСтруктуру(Объект.Поле));
	СтруктураОбъекта.Вставить("ТипГруппировки", ПеречислениеСКДВСтроку(Объект.ТипГруппировки));
	СтруктураОбъекта.Вставить("ТипДополнения" , ПеречислениеСКДВСтроку(Объект.ТипДополнения));
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ПолеГруппировкиСКДВСтруктуру()

// Процедура - заполняет объекты СКД ПолеГруппировкиКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ПолеГруппировкиКомпоновкиДанных   - заполняемый объект
// 	СтруктураОбъекта   - Структура                         - данные для заполнения объекта
//
Процедура ПолеГруппировкиСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ПолеГруппировкиКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");

	Если СтруктураОбъекта.Свойство("НачалоПериода") Тогда
		Если ТипЗнч(СтруктураОбъекта.НачалоПериода) = Тип("Строка") Тогда
			Объект.НачалоПериода = Новый ПолеКомпоновкиДанных(СтруктураОбъекта.НачалоПериода.Имя);
		ИначеЕсли ТипЗнч(СтруктураОбъекта.НачалоПериода) = Тип("Дата") Тогда
			Объект.НачалоПериода = СтруктураОбъекта.НачалоПериода;
		Иначе
			ПоказатьСообщение(СтрШаблонВнутр("Неизвестный тип поля ""НачалоПериода"": %1", СтруктураОбъекта.НачалоПериода));
		КонецЕсли;
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("КонецПериода") Тогда
		Если ТипЗнч(СтруктураОбъекта.КонецПериода) = Тип("Строка") Тогда
			Объект.КонецПериода = Новый ПолеКомпоновкиДанных(СтруктураОбъекта.КонецПериода.Имя);
		ИначеЕсли ТипЗнч(СтруктураОбъекта.КонецПериода) = Тип("Дата") Тогда
			Объект.КонецПериода = СтруктураОбъекта.КонецПериода;
		Иначе
			ПоказатьСообщение(СтрШаблонВнутр("Неизвестный тип поля ""КонецПериода"": %1", СтруктураОбъекта.НачалоПериода));
		КонецЕсли;
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("Поле") Тогда
		Объект.Поле = Новый ПолеКомпоновкиДанных(СтруктураОбъекта.Поле.Имя);
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ТипГруппировки") Тогда
		Объект.ТипГруппировки = ТипГруппировкиКомпоновкиДанных[СтруктураОбъекта.ТипГруппировки];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ТипДополнения") Тогда
		Объект.ТипДополнения = ТипДополненияПериодаКомпоновкиДанных[СтруктураОбъекта.ТипДополнения];
	КонецЕсли;

КонецПроцедуры // ПолеГруппировкиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПоляГруппировкиКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ПоляГруппировкиКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ПоляГруппировкиСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ПоляГруппировкиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПоляГруппировкиКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Элементы" , КоллекцияСКДВМассив(Объект.Элементы));
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ПоляГруппировкиСКДВСтруктуру()

// Процедура - заполняет объект СКД ПоляГруппировкиКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ПоляГруппировкиКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                       - данные для заполнения объекта
//
Процедура ПоляГруппировкиСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ПоляГруппировкиКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы", Истина);
	
КонецПроцедуры // ПоляГруппировкиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных, ЗначенияПараметровВыводаГруппировкиТаблицыКомпоновкиДанных,
// ЗначенияПараметровВыводаГруппировкиДиаграммыКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных,          - заполняемый объект
//                       ЗначенияПараметровВыводаГруппировкиТаблицыКомпоновкиДанных
//                       ЗначенияПараметровВыводаГруппировкиДиаграммыКомпоновкиДанных
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ЗначенияПараметровВыводаГруппировкиСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если ТипЗнч(Объект) = Тип("ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных");
	ИначеЕсли ТипЗнч(Объект) = Тип("ЗначенияПараметровВыводаГруппировкиТаблицыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "ЗначенияПараметровВыводаГруппировкиТаблицыКомпоновкиДанных");
	ИначеЕсли ТипЗнч(Объект) = Тип("ЗначенияПараметровВыводаГруппировкиДиаграммыКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "ЗначенияПараметровВыводаГруппировкиДиаграммыКомпоновкиДанных");
	Иначе
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("Элементы", КоллекцияСКДВМассив(Объект.Элементы));
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ЗначенияПараметровВыводаГруппировкиСКДВСтруктуру()

// Процедура - заполняет объекты СКД ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных,
// ЗначенияПараметровВыводаГруппировкиТаблицыКомпоновкиДанных,
// ЗначенияПараметровВыводаГруппировкиДиаграммыКомпоновкиДанных из структуры описания объекта
// 
// Параметры:
// 	Объект             - ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных           - заполняемый объект
//                       ЗначенияПараметровВыводаГруппировкиТаблицыКомпоновкиДанных
//                       ЗначенияПараметровВыводаГруппировкиДиаграммыКомпоновкиДанных
// 	СтруктураОбъекта   - Структура                                                     - данные для заполнения объекта
//
Процедура ЗначенияПараметровВыводаГруппировкиСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ (ТипЗнч(Объект) = Тип("ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных")
	 ИЛИ ТипЗнч(Объект) = Тип("ЗначенияПараметровВыводаГруппировкиТаблицыКомпоновкиДанных")
	 ИЛИ ТипЗнч(Объект) = Тип("ЗначенияПараметровВыводаГруппировкиДиаграммыКомпоновкиДанных")) Тогда
		Возврат;
	КонецЕсли;
	
	ЗначенияПараметровОбъектаСКДИзСтруктуры(Объект, Объект, СтруктураОбъекта);
	
КонецПроцедуры // ЗначенияПараметровВыводаГруппировкиСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ЭлементУсловногоОформленияКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ЭлементУсловногоОформленияКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ЭлементУсловногоОформленияСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ЭлементУсловногоОформленияКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ЭлементУсловногоОформленияКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Использование", Объект.Использование);
	
	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));

	СтруктураОбъекта.Вставить("ИспользоватьВГруппировке",
	                          ПеречислениеСКДВСтроку(Объект.ИспользоватьВГруппировке));
	СтруктураОбъекта.Вставить("ИспользоватьВЗаголовке",
	                          ПеречислениеСКДВСтроку(Объект.ИспользоватьВЗаголовке));
	СтруктураОбъекта.Вставить("ИспользоватьВЗаголовкеПолей",
	                          ПеречислениеСКДВСтроку(Объект.ИспользоватьВЗаголовкеПолей));
	СтруктураОбъекта.Вставить("ИспользоватьВИерархическойГруппировке",
	                          ПеречислениеСКДВСтроку(Объект.ИспользоватьВИерархическойГруппировке));
	СтруктураОбъекта.Вставить("ИспользоватьВОбщемИтоге",
	                          ПеречислениеСКДВСтроку(Объект.ИспользоватьВОбщемИтоге));
	СтруктураОбъекта.Вставить("ИспользоватьВОтборе",
	                          ПеречислениеСКДВСтроку(Объект.ИспользоватьВОтборе));
	СтруктураОбъекта.Вставить("ИспользоватьВПараметрах",
	                          ПеречислениеСКДВСтроку(Объект.ИспользоватьВПараметрах));

	СтруктураОбъекта.Вставить("Отбор"     , ЗначениеСКДВСтруктуру(Объект.Отбор));
	СтруктураОбъекта.Вставить("Оформление", ЗначениеСКДВСтруктуру(Объект.Оформление));
	СтруктураОбъекта.Вставить("Поля"      , ЗначениеСКДВСтруктуру(Объект.Поля));
 
	СтруктураОбъекта.Вставить("Представление", Объект.Представление);

	Возврат СтруктураОбъекта;
	
КонецФункции // ЭлементУсловногоОформленияСКДВСтруктуру()

// Процедура - заполняет объект СКД ЭлементУсловногоОформленияКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ЭлементУсловногоОформленияКомпоновкиДанных  - заполняемый объект
// 	СтруктураОбъекта   - Структура                                   - данные для заполнения объекта
//
Процедура ЭлементУсловногоОформленияСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ЭлементУсловногоОформленияКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Представление");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Отбор", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Оформление", Истина);
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Поля", Истина);

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ИспользоватьВГруппировке") Тогда
		Объект.ИспользоватьВГруппировке =
			ИспользованиеУсловногоОформленияКомпоновкиДанных[СтруктураОбъекта.ИспользоватьВГруппировке];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ИспользоватьВЗаголовке") Тогда
		Объект.ИспользоватьВЗаголовке =
			ИспользованиеУсловногоОформленияКомпоновкиДанных[СтруктураОбъекта.ИспользоватьВЗаголовке];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ИспользоватьВЗаголовкеПолей") Тогда
		Объект.ИспользоватьВЗаголовкеПолей =
			ИспользованиеУсловногоОформленияКомпоновкиДанных[СтруктураОбъекта.ИспользоватьВЗаголовкеПолей];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ИспользоватьВИерархическойГруппировке") Тогда
		Объект.ИспользоватьВИерархическойГруппировке =
			ИспользованиеУсловногоОформленияКомпоновкиДанных[СтруктураОбъекта.ИспользоватьВИерархическойГруппировке];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ИспользоватьВОбщемИтоге") Тогда
		Объект.ИспользоватьВОбщемИтоге =
			ИспользованиеУсловногоОформленияКомпоновкиДанных[СтруктураОбъекта.ИспользоватьВОбщемИтоге];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ИспользоватьВОтборе") Тогда
		Объект.ИспользоватьВОтборе =
			ИспользованиеУсловногоОформленияКомпоновкиДанных[СтруктураОбъекта.ИспользоватьВОтборе];
	КонецЕсли;

	Если СтруктураОбъекта.Свойство("ИспользоватьВПараметрах") Тогда
		Объект.ИспользоватьВПараметрах =
			ИспользованиеУсловногоОформленияКомпоновкиДанных[СтруктураОбъекта.ИспользоватьВПараметрах];
	КонецЕсли;

КонецПроцедуры // ЭлементУсловногоОформленияСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// УсловноеОформлениеКомпоновкиДанных
// 
// Параметры:
// 	Объект             - УсловноеОформлениеКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция УсловноеОформлениеСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("УсловноеОформлениеКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "УсловноеОформлениеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("ИдентификаторПользовательскойНастройки",
	                          Объект.ИдентификаторПользовательскойНастройки);
	СтруктураОбъекта.Вставить("ПредставлениеПользовательскойНастройки",
	                          Объект.ПредставлениеПользовательскойНастройки);
	СтруктураОбъекта.Вставить("РежимОтображения",
	                          ПеречислениеСКДВСтроку(Объект.РежимОтображения));

	СтруктураОбъекта.Вставить("Элементы", КоллекцияСКДВМассив(Объект.Элементы));
	
	Возврат СтруктураОбъекта;
	
КонецФункции // УсловноеОформлениеСКДВСтруктуру()

// Процедура - заполняет объект СКД УсловноеОформлениеКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - УсловноеОформлениеКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                          - данные для заполнения объекта
//
Процедура УсловноеОформлениеСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("УсловноеОформлениеКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ИдентификаторПользовательскойНастройки");
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "ПредставлениеПользовательскойНастройки");

	Если СтруктураОбъекта.Свойство("РежимОтображения") Тогда
		Объект.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных[СтруктураОбъекта.РежимОтображения];
	КонецЕсли;

	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы");
	
КонецПроцедуры // УсловноеОформлениеСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ОформляемоеПолеКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ОформляемоеПолеКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ОформляемоеПолеСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ОформляемоеПолеКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ОформляемоеПолеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Использование", Объект.Использование);
	СтруктураОбъекта.Вставить("Поле"         , ЗначениеСКДВСтруктуру(Объект.Поле));
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ОформляемоеПолеСКДВСтруктуру()

// Процедура - заполняет объект СКД ОформляемоеПолеКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ОформляемоеПолеКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                       - данные для заполнения объекта
//
Процедура ОформляемоеПолеСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ОформляемоеПолеКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, "Использование");
	
	Если СтруктураОбъекта.Свойство("Поле") Тогда
		Объект.Поле = Новый ПолеКомпоновкиДанных(СтруктураОбъекта.Поле.Имя);
	КонецЕсли;
	
КонецПроцедуры // ОформляемоеПолеСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ОформляемыеПоляКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ОформляемыеПоляКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ОформляемыеПоляСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ОформляемыеПоляКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ОформляемыеПоляКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Элементы", КоллекцияСКДВМассив(Объект.Элементы));
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ОформляемыеПоляСКДВСтруктуру()

// Процедура - заполняет объект СКД ОформляемыеПоляКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ОформляемыеПоляКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                       - данные для заполнения объекта
//
Процедура ОформляемыеПоляСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ОформляемыеПоляКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, "Элементы");
	
КонецПроцедуры // ОформляемыеПоляСКДИзСтруктуры()

// Функция - заполняет и возвращает структуру описания объекта СКД
// ПолеКомпоновкиДанных
// 
// Параметры:
// 	Объект             - ОформляемыеПоляКомпоновкиДанных     - заполняемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ПолеСКДВСтруктуру(Объект)
	
	СтруктураОбъекта = Новый Структура();
	
	Если НЕ ТипЗнч(Объект) = Тип("ПолеКомпоновкиДанных") Тогда
		СтруктураОбъекта.Вставить("__Тип", "Неопределено");
		Возврат СтруктураОбъекта;
	КонецЕсли;

	СтруктураОбъекта.Вставить("__Тип", "ПолеКомпоновкиДанных");

	СтруктураОбъекта.Вставить("Имя", СокрЛП(Объект));
	
	Возврат СтруктураОбъекта;
	
КонецФункции // ПолеСКДВСтруктуру()

// Процедура - заполняет объект СКД ПолеКомпоновкиДанных
// из структуры описания объекта
// 
// Параметры:
// 	Объект             - ОформляемыеПоляКомпоновкиДанных - заполняемый объект
// 	СтруктураОбъекта   - Структура                       - данные для заполнения объекта
//
Процедура ПолеСКДИзСтруктуры(Объект, СтруктураОбъекта)
	
	Если НЕ ТипЗнч(Объект) = Тип("ПолеКомпоновкиДанных") Тогда
		Возврат;
	КонецЕсли;
	
	Объект = Новый ПолеКомпоновкиДанных(СтруктураОбъекта.Имя);
	
КонецПроцедуры // ПолеСКДИзСтруктуры()

#КонецОбласти // ПреобразованияСКДИнтерфейсныеПроцедуры

#Область ПреобразованияСКДСлужебныеПроцедурыИФункции

// Функция - заполняет и возвращает структуру описания объекта СКД
// 
// Параметры:
// 	Объект             - <Объект СКД>     - преобразуемый объект
//
// Возвращаемое значение:
// 	Структура          - структура описания объекта
//
Функция ЗначениеСКДВСтруктуру(Объект)
	
	Если ТипЗнч(Объект) = Тип("СхемаКомпоновкиДанных") Тогда
		Возврат СКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("НастройкиКомпоновкиДанных") Тогда
		Возврат НастройкиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ВариантНастроекКомпоновкиДанных") Тогда
		Возврат ВариантНастроекСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ВложеннаяСхемаКомпоновкиДанных") Тогда
		Возврат ВложеннаяСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ВычисляемоеПолеСхемыКомпоновкиДанных") Тогда
		Возврат ВычисляемоеПолеСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ИсточникДанныхСхемыКомпоновкиДанных") Тогда
		Возврат ИсточникДанныхСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ОписаниеМакетаСхемыКомпоновкиДанных") Тогда
		Возврат ОписаниеМакетаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("МакетГруппировкиСхемыКомпоновкиДанных") Тогда
		Возврат МакетГруппировкиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("МакетПоляСхемыКомпоновкиДанных") Тогда
		Возврат МакетПоляСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("МакетПолейИтогаСхемыКомпоновкиДанных") Тогда
		Возврат МакетПолейИтогаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("НаборДанныхЗапросСхемыКомпоновкиДанных") Тогда
		Возврат НаборДанныхЗапросСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("НаборДанныхОбъектСхемыКомпоновкиДанных") Тогда
		Возврат НаборДанныхОбъектСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("НаборДанныхОбъединениеСхемыКомпоновкиДанных") Тогда
		Возврат НаборДанныхОбъединениеСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПараметрСхемыКомпоновкиДанных") Тогда
		Возврат ПараметрСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПолеИтогаСхемыКомпоновкиДанных") Тогда
		Возврат ПолеИтогаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("СвязьНаборовДанныхСхемыКомпоновкиДанных") Тогда
		Возврат СвязьНаборовДанныхСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ВыражениеУпорядочиванияКомпоновкиДанных") Тогда
		Возврат ВыражениеУпорядочиванияСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ОграничениеИспользованияПоляСхемыКомпоновкиДанных") Тогда
		Возврат ОграничениеИспользованияПоляСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ОформлениеКомпоновкиДанных") Тогда
		Возврат ОформлениеСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ЗначениеПараметраНастроекКомпоновкиДанных") Тогда
		Возврат ЗначениеПараметраНастроекСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ЗначениеПараметраКомпоновкиДанных") Тогда
		Возврат ЗначениеПараметраСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПараметрыРедактированияКомпоновкиДанных") Тогда
		Возврат ПараметрыРедактированияСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("СтрокаТаблицыОбластиКомпоновкиДанных") Тогда
		Возврат СтрокаТаблицыОбластиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ЯчейкаТаблицыОбластиКомпоновкиДанных") Тогда
		Возврат ЯчейкаТаблицыОбластиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ОформлениеЯчейкиТаблицыОбластиКомпоновкиДанных") Тогда
		Возврат ОформлениеЯчейкиТаблицыОбластиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ОформлениеПоляОбластиКомпоновкиДанных") Тогда
		Возврат ОформлениеПоляОбластиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПараметрОбластиВыражениеКомпоновкиДанных") Тогда
		Возврат ПараметрОбластиВыражениеСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПараметрОбластиРасшифровкаКомпоновкиДанных") Тогда
		Возврат ПараметрОбластиРасшифровкаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ВыражениеПоляПараметраОбластиРасшифровкаКомпоновкиДанных") Тогда
		Возврат ВыражениеПоляПараметраРасшифровкиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПолеОбластиКомпоновкиДанных") Тогда
		Возврат ПолеОбластиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПолеНабораДанныхСхемыКомпоновкиДанных") Тогда
		Возврат ПолеНабораДанныхПолеСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПапкаПолейНабораДанныхСхемыКомпоновкиДанных") Тогда
		Возврат ПолеНабораДанныхПапкаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ВложенныйНаборДанныхСхемыКомпоновкиДанных") Тогда
		Возврат ПолеНабораДанныхВложенныйНаборСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ВыбранныеПоляКомпоновкиДанных") Тогда
		Возврат ВыбранныеПоляСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ГруппаВыбранныхПолейКомпоновкиДанных") Тогда
		Возврат ГруппаВыбранныхПолейСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда
		Возврат АвтоВыбранноеПолеСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ВыбранноеПолеКомпоновкиДанных") Тогда
		Возврат ВыбранноеПолеСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("РольПоляНабораДанныхКомпоновкиДанных") Тогда
		Возврат РольПоляНабораДанныхСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		Возврат ГруппаЭлементовОтбораСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		Возврат ЭлементОтбораСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ОтборКомпоновкиДанных") Тогда
		Возврат ОтборСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ЗначенияПараметровВыводаКомпоновкиДанных") Тогда
		Возврат ЗначенияПараметровВыводаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ЗначенияПараметровДанныхКомпоновкиДанных") Тогда
		Возврат ЗначенияПараметровДанныхСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПользовательскоеПолеВыражениеКомпоновкиДанных") Тогда
		Возврат ПользовательскоеПолеВыражениеСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПользовательскоеПолеВыборКомпоновкиДанных") Тогда
		Возврат ПользовательскоеПолеВыборСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПользовательскиеПоляКомпоновкиДанных") Тогда
		Возврат ПользовательскиеПоляСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ВариантПользовательскогоПоляВыборКомпоновкиДанных") Тогда
		Возврат ВариантПользовательскогоПоляВыбораСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ВариантыПользовательскогоПоляВыборКомпоновкиДанных") Тогда
		Возврат ВариантыПользовательскогоПоляВыбораСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("АвтоЭлементПорядкаКомпоновкиДанных") Тогда
		Возврат АвтоЭлементПорядкаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ЭлементПорядкаКомпоновкиДанных") Тогда
		Возврат ЭлементПорядкаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПорядокКомпоновкиДанных") Тогда
		Возврат ПорядокСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
		Возврат НастройкиВложенногоОбъектаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ГруппировкаКомпоновкиДанных") Тогда
		Возврат ГруппировкаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ТаблицаКомпоновкиДанных") Тогда
		Возврат ТаблицаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ДиаграммаКомпоновкиДанных") Тогда
		Возврат ДиаграммаСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("АвтоПолеГруппировкиКомпоновкиДанных") Тогда
		Возврат АвтоПолеГруппировкиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПолеГруппировкиКомпоновкиДанных") Тогда
		Возврат ПолеГруппировкиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПоляГруппировкиКомпоновкиДанных") Тогда
		Возврат ПоляГруппировкиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных")
	      ИЛИ ТипЗнч(Объект) = Тип("ЗначенияПараметровВыводаГруппировкиТаблицыКомпоновкиДанных")
	      ИЛИ ТипЗнч(Объект) = Тип("ЗначенияПараметровВыводаГруппировкиДиаграммыКомпоновкиДанных") Тогда
		Возврат ЗначенияПараметровВыводаГруппировкиСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ЭлементУсловногоОформленияКомпоновкиДанных") Тогда
		Возврат ЭлементУсловногоОформленияСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("УсловноеОформлениеКомпоновкиДанных") Тогда
		Возврат УсловноеОформлениеСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ОформляемоеПолеКомпоновкиДанных") Тогда
		Возврат ОформляемоеПолеСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ОформляемыеПоляКомпоновкиДанных") Тогда
		Возврат ОформляемыеПоляСКДВСтруктуру(Объект);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПолеКомпоновкиДанных") Тогда
		Возврат ПолеСКДВСтруктуру(Объект);
	Иначе
		Возврат Неопределено;
	КонецЕсли;
		
КонецФункции // ЗначениеСКДВСтруктуру()

// Процедура - заполняет объект СКД из структуры описания объекта
// 
// Параметры:
// 	Объект             - <Объект СКД>          - заполняемый объект
// 	СтруктураОбъекта   - Структура             - данные для заполнения объекта
//
Процедура ЗначениеСКДИзСтруктуры(Объект, СтруктураОбъекта)

	Если ТипЗнч(Объект) = Тип("СхемаКомпоновкиДанных") Тогда
		СКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("НастройкиКомпоновкиДанных") Тогда
		НастройкиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ВариантНастроекКомпоновкиДанных") Тогда
		ВариантНастроекСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ВложеннаяСхемаКомпоновкиДанных") Тогда
		ВложеннаяСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ВычисляемоеПолеСхемыКомпоновкиДанных") Тогда
		ВычисляемоеПолеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ИсточникДанныхСхемыКомпоновкиДанных") Тогда
		ИсточникДанныхСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ОписаниеМакетаСхемыКомпоновкиДанных") Тогда
		ОписаниеМакетаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("МакетГруппировкиСхемыКомпоновкиДанных") Тогда
		МакетГруппировкиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("МакетПоляСхемыКомпоновкиДанных") Тогда
		МакетПоляСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("МакетПолейИтогаСхемыКомпоновкиДанных") Тогда
		МакетПолейИтогаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("НаборДанныхЗапросСхемыКомпоновкиДанных") Тогда
		НаборДанныхЗапросСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("НаборДанныхОбъектСхемыКомпоновкиДанных") Тогда
		НаборДанныхОбъектСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("НаборДанныхОбъединениеСхемыКомпоновкиДанных") Тогда
		НаборДанныхОбъединениеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПараметрСхемыКомпоновкиДанных") Тогда
		ПараметрСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПолеИтогаСхемыКомпоновкиДанных") Тогда
		ПолеИтогаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("СвязьНаборовДанныхСхемыКомпоновкиДанных") Тогда
		СвязьНаборовДанныхСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ВыражениеУпорядочиванияКомпоновкиДанных") Тогда
		ВыражениеУпорядочиванияСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ОграничениеИспользованияПоляСхемыКомпоновкиДанных") Тогда
		ОграничениеИспользованияПоляСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ОформлениеКомпоновкиДанных") Тогда
		ОформлениеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ЗначениеПараметраНастроекКомпоновкиДанных") Тогда
		ЗначениеПараметраНастроекСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ЗначениеПараметраКомпоновкиДанных") Тогда
		ЗначениеПараметраСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПараметрыРедактированияКомпоновкиДанных") Тогда
		ПараметрыРедактированияСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("СтрокаТаблицыОбластиКомпоновкиДанных") Тогда
		СтрокаТаблицыОбластиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ЯчейкаТаблицыОбластиКомпоновкиДанных") Тогда
		ЯчейкаТаблицыОбластиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ОформлениеЯчейкиТаблицыОбластиКомпоновкиДанных") Тогда
		ОформлениеЯчейкиТаблицыОбластиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ОформлениеПоляОбластиКомпоновкиДанных") Тогда
		ОформлениеПоляОбластиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПараметрОбластиВыражениеКомпоновкиДанных") Тогда
		ПараметрОбластиВыражениеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПараметрОбластиРасшифровкаКомпоновкиДанных") Тогда
		ПараметрОбластиРасшифровкаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ВыражениеПоляПараметраОбластиРасшифровкаКомпоновкиДанных") Тогда
		ВыражениеПоляПараметраРасшифровкиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПолеОбластиКомпоновкиДанных") Тогда
		ПолеОбластиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПолеНабораДанныхСхемыКомпоновкиДанных") Тогда
		ПолеНабораДанныхПолеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПапкаПолейНабораДанныхСхемыКомпоновкиДанных") Тогда
		ПолеНабораДанныхПапкаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ВложенныйНаборДанныхСхемыКомпоновкиДанных") Тогда
		ПолеНабораДанныхВложенныйНаборСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ВыбранныеПоляКомпоновкиДанных") Тогда
		ВыбранныеПоляСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ГруппаВыбранныхПолейКомпоновкиДанных") Тогда
		ГруппаВыбранныхПолейСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("АвтоВыбранноеПолеКомпоновкиДанных") Тогда
		АвтоВыбранноеПолеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ВыбранноеПолеКомпоновкиДанных") Тогда
		ВыбранноеПолеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("РольПоляНабораДанныхКомпоновкиДанных") Тогда
		РольПоляНабораДанныхСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		ГруппаЭлементовОтбораСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
		ЭлементОтбораСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ОтборКомпоновкиДанных") Тогда
		ОтборСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ЗначенияПараметровВыводаКомпоновкиДанных") Тогда
		ЗначенияПараметровВыводаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ЗначенияПараметровДанныхКомпоновкиДанных") Тогда
		ЗначенияПараметровДанныхСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПользовательскоеПолеВыражениеКомпоновкиДанных") Тогда
		ПользовательскоеПолеВыражениеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПользовательскоеПолеВыборКомпоновкиДанных") Тогда
		ПользовательскоеПолеВыборСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПользовательскиеПоляКомпоновкиДанных") Тогда
		ПользовательскиеПоляСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ВариантПользовательскогоПоляВыборКомпоновкиДанных") Тогда
		ВариантПользовательскогоПоляВыбораСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ВариантыПользовательскогоПоляВыборКомпоновкиДанных") Тогда
		ВариантыПользовательскогоПоляВыбораСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("АвтоЭлементПорядкаКомпоновкиДанных") Тогда
		АвтоЭлементПорядкаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ЭлементПорядкаКомпоновкиДанных") Тогда
		ЭлементПорядкаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПорядокКомпоновкиДанных") Тогда
		ПорядокСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
		НастройкиВложенногоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ГруппировкаКомпоновкиДанных") Тогда
		ГруппировкаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ТаблицаКомпоновкиДанных") Тогда
		ТаблицаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ДиаграммаКомпоновкиДанных") Тогда
		ДиаграммаСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("АвтоПолеГруппировкиКомпоновкиДанных") Тогда
		АвтоПолеГруппировкиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПолеГруппировкиКомпоновкиДанных") Тогда
		ПолеГруппировкиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПоляГруппировкиКомпоновкиДанных") Тогда
		ПоляГруппировкиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ЗначенияПараметровВыводаГруппировкиКомпоновкиДанных")
	      ИЛИ ТипЗнч(Объект) = Тип("ЗначенияПараметровВыводаГруппировкиТаблицыКомпоновкиДанных")
	      ИЛИ ТипЗнч(Объект) = Тип("ЗначенияПараметровВыводаГруппировкиДиаграммыКомпоновкиДанных") Тогда
		ЗначенияПараметровВыводаГруппировкиСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ЭлементУсловногоОформленияКомпоновкиДанных") Тогда
		ЭлементУсловногоОформленияСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("УсловноеОформлениеКомпоновкиДанных") Тогда
		УсловноеОформлениеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ОформляемоеПолеКомпоновкиДанных") Тогда
		ОформляемоеПолеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ОформляемыеПоляКомпоновкиДанных") Тогда
		ОформляемыеПоляСКДИзСтруктуры(Объект, СтруктураОбъекта);
	ИначеЕсли ТипЗнч(Объект) = Тип("ПолеКомпоновкиДанных") Тогда
		ПолеСКДИзСтруктуры(Объект, СтруктураОбъекта);
	Иначе
		ПоказатьСообщение(СтрШаблонВнутр("Неизвестный тип объекта СКД: %1", Объект));
	КонецЕсли;

КонецПроцедуры // ЗначениеСКДИзСтруктуры()
 
// Функция - заполняет массив элементами по данным коллекции СКД
// 
// Параметры:
// 	Коллекция          - <Коллекция СКД>     - заполняемый объект
//
// Возвращаемое значение:
// 	Массив(Структура)     - массив элементов-описаний объектов
//
Функция КоллекцияСКДВМассив(Коллекция)

	МассивЭлементов = Новый Массив();
	Для Каждого ТекЭлемент Из Коллекция Цикл
		МассивЭлементов.Добавить(ЗначениеСКДВСтруктуру(ТекЭлемент));
	КонецЦикла;
	
	Возврат МассивЭлементов;

КонецФункции // КоллекцияСКДВМассив()

// Процедура - заполняет коллекцию СКД из массива описаний объектов
// 
// Параметры:
// 	Коллекция              - <Коллекция СКД>       - заполняемая коллекция
// 	МассивКоллекции        - Массив(Структура)     - данные для заполнения коллекции
// 	УстановитьТипЭлемента  - Булево                - Истина - при добавлении элемента в коллекцию,
//                                                   будет указан тип элемента
//
Процедура КоллекцияСКДИзМассива(Коллекция, МассивКоллекции, УстановитьТипЭлемента = Ложь)
	
	Для Каждого ТекЭлемент Из МассивКоллекции Цикл
		Если УстановитьТипЭлемента Тогда
			НовыйЭлемент = Коллекция.Добавить(Тип(ТекЭлемент.__Тип));
		Иначе
			НовыйЭлемент = Коллекция.Добавить();
		КонецЕсли;
		ЗначениеСКДИзСтруктуры(НовыйЭлемент, ТекЭлемент);
	КонецЦикла;

КонецПроцедуры // КоллекцияСКДИзМассива()

// Процедура - заполняет указанный элемент объекта СКД из структуры описания объекта
// 
// Параметры:
// 	Объект                 - <Объект СКД>        - заполняемый объект
// 	СтруктураОбъекта       - Структура           - данные для заполнения объекта
// 	Свойство               - Строка              - имя заполняемого свойства
// 	ЗначениеСКД            - Булево              - Истина - значение будет приобразовано в объект СКД
//
Процедура СвойствоОбъектаСКДИзСтруктуры(Объект, СтруктураОбъекта, Свойство, ЗначениеСКД = Ложь)

	Если СтруктураОбъекта.Свойство(Свойство) Тогда
		Если ЗначениеСКД Тогда
			ЗначениеСКДИзСтруктуры(Объект[Свойство], СтруктураОбъекта[Свойство]);
		Иначе
			Объект[Свойство] = СтруктураОбъекта[Свойство];
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры // СвойствоОбъектаСКДИзСтруктуры()

// Процедура - заполняет указанный элемент-коллекцию объекта СКД из структуры описания объекта
// 
// Параметры:
// 	Объект                 - <Объект СКД>        - заполняемый объект
// 	СтруктураОбъекта       - Структура           - данные для заполнения объекта
// 	Свойство               - Строка              - имя заполняемого свойства-коллекции
// 	УстановитьТипЭлемента  - Булево              - Истина - при добавлении элемента в коллекцию,
//                                                 будет указан тип элемента
//
Процедура СвойствоОбъектаСКДИзМассива(Объект, СтруктураОбъекта, Свойство, УстановитьТипЭлемента = Ложь)

	Если СтруктураОбъекта.Свойство(Свойство) Тогда
		КоллекцияСКДИзМассива(Объект[Свойство], СтруктураОбъекта[Свойство], УстановитьТипЭлемента);
	КонецЕсли;

КонецПроцедуры // СвойствоОбъектаСКДИзМассива()

#КонецОбласти // ПреобразованияСКДСлужебныеПроцедурыИФункции

#Область ПреобразованияСКДФункцииПолученияЗначенийПеречислений

// Функция - возвращает строковое представление значения перечисления СКД
// ТипМакетаОбластиКомпоновкиДанных
// 
// Параметры:
// 	Значение         - ТипМакетаОбластиКомпоновкиДанных - значение для получения стрококвого представления
// Возвращаемое значение:
// 	Строка, Неопределено - строковое представление значения
//
Функция ТипМакетаОбластиКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ТипМакетаОбластиКомпоновкиДанных.Заголовок Тогда
		Возврат "Заголовок";
	ИначеЕсли Значение = ТипМакетаОбластиКомпоновкиДанных.ЗаголовокИерархии Тогда
		Возврат "ЗаголовокИерархии";
	ИначеЕсли Значение = ТипМакетаОбластиКомпоновкиДанных.ОбщийИтогЗаголовок Тогда
		Возврат "ОбщийИтогЗаголовок";
	ИначеЕсли Значение = ТипМакетаОбластиКомпоновкиДанных.ОбщийИтогПодвал Тогда
		Возврат "ОбщийИтогПодвал";
	ИначеЕсли Значение = ТипМакетаОбластиКомпоновкиДанных.Подвал Тогда
		Возврат "Подвал";
	ИначеЕсли Значение = ТипМакетаОбластиКомпоновкиДанных.ПодвалИерархии Тогда
		Возврат "ПодвалИерархии";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ТипМакетаОбластиКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ИспользованиеПараметраКомпоновкиДанных
// 
// Параметры:
// 	Значение         - ИспользованиеПараметраКомпоновкиДанных - значение для получения стрококвого представления
// Возвращаемое значение:
// 	Строка, Неопределено - строковое представление значения
//
Функция ИспользованиеПараметраКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ИспользованиеПараметраКомпоновкиДанных.Авто Тогда
		Возврат "Авто";
	ИначеЕсли Значение = ИспользованиеПараметраКомпоновкиДанных.Всегда Тогда
		Возврат "Всегда";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ИспользованиеПараметраКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// НаправлениеСортировкиКомпоновкиДанных
// 
// Параметры:
// 	Значение         - НаправлениеСортировкиКомпоновкиДанных - значение для получения стрококвого представления
// Возвращаемое значение:
// 	Строка, Неопределено - строковое представление значения
//
Функция НаправлениеСортировкиКомпоновкиДанныхВСтроку(Значение)

	Если Значение = НаправлениеСортировкиКомпоновкиДанных.Возр Тогда
		Возврат "Возр";
	ИначеЕсли Значение = НаправлениеСортировкиКомпоновкиДанных.Убыв Тогда
		Возврат "Убыв";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // НаправлениеСортировкиКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// РежимОтображенияЭлементаНастройкиКомпоновкиДанных
// 
// Параметры:
// 	Значение         - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - значение для получения
//                                                                         стрококвого представления
// Возвращаемое значение:
// 	Строка, Неопределено - строковое представление значения
//
Функция РежимОтображенияЭлементаНастройкиКомпоновкиДанныхВСтроку(Значение)

	Если Значение = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Авто Тогда
		Возврат "Авто";
	ИначеЕсли Значение = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.БыстрыйДоступ Тогда
		Возврат "БыстрыйДоступ";
	ИначеЕсли Значение = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный Тогда
		Возврат "Недоступный";
	ИначеЕсли Значение = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Обычный Тогда
		Возврат "Обычный";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // РежимОтображенияЭлементаНастройкиКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ТипПримененияОтбораКомпоновкиДанныхВСтроку
// 
// Параметры:
// 	Значение         - ТипПримененияОтбораКомпоновкиДанныхВСтроку - значение для получения
//                                                                  стрококвого представления
// Возвращаемое значение:
// 	Строка, Неопределено - строковое представление значения
//
Функция ТипПримененияОтбораКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ТипПримененияОтбораКомпоновкиДанных.Иерархия Тогда
		Возврат "Иерархия";
	ИначеЕсли Значение = ТипПримененияОтбораКомпоновкиДанных.ТолькоИерархия Тогда
		Возврат "ТолькоИерархия";
	ИначеЕсли Значение = ТипПримененияОтбораКомпоновкиДанных.Элементы Тогда
		Возврат "Элементы";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ТипПримененияОтбораКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ТипГруппыЭлементовОтбораКомпоновкиДанных
// 
// Параметры:
// 	Значение         - ТипГруппыЭлементовОтбораКомпоновкиДанных - значение для получения
//                                                                стрококвого представления
// Возвращаемое значение:
// 	Строка, Неопределено - строковое представление значения
//
Функция ТипГруппыЭлементовОтбораКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ Тогда
		Возврат "ГруппаИ";
	ИначеЕсли Значение = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли Тогда
		Возврат "ГруппаИли";
	ИначеЕсли Значение = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаНе Тогда
		Возврат "ГруппаНе";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ТипГруппыЭлементовОтбораКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ДействиеОбработкиРасшифровкиКомпоновкиДанных
// 
// Параметры:
// 	Значение         - ДействиеОбработкиРасшифровкиКомпоновкиДанных - значение для получения
//                                                                    стрококвого представления
// Возвращаемое значение:
// 	Строка, Неопределено - строковое представление значения
//
Функция ДействиеОбработкиРасшифровкиКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ДействиеОбработкиРасшифровкиКомпоновкиДанных.Нет Тогда
		Возврат "Нет";
	ИначеЕсли Значение = ДействиеОбработкиРасшифровкиКомпоновкиДанных.ОткрытьЗначение Тогда
		Возврат "ОткрытьЗначение";
	ИначеЕсли Значение = ДействиеОбработкиРасшифровкиКомпоновкиДанных.Отфильтровать Тогда
		Возврат "Отфильтровать";
	ИначеЕсли Значение = ДействиеОбработкиРасшифровкиКомпоновкиДанных.Оформить Тогда
		Возврат "Оформить";
	ИначеЕсли Значение = ДействиеОбработкиРасшифровкиКомпоновкиДанных.Расшифровать Тогда
		Возврат "Расшифровать";
	ИначеЕсли Значение = ДействиеОбработкиРасшифровкиКомпоновкиДанных.Сгруппировать Тогда
		Возврат "Сгруппировать";
	ИначеЕсли Значение = ДействиеОбработкиРасшифровкиКомпоновкиДанных.Упорядочить Тогда
		Возврат "Упорядочить";
	Иначе      
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ДействиеОбработкиРасшифровкиКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// РасположениеПоляКомпоновкиДанных
// 
// Параметры:
// 	Значение         - РасположениеПоляКомпоновкиДанных - значение для получения
//                                                        стрококвого представления
// Возвращаемое значение:
// 	Строка, Неопределено - строковое представление значения
//
Функция РасположениеПоляКомпоновкиДанныхВСтроку(Значение)

	Если Значение = РасположениеПоляКомпоновкиДанных.Авто Тогда
		Возврат "Авто";
	ИначеЕсли Значение = РасположениеПоляКомпоновкиДанных.Вертикально Тогда
		Возврат "Вертикально";
	ИначеЕсли Значение = РасположениеПоляКомпоновкиДанных.Вместе Тогда
		Возврат "Вместе";
	ИначеЕсли Значение = РасположениеПоляКомпоновкиДанных.Горизонтально Тогда
		Возврат "Горизонтально";
	ИначеЕсли Значение = РасположениеПоляКомпоновкиДанных.ОтдельнаяКолонка Тогда
		Возврат "ОтдельнаяКолонка";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // РасположениеПоляКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ТипБухгалтерскогоОстаткаКомпоновкиДанных
// 
// Параметры:
// 	Значение         - ТипБухгалтерскогоОстаткаКомпоновкиДанных - значение для получения
//                                                                стрококвого представления
// Возвращаемое значение:
// 	Строка, Неопределено - строковое представление значения
//
Функция ТипБухгалтерскогоОстаткаКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ТипБухгалтерскогоОстаткаКомпоновкиДанных.Дебет Тогда
		Возврат "Дебет";
	ИначеЕсли Значение = ТипБухгалтерскогоОстаткаКомпоновкиДанных.Кредит Тогда
		Возврат "Кредит";
	ИначеЕсли Значение = ТипБухгалтерскогоОстаткаКомпоновкиДанных.Нет Тогда
		Возврат "Нет";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ТипБухгалтерскогоОстаткаКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ТипОстаткаКомпоновкиДанных
// 
// Параметры:
// 	Значение         - ТипОстаткаКомпоновкиДанных - значение для получения
//                                                  стрококвого представления
// Возвращаемое значение:
// 	Строка, Неопределено - строковое представление значения
//
Функция ТипОстаткаКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ТипОстаткаКомпоновкиДанных.КонечныйОстаток Тогда
		Возврат "КонечныйОстаток";
	ИначеЕсли Значение = ТипОстаткаКомпоновкиДанных.НачальныйОстаток Тогда
		Возврат "НачальныйОстаток";
	ИначеЕсли Значение = ТипОстаткаКомпоновкиДанных.Нет Тогда
		Возврат "Нет";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ТипОстаткаКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ТипПериодаКомпоновкиДанных
// 
// Параметры:
// 	Значение         - ТипПериодаКомпоновкиДанных - значение для получения
//                                                  стрококвого представления
// Возвращаемое значение:
// 	Строка, Неопределено - строковое представление значения
//
Функция ТипПериодаКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ТипПериодаКомпоновкиДанных.Дополнительный Тогда
		Возврат "Дополнительный";
	ИначеЕсли Значение = ТипПериодаКомпоновкиДанных.Основной Тогда
		Возврат "Основной";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ТипПериодаКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// СостояниеЭлементаНастройкиКомпоновкиДанных
// 
// Параметры:
// 	Значение         - СостояниеЭлементаНастройкиКомпоновкиДанных - значение для получения
//                                                                  стрококвого представления
// Возвращаемое значение:
// 	Строка, Неопределено - строковое представление значения
//
Функция СостояниеЭлементаНастройкиКомпоновкиДанныхВСтроку(Значение)

	Если Значение = СостояниеЭлементаНастройкиКомпоновкиДанных.Включен Тогда
		Возврат "Включен";
	ИначеЕсли Значение = СостояниеЭлементаНастройкиКомпоновкиДанных.Отключен Тогда
		Возврат "Отключен";
	ИначеЕсли Значение = СостояниеЭлементаНастройкиКомпоновкиДанных.УдаленПользователем Тогда
		Возврат "УдаленПользователем";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // СостояниеЭлементаНастройкиКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ТипГруппировкиКомпоновкиДанных
// 
// Параметры:
// 	Значение         - ТипГруппировкиКомпоновкиДанных - значение для получения
//                                                      стрококвого представления
// Возвращаемое значение:
// 	Строка, Неопределено - строковое представление значения
//
Функция ТипГруппировкиКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ТипГруппировкиКомпоновкиДанных.Иерархия Тогда
		Возврат "Иерархия";
	ИначеЕсли Значение = ТипГруппировкиКомпоновкиДанных.ТолькоИерархия Тогда
		Возврат "ТолькоИерархия";
	ИначеЕсли Значение = ТипГруппировкиКомпоновкиДанных.Элементы Тогда
		Возврат "Элементы";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // СостояниеЭлементаНастройкиКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ТипДополненияПериодаКомпоновкиДанных
// 
// Параметры:
// 	Значение         - ТипДополненияПериодаКомпоновкиДанных - значение для получения
//                                                            стрококвого представления
// Возвращаемое значение:
// 	Строка, Неопределено - строковое представление значения
//
Функция ТипДополненияПериодаКомпоновкиДанныхВСтроку(Значение)

	РасширенныйРежим = Ложь;
	СИ = Новый СистемнаяИнформация();
	Если СтрокаНачиснаетсяСВнутр(СИ.ВерсияПриложения, "8.3.12") Тогда
		Если Метаданные.РежимСовместимости = Метаданные.СвойстваОбъектов.РежимСовместимости["НеИспользовать"] Тогда
			РасширенныйРежим = Истина;
		КонецЕсли;
	ИначеЕсли Лев(СИ.ВерсияПриложения, 6) > "8.3.12" Тогда
		Если Метаданные.РежимСовместимости >= Метаданные.СвойстваОбъектов.РежимСовместимости["Версия8_3_12"] Тогда
			РасширенныйРежим = Истина;
		КонецЕсли;
	Иначе
		РасширенныйРежим = Ложь;
	КонецЕсли;
	
	Если Значение = ТипДополненияПериодаКомпоновкиДанных.БезДополнения Тогда
		Возврат "БезДополнения";
	ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.Год Тогда
		Возврат "Год";
	ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.Декада Тогда
		Возврат "Декада";
	ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.День Тогда
		Возврат "День";
	ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.Квартал Тогда
		Возврат "Квартал";
	ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.Месяц Тогда
		Возврат "Месяц";
	ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.Минута Тогда
		Возврат "Минута";
	ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.Неделя Тогда
		Возврат "Неделя";
	ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.Полугодие Тогда
		Возврат "Полугодие";
	ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.Секунда Тогда
		Возврат "Секунда";
	ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.Час Тогда
		Возврат "Час";
	ИначеЕсли РасширенныйРежим Тогда
		Если Значение = ТипДополненияПериодаКомпоновкиДанных.ГодОтНачалаПериода Тогда
			Возврат "ГодОтНачалаПериода";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.ГодОтНачалаПериода445 Тогда
			Возврат "ГодОтНачалаПериода445";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.ДеньОтНачалаПериода Тогда
			Возврат "ДеньОтНачалаПериода";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.КварталОтНачалаПериода Тогда
			Возврат "КварталОтНачалаПериода";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.КварталОтНачалаПериода445 Тогда
			Возврат "КварталОтНачалаПериода445";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.МесяцОтНачалаПериода Тогда
			Возврат "МесяцОтНачалаПериода";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.МесяцОтНачалаПериода445 Тогда
			Возврат "МесяцОтНачалаПериода445";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.МинутаОтНачалаПериода Тогда
			Возврат "МинутаОтНачалаПериода";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.НеделяОтНачалаПериода Тогда
			Возврат "НеделяОтНачалаПериода";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.ПолугодиеОтНачалаПериода Тогда
			Возврат "ПолугодиеОтНачалаПериода";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.ПолугодиеОтНачалаПериода445 Тогда
			Возврат "ПолугодиеОтНачалаПериода445";
		ИначеЕсли Значение = ТипДополненияПериодаКомпоновкиДанных.ЧасОтНачалаПериода Тогда
			Возврат "ЧасОтНачалаПериода";
		Иначе
			Возврат Неопределено;
		КонецЕсли;
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // ТипДополненияПериодаКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// ИспользованиеУсловногоОформленияКомпоновкиДанных
// 
// Параметры:
// 	Значение         - ИспользованиеУсловногоОформленияКомпоновкиДанных - значение для получения
//                                                                        стрококвого представления
// Возвращаемое значение:
// 	Строка, Неопределено - строковое представление значения
//
Функция ИспользованиеУсловногоОформленияКомпоновкиДанныхВСтроку(Значение)

	Если Значение = ИспользованиеУсловногоОформленияКомпоновкиДанных.Использовать Тогда
		Возврат "Использовать";
	ИначеЕсли Значение = ИспользованиеУсловногоОформленияКомпоновкиДанных.НеИспользовать Тогда
		Возврат "НеИспользовать";
	Иначе
		Возврат Неопределено;
	КонецЕсли;

КонецФункции // СостояниеЭлементаНастройкиКомпоновкиДанныхВСтроку()

// Функция - возвращает строковое представление значения перечисления СКД
// 
// Параметры:
// 	Значение             - <Перечисление СКД> - значение для получения стрококвого представления
// Возвращаемое значение:
// 	Строка, Неопределено - строковое представление значения
//
Функция ПеречислениеСКДВСтроку(Значение)
	
	Если ТипЗнч(Значение) = Тип("ТипМакетаОбластиКомпоновкиДанных") Тогда
		Возврат ТипМакетаОбластиКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("ИспользованиеПараметраКомпоновкиДанных") Тогда
		Возврат ИспользованиеПараметраКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("НаправлениеСортировкиКомпоновкиДанных") Тогда
		Возврат НаправлениеСортировкиКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("РежимОтображенияЭлементаНастройкиКомпоновкиДанных") Тогда
		Возврат РежимОтображенияЭлементаНастройкиКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("ТипПримененияОтбораКомпоновкиДанных") Тогда
		Возврат ТипПримененияОтбораКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("ТипГруппыЭлементовОтбораКомпоновкиДанных") Тогда
		Возврат ТипГруппыЭлементовОтбораКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("ДействиеОбработкиРасшифровкиКомпоновкиДанных") Тогда
		Возврат ДействиеОбработкиРасшифровкиКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("РасположениеПоляКомпоновкиДанных") Тогда
		Возврат РасположениеПоляКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("ТипБухгалтерскогоОстаткаКомпоновкиДанных") Тогда
		Возврат ТипБухгалтерскогоОстаткаКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("ТипОстаткаКомпоновкиДанных") Тогда
		Возврат ТипОстаткаКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("ТипПериодаКомпоновкиДанных") Тогда
		Возврат ТипПериодаКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("СостояниеЭлементаНастройкиКомпоновкиДанных") Тогда
		Возврат СостояниеЭлементаНастройкиКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("ТипГруппировкиКомпоновкиДанных") Тогда
		Возврат ТипГруппировкиКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("ТипДополненияПериодаКомпоновкиДанных") Тогда
		Возврат ТипДополненияПериодаКомпоновкиДанныхВСтроку(Значение);
	ИначеЕсли ТипЗнч(Значение) = Тип("ИспользованиеУсловногоОформленияКомпоновкиДанных") Тогда
		Возврат ИспользованиеУсловногоОформленияКомпоновкиДанныхВСтроку(Значение);
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
КонецФункции // ПеречислениеСКДВСтроку()

#КонецОбласти // СКДСлужебныеФункцииПолученияЗначенийПеречислений

#Область СлужебныеПроцедурыИФункции


// Процедура - выодит сообщение пользователю
// 
// Параметры:
// 	ТекстСообщения     - Строка - Текст сообщения
// 	ВызыватьИсключение - Булево - Истина - будет вызвано исключение
//
Процедура ПоказатьСообщение(ТекстСообщения, ВызыватьИсключение = Ложь)
	
	Сообщение = Новый СообщениеПользователю();
	Сообщение.Текст = ТекстСообщения;
	Сообщение.Сообщить();
	
	Если ВызыватьИсключение Тогда
		ВызватьИсключение ТекстСообщения;
	КонецЕсли;
	
КонецПроцедуры // ПоказатьСообщение()

// Процедура - дополняет текст полями структуры
// 
// Параметры:
// 	Текст             - Строка    - дополняемый текст
// 	ПарамСтруктура    - Структура - структура, поля которой добавляются
// 	ДобавлятьЗначения - Булево    - Истина - к тексту полей будут добавлены значения
//
Процедура ДополнитьТекстПолямиСтруктуры(Текст, ПарамСтруктура, ДобавлятьЗначения = Ложь)
	
	Для Каждого ТекЭлемент Из ПарамСтруктура Цикл
		Текст = Текст + Символы.ПС + ТекЭлемент.Ключ + ?(ДобавлятьЗначения, " : " + ТекЭлемент.Значение, "");
	КонецЦикла;
	
КонецПроцедуры // ДополнитьТекстПолямиСтруктуры()

// Функция "расщепляет" строку на подстроки, используя заданный 
//		разделитель. Разделитель может иметь любую длину. 
//		Если в качестве разделителя задан пробел, рядом стоящие пробелы 
//		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//		игнорируются.
//
//	Параметры: 
//		Стр            -    строка, которую необходимо разложить на подстроки. 
//		                    Параметр передается по значению.
//		Разделитель    -    строка-разделитель, по умолчанию - запятая.
//		ВключатьПустые -    Указывает необходимость включать в результат пустые строки.
//
//
//	Возвращаемое значение:
//		массив значений, элементы которого - подстроки
//
Функция СтрРазделитьВнутр(Знач Стр, Разделитель = ",", ВключатьПустые = Истина) Экспорт
	
	Попытка
		Возврат Вычислить("СтрРазделить(Стр, Разделитель, ВключатьПустые)");
	Исключение
		ПоказатьСообщение(СтрШаблонВнутр("Ошибка вызова метода СтрРазделить(): %1",
			                             ПодробноеПредставлениеОшибки(ИнформацияОбОшибке())));
	КонецПопытки;
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока Истина Цикл
			Поз = Найти(Стр, Разделитель);
			Если Поз = 0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр, Поз - 1));
			Стр = СокрЛ(Сред(Стр, Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока Истина Цикл
			Поз = Найти(Стр, Разделитель);
			Если Поз = 0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			Значение = Лев(Стр, Поз - 1);
			Если НЕ ПустаяСтрока(Значение) ИЛИ ВключатьПустые Тогда
				МассивСтрок.Добавить(Значение);
			КонецЕсли;
			Стр = Сред(Стр, Поз + ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции // СтрРазделитьВнутр()

// Функция выполняет подстановку значений в исходный текст
//
//	Параметры: 
//		Текст          - Строка   - строка для подстановки 
//		Замена1..10    - Строка   - значения подстановки
//
//	Возвращаемое значение:
//		Строка - результат подставновки
//
Функция СтрШаблонВнутр(Знач Текст, Замена1 = Неопределено, Замена2 = Неопределено, Замена3 = Неопределено,
	                          Замена4 = Неопределено, Замена5 = Неопределено, Замена6 = Неопределено,
							  Замена7 = Неопределено, Замена8 = Неопределено, Замена9 = Неопределено, Замена10 = Неопределено)
	Попытка
		Возврат Вычислить("СтрШаблон(Текст, Замена1, Замена2, Замена3,
		                                   |Замена4, Замена5, Замена6,
		                                   |Замена7, Замена8, Замена9, Замена10)");
	Исключение
		ПоказатьСообщение("Ошибка вызова метода СтрШаблон():" + Символы.ПС +
			              ПодробноеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Для й = 1 По 10 Цикл
		Значение = Вычислить("Замена" + СокрЛП(й));
		Если Значение = Неопределено Тогда
			Прервать;
		КонецЕсли;
		Текст = СтрЗаменить(Текст, "%" + СокрЛП(й), Значение);
	КонецЦикла;
	
	Возврат Текст;
	
КонецФункции // СтрШаблонВнутр()
	
// Функция проверяет что переданная строка начинается с указанной подстроки
//
//	Параметры: 
//		Строка            - Строка   - строка для проверки 
//		Подстрока         - Строка   - проверяемое начало строки
//		УчитыватьРегистр  - Булево   - Истина - проверка выполняется с учетом регистра;
//                                     Ложь - без учета регистра
//
//	Возвращаемое значение:
//		Булево   - Истина - строка начинается с указанной подстроки;
//                 Ложь - в противном случае
//
Функция СтрокаНачиснаетсяСВнутр(Строка, Подстрока = "", УчитыватьРегистр = Ложь)

	Если НЕ ЗначениеЗаполнено(Подстрока) Тогда
		Возврат Истина;
	КонецЕсли;

	Если УчитыватьРегистр Тогда
		Возврат Лев(Строка, СтрДлина(Подстрока)) = Подстрока;
	Иначе
		Возврат ВРег(Лев(Строка, СтрДлина(Подстрока))) = ВРег(Подстрока);
	КонецЕсли;

КонецФункции // СтрокаНачиснаетсяСВнутр()

// Функция - возвращает версию библиотеки
// 
// Возвращаемое значение:
// 	Строка - версия библиотеки
//
Функция Версия() Экспорт
	
	//@skip-warning
	Возврат ЭтотОбъект.ПолучитьМакет("ВерсияБиблиотеки").ПолучитьТекст();
	
КонецФункции // Версия()

#КонецОбласти // СлужебныеПроцедурыИФункции
